From 4fd038702f763317833ba3fd83490c599bcd8de3 Mon Sep 17 00:00:00 2001
From: MarvinCao <caogang440@163.com>
Date: Fri, 16 Oct 2015 10:03:42 +0800
Subject: [PATCH] from old openwrt hostapd to openwrt14.07 hostapd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

将原版本额openwrt中的hostapd odin协议移植到新版本的operwrt上
Conflicts:
	.gitignore
---
 .cproject                                        |   44 +
 .gitignore                                       |    3 +
 .project                                         |   27 +
 hostapd/Makefile                                 |   11 +
 hostapd/main.c                                   |   12 +
 src/ap/beacon.c                                  |  277 +++-
 src/ap/hostapd.c                                 |  464 +++++++
 src/ap/ieee802_11_auth.c                         |    4 +
 src/drivers/driver.h                             |   24 +
 src/drivers/driver_nl80211.c                     |  236 +++-
 src/odin/odinagent.c                             | 1564 ++++++++++++++++++++++
 src/odin/odinagent.h                             |  173 +++
 src/tstl2cl/Makefile                             |   23 +
 src/tstl2cl/Makefile.win                         |  103 ++
 src/tstl2cl/README                               |   32 +
 src/tstl2cl/c_algo.c                             |  373 ++++++
 src/tstl2cl/c_algo.h                             |  114 ++
 src/tstl2cl/c_function.c                         |  146 ++
 src/tstl2cl/c_function.h                         |  126 ++
 src/tstl2cl/c_iterator.c                         |  375 ++++++
 src/tstl2cl/c_list.c                             |  540 ++++++++
 src/tstl2cl/c_map.c                              |  197 +++
 src/tstl2cl/c_memory.c                           |   69 +
 src/tstl2cl/c_memory.h                           |   65 +
 src/tstl2cl/c_pair.c                             |   78 ++
 src/tstl2cl/c_pair.h                             |  116 ++
 src/tstl2cl/c_queue.c                            |  114 ++
 src/tstl2cl/c_set.c                              |  191 +++
 src/tstl2cl/c_stack.c                            |  109 ++
 src/tstl2cl/c_tree.c                             | 1077 +++++++++++++++
 src/tstl2cl/c_tree.h                             |  160 +++
 src/tstl2cl/c_vector.c                           |  661 +++++++++
 src/tstl2cl/doc/eng/Assignable.html              |  265 ++++
 src/tstl2cl/doc/eng/BidirectionalIterator.html   |  213 +++
 src/tstl2cl/doc/eng/BinaryFunction.html          |  210 +++
 src/tstl2cl/doc/eng/BinaryPredicate.html         |  178 +++
 src/tstl2cl/doc/eng/Container.html               |  620 +++++++++
 src/tstl2cl/doc/eng/EqualityComparable.html      |  197 +++
 src/tstl2cl/doc/eng/ForwardIterator.html         |  207 +++
 src/tstl2cl/doc/eng/InputIterator.html           |  283 ++++
 src/tstl2cl/doc/eng/Iterators.html               |  220 +++
 src/tstl2cl/doc/eng/LessThanComparable.html      |  270 ++++
 src/tstl2cl/doc/eng/List.html                    |  850 ++++++++++++
 src/tstl2cl/doc/eng/Map.html                     |  615 +++++++++
 src/tstl2cl/doc/eng/OutputIterator.html          |  398 ++++++
 src/tstl2cl/doc/eng/Predicate.html               |  161 +++
 src/tstl2cl/doc/eng/Queue.html                   |  355 +++++
 src/tstl2cl/doc/eng/RandomAccessIterator.html    |  465 +++++++
 src/tstl2cl/doc/eng/Set.html                     |  623 +++++++++
 src/tstl2cl/doc/eng/Stack.html                   |  328 +++++
 src/tstl2cl/doc/eng/UnaryFunction.html           |  186 +++
 src/tstl2cl/doc/eng/Vector.html                  |  585 ++++++++
 src/tstl2cl/doc/eng/adjacent_find.html           |  116 ++
 src/tstl2cl/doc/eng/advance.html                 |   83 ++
 src/tstl2cl/doc/eng/binary_negate.html           |  198 +++
 src/tstl2cl/doc/eng/copy.html                    |  115 ++
 src/tstl2cl/doc/eng/copy_backward.html           |   89 ++
 src/tstl2cl/doc/eng/count.html                   |  141 ++
 src/tstl2cl/doc/eng/count_if.html                |  139 ++
 src/tstl2cl/doc/eng/distance.html                |  124 ++
 src/tstl2cl/doc/eng/equal.html                   |  129 ++
 src/tstl2cl/doc/eng/fill.html                    |   78 ++
 src/tstl2cl/doc/eng/fill_n.html                  |   73 +
 src/tstl2cl/doc/eng/find.html                    |   80 ++
 src/tstl2cl/doc/eng/find_if.html                 |   92 ++
 src/tstl2cl/doc/eng/for_each.html                |   93 ++
 src/tstl2cl/doc/eng/functors.html                |  222 +++
 src/tstl2cl/doc/eng/identity.html                |  135 ++
 src/tstl2cl/doc/eng/index.html                   |  393 ++++++
 src/tstl2cl/doc/eng/introduction.html            |  215 +++
 src/tstl2cl/doc/eng/iter_swap.html               |   64 +
 src/tstl2cl/doc/eng/lexicographical_compare.html |  109 ++
 src/tstl2cl/doc/eng/pair.html                    |  346 +++++
 src/tstl2cl/doc/eng/reverse.html                 |   76 ++
 src/tstl2cl/doc/eng/search.html                  |   94 ++
 src/tstl2cl/doc/eng/select1st.html               |  139 ++
 src/tstl2cl/doc/eng/swap.html                    |   80 ++
 src/tstl2cl/doc/eng/unary_negate.html            |  201 +++
 src/tstl2cl/include/c_algorithm.h                |   58 +
 src/tstl2cl/include/c_def.h                      |   70 +
 src/tstl2cl/include/c_functional.h               |   58 +
 src/tstl2cl/include/c_iterator.h                 |  184 +++
 src/tstl2cl/include/c_list.h                     |  133 ++
 src/tstl2cl/include/c_map.h                      |  122 ++
 src/tstl2cl/include/c_queue.h                    |   95 ++
 src/tstl2cl/include/c_set.h                      |  120 ++
 src/tstl2cl/include/c_stack.h                    |   92 ++
 src/tstl2cl/include/c_utility.h                  |   59 +
 src/tstl2cl/include/c_vector.h                   |  123 ++
 src/tstl2cl/license.txt                          |   49 +
 src/tstl2cl/msvc/tstl2cl.sln                     |   21 +
 src/tstl2cl/msvc/tstl2cl.vcproj                  |  236 ++++
 src/tstl2cl/pax_global_header                    |    1 +
 src/tstl2cl/test/t_algo.c                        |  867 ++++++++++++
 src/tstl2cl/test/t_list.c                        |  627 +++++++++
 src/tstl2cl/test/t_main.c                        |   30 +
 src/tstl2cl/test/t_map.c                         |  598 +++++++++
 src/tstl2cl/test/t_queue.c                       |  147 ++
 src/tstl2cl/test/t_set.c                         |  567 ++++++++
 src/tstl2cl/test/t_stack.c                       |  143 ++
 src/tstl2cl/test/t_test.h                        |    8 +
 src/tstl2cl/test/t_tree.c                        |  672 ++++++++++
 src/tstl2cl/test/t_vector.c                      |  365 +++++
 src/tstl2cl/tstl2cl.dev                          |  409 ++++++
 104 files changed, 24209 insertions(+), 6 deletions(-)
 create mode 100644 .cproject
 create mode 100644 .project
 create mode 100644 src/odin/odinagent.c
 create mode 100644 src/odin/odinagent.h
 create mode 100644 src/tstl2cl/Makefile
 create mode 100644 src/tstl2cl/Makefile.win
 create mode 100644 src/tstl2cl/README
 create mode 100644 src/tstl2cl/c_algo.c
 create mode 100644 src/tstl2cl/c_algo.h
 create mode 100644 src/tstl2cl/c_function.c
 create mode 100644 src/tstl2cl/c_function.h
 create mode 100644 src/tstl2cl/c_iterator.c
 create mode 100644 src/tstl2cl/c_list.c
 create mode 100644 src/tstl2cl/c_map.c
 create mode 100644 src/tstl2cl/c_memory.c
 create mode 100644 src/tstl2cl/c_memory.h
 create mode 100644 src/tstl2cl/c_pair.c
 create mode 100644 src/tstl2cl/c_pair.h
 create mode 100644 src/tstl2cl/c_queue.c
 create mode 100644 src/tstl2cl/c_set.c
 create mode 100644 src/tstl2cl/c_stack.c
 create mode 100644 src/tstl2cl/c_tree.c
 create mode 100644 src/tstl2cl/c_tree.h
 create mode 100644 src/tstl2cl/c_vector.c
 create mode 100644 src/tstl2cl/doc/eng/Assignable.html
 create mode 100644 src/tstl2cl/doc/eng/BidirectionalIterator.html
 create mode 100644 src/tstl2cl/doc/eng/BinaryFunction.html
 create mode 100644 src/tstl2cl/doc/eng/BinaryPredicate.html
 create mode 100644 src/tstl2cl/doc/eng/Container.html
 create mode 100644 src/tstl2cl/doc/eng/EqualityComparable.html
 create mode 100644 src/tstl2cl/doc/eng/ForwardIterator.html
 create mode 100644 src/tstl2cl/doc/eng/InputIterator.html
 create mode 100644 src/tstl2cl/doc/eng/Iterators.html
 create mode 100644 src/tstl2cl/doc/eng/LessThanComparable.html
 create mode 100644 src/tstl2cl/doc/eng/List.html
 create mode 100644 src/tstl2cl/doc/eng/Map.html
 create mode 100644 src/tstl2cl/doc/eng/OutputIterator.html
 create mode 100644 src/tstl2cl/doc/eng/Predicate.html
 create mode 100644 src/tstl2cl/doc/eng/Queue.html
 create mode 100644 src/tstl2cl/doc/eng/RandomAccessIterator.html
 create mode 100644 src/tstl2cl/doc/eng/Set.html
 create mode 100644 src/tstl2cl/doc/eng/Stack.html
 create mode 100644 src/tstl2cl/doc/eng/UnaryFunction.html
 create mode 100644 src/tstl2cl/doc/eng/Vector.html
 create mode 100644 src/tstl2cl/doc/eng/adjacent_find.html
 create mode 100644 src/tstl2cl/doc/eng/advance.html
 create mode 100644 src/tstl2cl/doc/eng/binary_negate.html
 create mode 100644 src/tstl2cl/doc/eng/copy.html
 create mode 100644 src/tstl2cl/doc/eng/copy_backward.html
 create mode 100644 src/tstl2cl/doc/eng/count.html
 create mode 100644 src/tstl2cl/doc/eng/count_if.html
 create mode 100644 src/tstl2cl/doc/eng/distance.html
 create mode 100644 src/tstl2cl/doc/eng/equal.html
 create mode 100644 src/tstl2cl/doc/eng/fill.html
 create mode 100644 src/tstl2cl/doc/eng/fill_n.html
 create mode 100644 src/tstl2cl/doc/eng/find.html
 create mode 100644 src/tstl2cl/doc/eng/find_if.html
 create mode 100644 src/tstl2cl/doc/eng/for_each.html
 create mode 100644 src/tstl2cl/doc/eng/functors.html
 create mode 100644 src/tstl2cl/doc/eng/identity.html
 create mode 100644 src/tstl2cl/doc/eng/index.html
 create mode 100644 src/tstl2cl/doc/eng/introduction.html
 create mode 100644 src/tstl2cl/doc/eng/iter_swap.html
 create mode 100644 src/tstl2cl/doc/eng/lexicographical_compare.html
 create mode 100644 src/tstl2cl/doc/eng/pair.html
 create mode 100644 src/tstl2cl/doc/eng/reverse.html
 create mode 100644 src/tstl2cl/doc/eng/search.html
 create mode 100644 src/tstl2cl/doc/eng/select1st.html
 create mode 100644 src/tstl2cl/doc/eng/swap.html
 create mode 100644 src/tstl2cl/doc/eng/unary_negate.html
 create mode 100644 src/tstl2cl/include/c_algorithm.h
 create mode 100644 src/tstl2cl/include/c_def.h
 create mode 100644 src/tstl2cl/include/c_functional.h
 create mode 100644 src/tstl2cl/include/c_iterator.h
 create mode 100644 src/tstl2cl/include/c_list.h
 create mode 100644 src/tstl2cl/include/c_map.h
 create mode 100644 src/tstl2cl/include/c_queue.h
 create mode 100644 src/tstl2cl/include/c_set.h
 create mode 100644 src/tstl2cl/include/c_stack.h
 create mode 100644 src/tstl2cl/include/c_utility.h
 create mode 100644 src/tstl2cl/include/c_vector.h
 create mode 100644 src/tstl2cl/license.txt
 create mode 100644 src/tstl2cl/msvc/tstl2cl.sln
 create mode 100644 src/tstl2cl/msvc/tstl2cl.vcproj
 create mode 100644 src/tstl2cl/pax_global_header
 create mode 100644 src/tstl2cl/test/t_algo.c
 create mode 100644 src/tstl2cl/test/t_list.c
 create mode 100644 src/tstl2cl/test/t_main.c
 create mode 100644 src/tstl2cl/test/t_map.c
 create mode 100644 src/tstl2cl/test/t_queue.c
 create mode 100644 src/tstl2cl/test/t_set.c
 create mode 100644 src/tstl2cl/test/t_stack.c
 create mode 100644 src/tstl2cl/test/t_test.h
 create mode 100644 src/tstl2cl/test/t_tree.c
 create mode 100644 src/tstl2cl/test/t_vector.c
 create mode 100644 src/tstl2cl/tstl2cl.dev

diff --git a/.cproject b/.cproject
new file mode 100644
index 0000000..add04b7
--- /dev/null
+++ b/.cproject
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.toolchain.gnu.cross.base.660111833">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.toolchain.gnu.cross.base.660111833" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration buildProperties="" id="cdt.managedbuild.toolchain.gnu.cross.base.660111833" name="Default" parent="org.eclipse.cdt.build.core.emptycfg">
+					<folderInfo id="cdt.managedbuild.toolchain.gnu.cross.base.660111833.294246340" name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.cross.base.1073951537" name="Cross GCC" superClass="cdt.managedbuild.toolchain.gnu.cross.base">
+							<option id="cdt.managedbuild.option.gnu.cross.prefix.1268119412" name="Prefix" superClass="cdt.managedbuild.option.gnu.cross.prefix"/>
+							<option id="cdt.managedbuild.option.gnu.cross.path.1697535458" name="Path" superClass="cdt.managedbuild.option.gnu.cross.path"/>
+							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="cdt.managedbuild.targetPlatform.gnu.cross.2049311586" isAbstract="false" osList="all" superClass="cdt.managedbuild.targetPlatform.gnu.cross"/>
+							<builder id="cdt.managedbuild.builder.gnu.cross.1737449468" managedBuildOn="false" name="Gnu Make Builder.Default" superClass="cdt.managedbuild.builder.gnu.cross"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.c.compiler.993238246" name="Cross GCC Compiler" superClass="cdt.managedbuild.tool.gnu.cross.c.compiler"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.cpp.compiler.1889639766" name="Cross G++ Compiler" superClass="cdt.managedbuild.tool.gnu.cross.cpp.compiler"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.c.linker.1308426798" name="Cross GCC Linker" superClass="cdt.managedbuild.tool.gnu.cross.c.linker"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.cpp.linker.1503012283" name="Cross G++ Linker" superClass="cdt.managedbuild.tool.gnu.cross.cpp.linker"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.archiver.56214290" name="Cross GCC Archiver" superClass="cdt.managedbuild.tool.gnu.cross.archiver"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.assembler.883476851" name="Cross GCC Assembler" superClass="cdt.managedbuild.tool.gnu.cross.assembler"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="hostapd-20131120.null.1651212413" name="hostapd-20131120"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+</cproject>
diff --git a/.gitignore b/.gitignore
index ae624c9..a433559 100644
--- a/.gitignore
+++ b/.gitignore
@@ -28,3 +28,6 @@ wlantest/libwlantest.a
 wlantest/test_vectors
 wlantest/wlantest
 wlantest/wlantest_cli
+
+*.orig
+.settings/language.settings.xml
diff --git a/.project b/.project
new file mode 100644
index 0000000..ee8148a
--- /dev/null
+++ b/.project
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>hostapd-2014-06-03.1</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/hostapd/Makefile b/hostapd/Makefile
index 74640f3..2c6d16b 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -8,6 +8,8 @@ endif
 
 CFLAGS += -I$(abspath ../src)
 CFLAGS += -I$(abspath ../src/utils)
+# added by MagicCG
+CFLAGS += -I$(abspath ../src/tstl2cl/include)
 
 # Uncomment following line and set the path to your kernel tree include
 # directory if your C library does not include all header files.
@@ -40,6 +42,15 @@ endif
 
 OBJS += main.o
 OBJS += config_file.o
+ 
+# added by MagicCG
+OBJS += ../src/odin/odinagent.o
+OBJS += ../src/tstl2cl/c_algo.o ../src/tstl2cl/c_function.o ../src/tstl2cl/c_list.o \
+		../src/tstl2cl/c_memory.o ../src/tstl2cl/c_vector.o ../src/tstl2cl/c_pair.o \
+		../src/tstl2cl/c_tree.o ../src/tstl2cl/c_set.o ../src/tstl2cl/c_map.o \
+		../src/tstl2cl/c_queue.o ../src/tstl2cl/c_stack.o ../src/tstl2cl/c_iterator.o
+LIBS += -lpthread
+# ---------------
 
 OBJS += ../src/ap/hostapd.o
 OBJS += ../src/ap/wpa_auth_glue.o
diff --git a/hostapd/main.c b/hostapd/main.c
index aef9583..6543827 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -29,6 +29,9 @@
 #include "eap_register.h"
 #include "ctrl_iface.h"
 
+// added by MagicCG
+#include "odin/odinagent.h"
+
 
 struct hapd_global {
 	void **drv_priv;
@@ -574,6 +577,8 @@ int main(int argc, char *argv[])
 			debug++;
 			if (wpa_debug_level > 0)
 				wpa_debug_level--;
+			wpa_printf(MSG_INFO, "wpa_debug_level:%d, MSG_INFO:%d,MSG_DEBUG:%d",
+					wpa_debug_level, MSG_INFO, MSG_DEBUG);
 			break;
 		case 'B':
 			daemonize++;
@@ -728,6 +733,9 @@ int main(int argc, char *argv[])
 	}
 
 	hostapd_global_ctrl_iface_init(&interfaces);
+	
+	// added by MagicCG
+	odin_protocol_init(&interfaces);
 
 	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
 		wpa_printf(MSG_ERROR, "Failed to start eloop");
@@ -737,6 +745,10 @@ int main(int argc, char *argv[])
 	ret = 0;
 
  out:
+ 
+	// added by MagicCG
+	odin_protocol_deinit();
+	 
 	hostapd_global_ctrl_iface_deinit(&interfaces);
 	/* Deinitialize all interfaces */
 	for (i = 0; i < interfaces.count; i++) {
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index e360d04..e14fcd3 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -953,6 +953,226 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 }
 
 
+// added by MagicCG
+int ieee802_11_build_ap_params_odin(struct hostapd_data *hapd,
+			       struct wpa_driver_ap_params *params)
+{
+	struct ieee80211_mgmt *head = NULL;
+	u8 *tail = NULL;
+	size_t head_len = 0, tail_len = 0;
+	u8 *resp = NULL;
+	size_t resp_len = 0;
+#ifdef NEED_AP_MLME
+	u16 capab_info;
+	u8 *pos, *tailpos, *old_pos;
+
+#define BEACON_HEAD_BUF_SIZE 256
+#define BEACON_TAIL_BUF_SIZE 512
+	head = os_zalloc(BEACON_HEAD_BUF_SIZE);
+	tail_len = BEACON_TAIL_BUF_SIZE;
+#ifdef CONFIG_WPS
+	if (hapd->conf->wps_state && hapd->wps_beacon_ie)
+		tail_len += wpabuf_len(hapd->wps_beacon_ie);
+#endif /* CONFIG_WPS */
+#ifdef CONFIG_P2P
+	if (hapd->p2p_beacon_ie)
+		tail_len += wpabuf_len(hapd->p2p_beacon_ie);
+#endif /* CONFIG_P2P */
+	if (hapd->conf->vendor_elements)
+		tail_len += wpabuf_len(hapd->conf->vendor_elements);
+	tailpos = tail = os_malloc(tail_len);
+	if (head == NULL || tail == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to set beacon data");
+		os_free(head);
+		os_free(tail);
+		return -1;
+	}
+
+	head->frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
+					   WLAN_FC_STYPE_BEACON);
+	head->duration = host_to_le16(0);
+	// modified the broadcast beacon frame to the unicast beacon frame
+	// os_memset(head->da, 0xff, ETH_ALEN);
+	os_memcpy(head->da, hapd->conf->accept_mac->addr, ETH_ALEN);
+
+	os_memcpy(head->sa, hapd->own_addr, ETH_ALEN);
+	os_memcpy(head->bssid, hapd->own_addr, ETH_ALEN);
+	head->u.beacon.beacon_int =
+		host_to_le16(hapd->iconf->beacon_int);
+
+	/* hardware or low-level driver will setup seq_ctrl and timestamp */
+	capab_info = hostapd_own_capab_info(hapd, NULL, 0);
+	head->u.beacon.capab_info = host_to_le16(capab_info);
+	pos = &head->u.beacon.variable[0];
+
+	/* SSID */
+	*pos++ = WLAN_EID_SSID;
+	if (hapd->conf->ignore_broadcast_ssid == 2) {
+		/* clear the data, but keep the correct length of the SSID */
+		*pos++ = hapd->conf->ssid.ssid_len;
+		os_memset(pos, 0, hapd->conf->ssid.ssid_len);
+		pos += hapd->conf->ssid.ssid_len;
+	} else if (hapd->conf->ignore_broadcast_ssid) {
+		*pos++ = 0; /* empty SSID */
+	} else {
+		*pos++ = hapd->conf->ssid.ssid_len;
+		os_memcpy(pos, hapd->conf->ssid.ssid,
+			  hapd->conf->ssid.ssid_len);
+		pos += hapd->conf->ssid.ssid_len;
+	}
+
+	/* Supported rates */
+	pos = hostapd_eid_supp_rates(hapd, pos);
+
+	/* DS Params */
+	pos = hostapd_eid_ds_params(hapd, pos);
+
+	head_len = pos - (u8 *) head;
+
+	tailpos = hostapd_eid_country(hapd, tailpos,
+				      tail + BEACON_TAIL_BUF_SIZE - tailpos);
+
+	/* ERP Information element */
+	tailpos = hostapd_eid_erp_info(hapd, tailpos);
+
+	/* Extended supported rates */
+	tailpos = hostapd_eid_ext_supp_rates(hapd, tailpos);
+
+	/* RSN, MDIE, WPA */
+	tailpos = hostapd_eid_wpa(hapd, tailpos, tail + BEACON_TAIL_BUF_SIZE -
+				  tailpos);
+
+	tailpos = hostapd_eid_bss_load(hapd, tailpos,
+				       tail + BEACON_TAIL_BUF_SIZE - tailpos);
+
+#ifdef CONFIG_IEEE80211N
+	tailpos = hostapd_eid_ht_capabilities(hapd, tailpos);
+	tailpos = hostapd_eid_ht_operation(hapd, tailpos);
+#endif /* CONFIG_IEEE80211N */
+
+	tailpos = hostapd_eid_ext_capab(hapd, tailpos);
+
+	/*
+	 * TODO: Time Advertisement element should only be included in some
+	 * DTIM Beacon frames.
+	 */
+	tailpos = hostapd_eid_time_adv(hapd, tailpos);
+
+	tailpos = hostapd_eid_interworking(hapd, tailpos);
+	tailpos = hostapd_eid_adv_proto(hapd, tailpos);
+	tailpos = hostapd_eid_roaming_consortium(hapd, tailpos);
+	old_pos = tailpos;
+	tailpos = hostapd_eid_csa(hapd, tailpos);
+	hapd->iface->cs_c_off_beacon = (old_pos != tailpos) ?
+		tailpos - tail - 1 : 0;
+
+#ifdef CONFIG_IEEE80211AC
+	tailpos = hostapd_eid_vht_capabilities(hapd, tailpos);
+	tailpos = hostapd_eid_vht_operation(hapd, tailpos);
+#endif /* CONFIG_IEEE80211AC */
+
+	/* Wi-Fi Alliance WMM */
+	tailpos = hostapd_eid_wmm(hapd, tailpos);
+
+#ifdef CONFIG_WPS
+	if (hapd->conf->wps_state && hapd->wps_beacon_ie) {
+		os_memcpy(tailpos, wpabuf_head(hapd->wps_beacon_ie),
+			  wpabuf_len(hapd->wps_beacon_ie));
+		tailpos += wpabuf_len(hapd->wps_beacon_ie);
+	}
+#endif /* CONFIG_WPS */
+
+#ifdef CONFIG_P2P
+	if ((hapd->conf->p2p & P2P_ENABLED) && hapd->p2p_beacon_ie) {
+		os_memcpy(tailpos, wpabuf_head(hapd->p2p_beacon_ie),
+			  wpabuf_len(hapd->p2p_beacon_ie));
+		tailpos += wpabuf_len(hapd->p2p_beacon_ie);
+	}
+#endif /* CONFIG_P2P */
+#ifdef CONFIG_P2P_MANAGER
+	if ((hapd->conf->p2p & (P2P_MANAGE | P2P_ENABLED | P2P_GROUP_OWNER)) ==
+	    P2P_MANAGE)
+		tailpos = hostapd_eid_p2p_manage(hapd, tailpos);
+#endif /* CONFIG_P2P_MANAGER */
+
+#ifdef CONFIG_HS20
+	tailpos = hostapd_eid_hs20_indication(hapd, tailpos);
+#endif /* CONFIG_HS20 */
+
+	if (hapd->conf->vendor_elements) {
+		os_memcpy(tailpos, wpabuf_head(hapd->conf->vendor_elements),
+			  wpabuf_len(hapd->conf->vendor_elements));
+		tailpos += wpabuf_len(hapd->conf->vendor_elements);
+	}
+
+	tail_len = tailpos > tail ? tailpos - tail : 0;
+
+	resp = hostapd_probe_resp_offloads(hapd, &resp_len);
+#endif /* NEED_AP_MLME */
+
+	os_memset(params, 0, sizeof(*params));
+	params->head = (u8 *) head;
+	params->head_len = head_len;
+	params->tail = tail;
+	params->tail_len = tail_len;
+	params->proberesp = resp;
+	params->proberesp_len = resp_len;
+	params->dtim_period = hapd->conf->dtim_period;
+	params->beacon_int = hapd->iconf->beacon_int;
+	params->basic_rates = hapd->iface->basic_rates;
+	params->ssid = hapd->conf->ssid.ssid;
+	params->ssid_len = hapd->conf->ssid.ssid_len;
+	params->pairwise_ciphers = hapd->conf->rsn_pairwise ?
+		hapd->conf->rsn_pairwise : hapd->conf->wpa_pairwise;
+	params->group_cipher = hapd->conf->wpa_group;
+	params->key_mgmt_suites = hapd->conf->wpa_key_mgmt;
+	params->auth_algs = hapd->conf->auth_algs;
+	params->wpa_version = hapd->conf->wpa;
+	params->privacy = hapd->conf->ssid.wep.keys_set || hapd->conf->wpa ||
+		(hapd->conf->ieee802_1x &&
+		 (hapd->conf->default_wep_key_len ||
+		  hapd->conf->individual_wep_key_len));
+	switch (hapd->conf->ignore_broadcast_ssid) {
+	case 0:
+		params->hide_ssid = NO_SSID_HIDING;
+		break;
+	case 1:
+		params->hide_ssid = HIDDEN_SSID_ZERO_LEN;
+		break;
+	case 2:
+		params->hide_ssid = HIDDEN_SSID_ZERO_CONTENTS;
+		break;
+	}
+	params->isolate = hapd->conf->isolate;
+#ifdef NEED_AP_MLME
+	params->cts_protect = !!(ieee802_11_erp_info(hapd) &
+				ERP_INFO_USE_PROTECTION);
+	params->preamble = hapd->iface->num_sta_no_short_preamble == 0 &&
+		hapd->iconf->preamble == SHORT_PREAMBLE;
+	if (hapd->iface->current_mode &&
+	    hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G)
+		params->short_slot_time =
+			hapd->iface->num_sta_no_short_slot_time > 0 ? 0 : 1;
+	else
+		params->short_slot_time = -1;
+	if (!hapd->iconf->ieee80211n || hapd->conf->disable_11n)
+		params->ht_opmode = -1;
+	else
+		params->ht_opmode = hapd->iface->ht_op_mode;
+#endif /* NEED_AP_MLME */
+	params->interworking = hapd->conf->interworking;
+	if (hapd->conf->interworking &&
+	    !is_zero_ether_addr(hapd->conf->hessid))
+		params->hessid = hapd->conf->hessid;
+	params->access_network_type = hapd->conf->access_network_type;
+	params->ap_max_inactivity = hapd->conf->ap_max_inactivity;
+#ifdef CONFIG_HS20
+	params->disable_dgaf = hapd->conf->disable_dgaf;
+#endif /* CONFIG_HS20 */
+	return 0;
+}
+
+
 void ieee802_11_free_ap_params(struct wpa_driver_ap_params *params)
 {
 	os_free(params->tail);
@@ -1014,15 +1234,62 @@ fail:
 }
 
 
+// added by MagicCG
+void ieee802_11_set_beacon_odin(struct hostapd_data *hapd)
+{
+	struct wpa_driver_ap_params params;
+	struct wpabuf *beacon, *proberesp, *assocresp;
+
+	if (hapd->iface->csa_in_progress) {
+		wpa_printf(MSG_ERROR, "Cannot set beacons during CSA period");
+		return;
+	}
+
+	hapd->beacon_set_done = 1;
+
+	if (ieee802_11_build_ap_params_odin(hapd, &params) < 0)
+		return;
+
+	if (hostapd_build_ap_extra_ies(hapd, &beacon, &proberesp, &assocresp) <
+	    0)
+		goto fail;
+
+	params.beacon_ies = beacon;
+	params.proberesp_ies = proberesp;
+	params.assocresp_ies = assocresp;
+
+	if (hostapd_drv_set_ap(hapd, &params))
+		wpa_printf(MSG_ERROR, "Failed to set beacon parameters");
+	hostapd_free_ap_extra_ies(hapd, beacon, proberesp, assocresp);
+fail:
+	ieee802_11_free_ap_params(&params);
+}
+
+
 int ieee802_11_set_beacons(struct hostapd_iface *iface)
 {
 	size_t i;
 	int ret = 0;
-
-	for (i = 0; i < iface->num_bss; i++) {
-		if (iface->bss[i]->started &&
-		    ieee802_11_set_beacon(iface->bss[i]) < 0)
-			ret = -1;
+	
+	// modified by MagicCG
+	//for (i = 0; i < iface->num_bss; i++) {
+	//	if (iface->bss[i]->started &&
+	//	    ieee802_11_set_beacon(iface->bss[i]) < 0)
+	//		ret = -1;
+	//}
+	for (i = 0; i< iface->num_bss; i++) {
+		if ( i != 0 &&
+			(iface->conf->bss[i]->macaddr_acl == DENY_UNLESS_ACCEPTED) &&
+			(iface->conf->bss[i]->num_accept_mac == 1)) {
+			if (iface->bss[i]->started &&
+				ieee802_11_set_beacon_odin(iface->bss[i]) < 0)
+				ret = -1;
+		}
+		else {
+			if (iface->bss[i]->started &&
+				ieee802_11_set_beacon(iface->bss[i]) < 0)
+				ret = -1;
+		}
 	}
 
 	return ret;
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index de6c566..3f00c8d 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -447,6 +447,30 @@ static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason)
 }
 
 
+//added by MagicCG
+static int hostapd_flush_old_stations_odin(struct hostapd_data *hapd, u16 reason)
+{
+	int ret = 0;
+	//u8 addr[ETH_ALEN];
+
+	if (hostapd_drv_none(hapd) || hapd->drv_priv == NULL)
+		return 0;
+
+	wpa_dbg(hapd->msg_ctx, MSG_DEBUG, "Flushing old station entries");
+	if (hostapd_flush(hapd)) {
+		wpa_msg(hapd->msg_ctx, MSG_WARNING, "Could not connect to "
+			"kernel driver");
+		ret = -1;
+	}
+	//wpa_dbg(hapd->msg_ctx, MSG_DEBUG, "Deauthenticate all stations");
+	//os_memset(addr, 0xff, ETH_ALEN);
+	//hostapd_drv_sta_deauth(hapd, addr, reason);
+	hostapd_free_stas(hapd);
+
+	return ret;
+}
+
+
 static void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
 {
 	hostapd_free_stas(hapd);
@@ -897,6 +921,220 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first)
 }
 
 
+/**
+ * added by MagicCG
+ * hostapd_setup_bss_odin - Per-BSS setup (initialization)
+ * @hapd: Pointer to BSS data
+ * @first: Whether this BSS is the first BSS of an interface; -1 = not first,
+ *	but interface may exist
+ *
+ * This function is used to initialize all per-BSS data structures and
+ * resources. This gets called in a loop for each BSS when an interface is
+ * initialized. Most of the modules that are initialized here will be
+ * deinitialized in hostapd_cleanup().
+ */
+static int hostapd_setup_bss_odin(struct hostapd_data *hapd, int first)
+{
+	struct hostapd_bss_config *conf = hapd->conf;
+	u8 ssid[HOSTAPD_MAX_SSID_LEN + 1];
+	int ssid_len, set_ssid;
+	char force_ifname[IFNAMSIZ];
+	u8 if_addr[ETH_ALEN];
+
+	wpa_printf(MSG_DEBUG, "%s(hapd=%p (%s), first=%d)",
+		   __func__, hapd, hapd->conf->iface, first);
+
+	if (hapd->started) {
+		wpa_printf(MSG_ERROR, "%s: Interface %s was already started",
+			   __func__, hapd->conf->iface);
+		return -1;
+	}
+	hapd->started = 1;
+
+	if (!first || first == -1) {
+		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0) {
+			/* Allocate the next available BSSID. */
+			do {
+				inc_byte_array(hapd->own_addr, ETH_ALEN);
+			} while (mac_in_conf(hapd->iconf, hapd->own_addr));
+		} else {
+			/* Allocate the configured BSSID. */
+			os_memcpy(hapd->own_addr, hapd->conf->bssid, ETH_ALEN);
+
+			if (hostapd_mac_comp(hapd->own_addr,
+					     hapd->iface->bss[0]->own_addr) ==
+			    0) {
+				wpa_printf(MSG_ERROR, "BSS '%s' may not have "
+					   "BSSID set to the MAC address of "
+					   "the radio", hapd->conf->iface);
+				return -1;
+			}
+		}
+
+		hapd->interface_added = 1;
+		if (hostapd_if_add(hapd->iface->bss[0], WPA_IF_AP_BSS,
+				   hapd->conf->iface, hapd->own_addr, hapd,
+				   &hapd->drv_priv, force_ifname, if_addr,
+				   hapd->conf->bridge[0] ? hapd->conf->bridge :
+				   NULL, first == -1)) {
+			wpa_printf(MSG_ERROR, "Failed to add BSS (BSSID="
+				   MACSTR ")", MAC2STR(hapd->own_addr));
+			return -1;
+		}
+	}
+
+	if (conf->wmm_enabled < 0)
+		conf->wmm_enabled = hapd->iconf->ieee80211n;
+
+	hostapd_flush_old_stations_odin(hapd, WLAN_REASON_PREV_AUTH_NOT_VALID);
+	hostapd_set_privacy(hapd, 0);
+
+	hostapd_broadcast_wep_clear(hapd);
+	if (hostapd_setup_encryption(hapd->conf->iface, hapd))
+		return -1;
+
+	/*
+	 * Fetch the SSID from the system and use it or,
+	 * if one was specified in the config file, verify they
+	 * match.
+	 */
+	ssid_len = hostapd_get_ssid(hapd, ssid, sizeof(ssid));
+	if (ssid_len < 0) {
+		wpa_printf(MSG_ERROR, "Could not read SSID from system");
+		return -1;
+	}
+	if (conf->ssid.ssid_set) {
+		/*
+		 * If SSID is specified in the config file and it differs
+		 * from what is being used then force installation of the
+		 * new SSID.
+		 */
+		set_ssid = (conf->ssid.ssid_len != (size_t) ssid_len ||
+			    os_memcmp(conf->ssid.ssid, ssid, ssid_len) != 0);
+	} else {
+		/*
+		 * No SSID in the config file; just use the one we got
+		 * from the system.
+		 */
+		set_ssid = 0;
+		conf->ssid.ssid_len = ssid_len;
+		os_memcpy(conf->ssid.ssid, ssid, conf->ssid.ssid_len);
+	}
+
+	if (!hostapd_drv_none(hapd)) {
+		wpa_printf(MSG_ERROR, "Using interface %s with hwaddr " MACSTR
+			   " and ssid \"%s\"",
+			   hapd->conf->iface, MAC2STR(hapd->own_addr),
+			   wpa_ssid_txt(hapd->conf->ssid.ssid,
+					hapd->conf->ssid.ssid_len));
+	}
+
+	if (hostapd_setup_wpa_psk(conf)) {
+		wpa_printf(MSG_ERROR, "WPA-PSK setup failed.");
+		return -1;
+	}
+
+	/* Set SSID for the kernel driver (to be used in beacon and probe
+	 * response frames) */
+	if (set_ssid && hostapd_set_ssid(hapd, conf->ssid.ssid,
+					 conf->ssid.ssid_len)) {
+		wpa_printf(MSG_ERROR, "Could not set SSID for kernel driver");
+		return -1;
+	}
+
+	if (wpa_debug_level == MSG_MSGDUMP)
+		conf->radius->msg_dumps = 1;
+#ifndef CONFIG_NO_RADIUS
+	hapd->radius = radius_client_init(hapd, conf->radius);
+	if (hapd->radius == NULL) {
+		wpa_printf(MSG_ERROR, "RADIUS client initialization failed.");
+		return -1;
+	}
+
+	if (hapd->conf->radius_das_port) {
+		struct radius_das_conf das_conf;
+		os_memset(&das_conf, 0, sizeof(das_conf));
+		das_conf.port = hapd->conf->radius_das_port;
+		das_conf.shared_secret = hapd->conf->radius_das_shared_secret;
+		das_conf.shared_secret_len =
+			hapd->conf->radius_das_shared_secret_len;
+		das_conf.client_addr = &hapd->conf->radius_das_client_addr;
+		das_conf.time_window = hapd->conf->radius_das_time_window;
+		das_conf.require_event_timestamp =
+			hapd->conf->radius_das_require_event_timestamp;
+		das_conf.ctx = hapd;
+		das_conf.disconnect = hostapd_das_disconnect;
+		hapd->radius_das = radius_das_init(&das_conf);
+		if (hapd->radius_das == NULL) {
+			wpa_printf(MSG_ERROR, "RADIUS DAS initialization "
+				   "failed.");
+			return -1;
+		}
+	}
+#endif /* CONFIG_NO_RADIUS */
+
+	if (hostapd_acl_init(hapd)) {
+		wpa_printf(MSG_ERROR, "ACL initialization failed.");
+		return -1;
+	}
+	if (hostapd_init_wps(hapd, conf))
+		return -1;
+
+	if (authsrv_init(hapd) < 0)
+		return -1;
+
+	if (ieee802_1x_init(hapd)) {
+		wpa_printf(MSG_ERROR, "IEEE 802.1X initialization failed.");
+		return -1;
+	}
+
+	if (hapd->conf->wpa && hostapd_setup_wpa(hapd))
+		return -1;
+
+	if (accounting_init(hapd)) {
+		wpa_printf(MSG_ERROR, "Accounting initialization failed.");
+		return -1;
+	}
+
+	if (hapd->conf->ieee802_11f &&
+	    (hapd->iapp = iapp_init(hapd, hapd->conf->iapp_iface)) == NULL) {
+		wpa_printf(MSG_ERROR, "IEEE 802.11F (IAPP) initialization "
+			   "failed.");
+		return -1;
+	}
+
+#ifdef CONFIG_INTERWORKING
+	if (gas_serv_init(hapd)) {
+		wpa_printf(MSG_ERROR, "GAS server initialization failed");
+		return -1;
+	}
+
+	if (conf->qos_map_set_len &&
+	    hostapd_drv_set_qos_map(hapd, conf->qos_map_set,
+				    conf->qos_map_set_len)) {
+		wpa_printf(MSG_ERROR, "Failed to initialize QoS Map");
+		return -1;
+	}
+#endif /* CONFIG_INTERWORKING */
+
+	if (!hostapd_drv_none(hapd) && vlan_init(hapd)) {
+		wpa_printf(MSG_ERROR, "VLAN initialization failed.");
+		return -1;
+	}
+
+	if (!hapd->conf->start_disabled)
+		ieee802_11_set_beacon_odin(hapd);
+
+	if (hapd->wpa_auth && wpa_init_keys(hapd->wpa_auth) < 0)
+		return -1;
+
+	if (hapd->driver && hapd->driver->set_operstate)
+		hapd->driver->set_operstate(hapd->drv_priv, 1);
+
+	return 0;
+}
+
+
 static void hostapd_tx_queue_params(struct hostapd_iface *iface)
 {
 	struct hostapd_data *hapd = iface->bss[0];
@@ -1383,6 +1621,18 @@ static void hostapd_bss_deinit(struct hostapd_data *hapd)
 }
 
 
+//added by MagicCG
+static void hostapd_bss_deinit_odin(struct hostapd_data *hapd)
+{
+	wpa_printf(MSG_DEBUG, "%s: deinit bss %s", __func__,
+		   hapd->conf->iface);
+	hostapd_free_stas(hapd);
+	hostapd_flush_old_stations_odin(hapd, WLAN_REASON_DEAUTH_LEAVING);
+	hostapd_clear_wep(hapd);
+	hostapd_cleanup(hapd);
+}
+
+
 void hostapd_interface_deinit(struct hostapd_iface *iface)
 {
 	int j;
@@ -2006,6 +2256,154 @@ fail:
 }
 
 
+//added by MagicCG
+int hostapd_add_iface_odin(struct hapd_interfaces *interfaces, char *buf)
+{
+	struct hostapd_config *conf = NULL;
+	struct hostapd_iface *hapd_iface = NULL, *new_iface = NULL;
+	struct hostapd_data *hapd;
+	char *ptr;
+	size_t i, j;
+	const char *conf_file = NULL, *phy_name = NULL;
+
+	if (os_strncmp(buf, "bss_config=", 11) == 0) {
+		char *pos;
+		phy_name = buf + 11;
+		pos = os_strchr(phy_name, ':');
+		if (!pos)
+			return -1;
+		*pos++ = '\0';
+		conf_file = pos;
+		if (!os_strlen(conf_file))
+			return -1;
+
+		hapd_iface = hostapd_interface_init_bss(interfaces, phy_name,
+							conf_file, 0);
+		if (!hapd_iface)
+			return -1;
+		for (j = 0; j < interfaces->count; j++) {
+			if (interfaces->iface[j] == hapd_iface)
+				break;
+		}
+		if (j == interfaces->count) {
+			struct hostapd_iface **tmp;
+			tmp = os_realloc_array(interfaces->iface,
+					       interfaces->count + 1,
+					       sizeof(struct hostapd_iface *));
+			if (!tmp) {
+				hostapd_interface_deinit_free(hapd_iface);
+				return -1;
+			}
+			interfaces->iface = tmp;
+			interfaces->iface[interfaces->count++] = hapd_iface;
+			new_iface = hapd_iface;
+		}
+
+		if (new_iface) {
+			if (interfaces->driver_init(hapd_iface) ||
+			    hostapd_setup_interface(hapd_iface)) {
+				interfaces->count--;
+				goto fail;
+			}
+		} else {
+			/* Assign new BSS with bss[0]'s driver info */
+			hapd = hapd_iface->bss[hapd_iface->num_bss - 1];
+			hapd->driver = hapd_iface->bss[0]->driver;
+			hapd->drv_priv = hapd_iface->bss[0]->drv_priv;
+			os_memcpy(hapd->own_addr, hapd_iface->bss[0]->own_addr,
+				  ETH_ALEN);
+
+			if (start_ctrl_iface_bss(hapd) < 0 ||
+			    (hapd_iface->state == HAPD_IFACE_ENABLED &&
+			     hostapd_setup_bss_odin(hapd, -1))) {
+				hapd_iface->conf->num_bss--;
+				hapd_iface->num_bss--;
+				wpa_printf(MSG_DEBUG, "%s: free hapd %p %s",
+					   __func__, hapd, hapd->conf->iface);
+				os_free(hapd);
+				return -1;
+			}
+		}
+		return 0;
+	}
+
+	ptr = os_strchr(buf, ' ');
+	if (ptr == NULL)
+		return -1;
+	*ptr++ = '\0';
+
+	if (os_strncmp(ptr, "config=", 7) == 0)
+		conf_file = ptr + 7;
+
+	for (i = 0; i < interfaces->count; i++) {
+		if (!os_strcmp(interfaces->iface[i]->conf->bss[0]->iface,
+			       buf)) {
+			wpa_printf(MSG_INFO, "Cannot add interface - it "
+				   "already exists");
+			return -1;
+		}
+	}
+
+	hapd_iface = hostapd_iface_alloc(interfaces);
+	if (hapd_iface == NULL) {
+		wpa_printf(MSG_ERROR, "%s: Failed to allocate memory "
+			   "for interface", __func__);
+		goto fail;
+	}
+
+	if (conf_file && interfaces->config_read_cb) {
+		conf = interfaces->config_read_cb(conf_file);
+		if (conf && conf->bss)
+			os_strlcpy(conf->bss[0]->iface, buf,
+				   sizeof(conf->bss[0]->iface));
+	} else
+		conf = hostapd_config_alloc(interfaces, buf, ptr);
+	if (conf == NULL || conf->bss == NULL) {
+		wpa_printf(MSG_ERROR, "%s: Failed to allocate memory "
+			   "for configuration", __func__);
+		goto fail;
+	}
+
+	hapd_iface = hostapd_data_alloc(interfaces, conf);
+	if (hapd_iface == NULL) {
+		wpa_printf(MSG_ERROR, "%s: Failed to allocate memory "
+			   "for hostapd", __func__);
+		goto fail;
+	}
+
+	if (start_ctrl_iface(hapd_iface) < 0)
+		goto fail;
+
+	wpa_printf(MSG_INFO, "Add interface '%s'", conf->bss[0]->iface);
+
+	return 0;
+
+fail:
+	if (conf)
+		hostapd_config_free(conf);
+	if (hapd_iface) {
+		if (hapd_iface->bss) {
+			for (i = 0; i < hapd_iface->num_bss; i++) {
+				hapd = hapd_iface->bss[i];
+				if (hapd && hapd_iface->interfaces &&
+				    hapd_iface->interfaces->ctrl_iface_deinit)
+					hapd_iface->interfaces->
+						ctrl_iface_deinit(hapd);
+				wpa_printf(MSG_DEBUG, "%s: free hapd %p (%s)",
+					   __func__, hapd_iface->bss[i],
+					hapd_iface->bss[i]->conf->iface);
+				os_free(hapd_iface->bss[i]);
+			}
+			os_free(hapd_iface->bss);
+		}
+		wpa_printf(MSG_DEBUG, "%s: free iface %p",
+			   __func__, hapd_iface);
+		os_free(hapd_iface);
+	}
+	return -1;
+}
+
+
 static int hostapd_remove_bss(struct hostapd_iface *iface, unsigned int idx)
 {
 	size_t i;
@@ -2039,6 +2437,40 @@ static int hostapd_remove_bss(struct hostapd_iface *iface, unsigned int idx)
 }
 
 
+//added by MagicCG
+static int hostapd_remove_bss_odin(struct hostapd_iface *iface, unsigned int idx)
+{
+	size_t i;
+
+	wpa_printf(MSG_INFO, "Remove BSS '%s'", iface->conf->bss[idx]->iface);
+
+	/* Remove hostapd_data only if it has already been initialized */
+	if (idx < iface->num_bss) {
+		struct hostapd_data *hapd = iface->bss[idx];
+
+		hostapd_bss_deinit_odin(hapd);
+		wpa_printf(MSG_DEBUG, "%s: free hapd %p (%s)",
+			   __func__, hapd, hapd->conf->iface);
+		hostapd_config_free_bss(hapd->conf);
+		os_free(hapd);
+
+		iface->num_bss--;
+
+		for (i = idx; i < iface->num_bss; i++)
+			iface->bss[i] = iface->bss[i + 1];
+	} else {
+		hostapd_config_free_bss(iface->conf->bss[idx]);
+		iface->conf->bss[idx] = NULL;
+	}
+
+	iface->conf->num_bss--;
+	for (i = idx; i < iface->conf->num_bss; i++)
+		iface->conf->bss[i] = iface->conf->bss[i + 1];
+
+	return 0;
+}
+
+
 int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 {
 	struct hostapd_iface *hapd_iface;
@@ -2078,6 +2510,38 @@ int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 }
 
 
+//added by MagicCG
+int hostapd_remove_iface_odin(struct hapd_interfaces *interfaces, char *buf)
+{
+	struct hostapd_iface *hapd_iface;
+	size_t i, j, k = 0;
+
+	for (i = 0; i < interfaces->count; i++) {
+		hapd_iface = interfaces->iface[i];
+		if (hapd_iface == NULL)
+			return -1;
+		if (!os_strcmp(hapd_iface->conf->bss[0]->iface, buf)) {
+			wpa_printf(MSG_INFO, "Remove interface '%s'", buf);
+			hostapd_interface_deinit_free(hapd_iface);
+			k = i;
+			while (k < (interfaces->count - 1)) {
+				interfaces->iface[k] =
+					interfaces->iface[k + 1];
+				k++;
+			}
+			interfaces->count--;
+			return 0;
+		}
+
+		for (j = 0; j < hapd_iface->conf->num_bss; j++) {
+			if (!os_strcmp(hapd_iface->conf->bss[j]->iface, buf))
+				return hostapd_remove_bss_odin(hapd_iface, j);
+		}
+	}
+	return -1;
+}
+
+
 /**
  * hostapd_new_assoc_sta - Notify that a new station associated with the AP
  * @hapd: Pointer to BSS data
diff --git a/src/ap/ieee802_11_auth.c b/src/ap/ieee802_11_auth.c
index 56c3ce0..3678551 100644
--- a/src/ap/ieee802_11_auth.c
+++ b/src/ap/ieee802_11_auth.c
@@ -248,6 +248,10 @@ int hostapd_allowed_address(struct hostapd_data *hapd, const u8 *addr,
 	if (radius_cui)
 		*radius_cui = NULL;
 
+	//added by MagicCG
+	wpa_printf(MSG_INFO, "macaddr_acl:%d, num_accept_mac:%d, num_deny_mac:%d",
+			hapd->conf->macaddr_acl, hapd->conf->num_accept_mac, hapd->conf->num_deny_mac);
+	
 	if (hostapd_maclist_found(hapd->conf->accept_mac,
 				  hapd->conf->num_accept_mac, addr, vlan_id))
 		return HOSTAPD_ACL_ACCEPT;
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 906eb6f..b3a924f 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -1682,6 +1682,15 @@ struct wpa_driver_ops {
 	 */
 	int (*send_mlme)(void *priv, const u8 *data, size_t data_len,
 			 int noack);
+			 
+	/**
+	 * send_mntr - Send management frame using monitor interface
+	 * @priv: Private driver interface data
+	 * @data: IEEE 802.11 management frame with IEEE 802.11 header
+	 * @data_len: Size of the management frame
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*send_mntr)(void *priv, const u8 *data, size_t data_len);
 
 	/**
 	 * update_ft_ies - Update FT (IEEE 802.11r) IEs
@@ -2803,6 +2812,21 @@ struct wpa_driver_ops {
 	 * Returns: Length of written status information or -1 on failure
 	 */
 	int (*status)(void *priv, char *buf, size_t buflen);
+	
+	/**
+	 * added by MagicCG
+	 * create_odin_monitor_interface - Create the monitor interface for odin protocol
+	 * @priv: Private driver interface data
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*create_odin_monitor_interface)(void *priv);
+
+	/**
+	 * added by MagicCG
+	 * remove_odin_monitor_interface - Delete the monitor interface for odin protocol
+	 * @priv: Private driver interface data
+	 */
+	void (*remove_odin_monitor_interface)(void *priv);
 
 #ifdef CONFIG_MACSEC
 	int (*macsec_init)(void *priv, struct macsec_init_params *params);
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 0657c05..de16b88 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -39,6 +39,8 @@
 #include "radiotap_iter.h"
 #include "rfkill.h"
 #include "driver.h"
+// added by MagicCG
+#include "odin/odinagent.h"
 
 #ifndef SO_WIFI_STATUS
 # if defined(__sparc__)
@@ -8308,7 +8310,9 @@ static int nl80211_setup_ap(struct i802_bss *bss)
 
 	wpa_printf(MSG_DEBUG, "nl80211: Setup AP(%s) - device_ap_sme=%d use_monitor=%d",
 		   bss->ifname, drv->device_ap_sme, drv->use_monitor);
-
+	//added by MagicCG
+	wpa_printf(MSG_INFO, "add_bss: Setup AP(%s) - device_ap_sme=%d use_monitor=%d",
+			bss->ifname, drv->device_ap_sme, drv->use_monitor);
 	/*
 	 * Disable Probe Request reporting unless we need it in this way for
 	 * devices that include the AP SME, in the other case (unless using
@@ -11776,6 +11780,15 @@ static int driver_nl80211_send_mlme(void *priv, const u8 *data,
 }
 
 
+//added by MagicCG
+static int driver_nl80211_send_mntr(void *priv, const u8 *data,
+				    size_t data_len)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_nl80211_send_mntr(bss->drv, data, data_len, 1, 0);
+}
+
+
 static int driver_nl80211_sta_remove(void *priv, const u8 *addr)
 {
 	struct i802_bss *bss = priv;
@@ -12148,6 +12161,223 @@ error:
 }
 
 
+//added by MagicCG
+static void nl80211_remove_odin_monitor_interface(void *priv)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	nl80211_remove_monitor_interface(drv);
+}
+
+
+//added by MagicCG
+static int nl80211_create_iface_once_odin(struct wpa_driver_nl80211_data *drv,
+				     const char *ifname,
+				     enum nl80211_iftype iftype,
+				     const u8 *addr, int wds,
+				     int (*handler)(struct nl_msg *, void *),
+				     void *arg)
+{
+	struct nl_msg *msg;
+	int ifidx;
+	int ret = -ENOBUFS;
+
+	wpa_printf(MSG_DEBUG, "nl80211: Create interface iftype %d (%s)",
+		   iftype, nl80211_iftype_str(iftype));
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	nl80211_cmd(drv, msg, 0, NL80211_CMD_NEW_INTERFACE);
+	if (nl80211_set_iface_id(msg, drv->first_bss) < 0)
+		goto nla_put_failure;
+	NLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, ifname);
+	NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, iftype);
+
+	if (iftype == NL80211_IFTYPE_MONITOR) {
+		struct nlattr *flags;
+
+		flags = nla_nest_start(msg, NL80211_ATTR_MNTR_FLAGS);
+		if (!flags)
+			goto nla_put_failure;
+
+		NLA_PUT_FLAG(msg, NL80211_MNTR_FLAG_CONTROL);
+		NLA_PUT_FLAG(msg, NL80211_MNTR_FLAG_OTHER_BSS);
+
+		nla_nest_end(msg, flags);
+	} else if (wds) {
+		NLA_PUT_U8(msg, NL80211_ATTR_4ADDR, wds);
+	}
+
+	ret = send_and_recv_msgs(drv, msg, handler, arg);
+	msg = NULL;
+	if (ret) {
+ nla_put_failure:
+		nlmsg_free(msg);
+		wpa_printf(MSG_ERROR, "Failed to create interface %s: %d (%s)",
+			   ifname, ret, strerror(-ret));
+		return ret;
+	}
+
+	if (iftype == NL80211_IFTYPE_P2P_DEVICE)
+		return 0;
+
+	ifidx = if_nametoindex(ifname);
+	wpa_printf(MSG_DEBUG, "nl80211: New interface %s created: ifindex=%d",
+		   ifname, ifidx);
+
+	if (ifidx <= 0)
+		return -1;
+
+	/* start listening for EAPOL on this interface */
+	add_ifidx(drv, ifidx);
+
+	if (addr && iftype != NL80211_IFTYPE_MONITOR &&
+	    linux_set_ifhwaddr(drv->global->ioctl_sock, ifname, addr)) {
+		nl80211_remove_iface(drv, ifidx);
+		return -1;
+	}
+
+	return ifidx;
+}
+
+
+//added by MagicCG
+static int nl80211_create_iface_odin(struct wpa_driver_nl80211_data *drv,
+				const char *ifname, enum nl80211_iftype iftype,
+				const u8 *addr, int wds,
+				int (*handler)(struct nl_msg *, void *),
+				void *arg, int use_existing)
+{
+	int ret;
+
+	ret = nl80211_create_iface_once_odin(drv, ifname, iftype, addr, wds, handler,
+					arg);
+
+	/* if error occurred and interface exists already */
+	if (ret == -ENFILE && if_nametoindex(ifname)) {
+		if (use_existing) {
+			wpa_printf(MSG_DEBUG, "nl80211: Continue using existing interface %s",
+				   ifname);
+			return -ENFILE;
+		}
+		wpa_printf(MSG_INFO, "Try to remove and re-create %s", ifname);
+
+		/* Try to remove the interface that was already there. */
+		nl80211_remove_iface(drv, if_nametoindex(ifname));
+
+		/* Try to create the interface again */
+		ret = nl80211_create_iface_once_odin(drv, ifname, iftype, addr,
+						wds, handler, arg);
+	}
+
+	if (ret >= 0 && is_p2p_net_interface(iftype))
+		nl80211_disable_11b_rates(drv, ret, 1);
+
+	return ret;
+}
+
+
+//added by MagicCG
+static int nl80211_create_odin_monitor_interface(void *priv)
+{
+	char buf[IFNAMSIZ];
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct sockaddr_ll ll;
+	int optval;
+	socklen_t optlen;
+
+	if (drv->monitor_ifidx >= 0) {
+		drv->monitor_refcount++;
+		wpa_printf(MSG_DEBUG, "nl80211: Re-use existing monitor interface: refcount=%d",
+			   drv->monitor_refcount);
+		return 0;
+	}
+
+	if (os_strncmp(drv->first_bss->ifname, "p2p-", 4) == 0) {
+		/*
+		 * P2P interface name is of the format p2p-%s-%d. For monitor
+		 * interface name corresponding to P2P GO, replace "p2p-" with
+		 * "mon-" to retain the same interface name length and to
+		 * indicate that it is a monitor interface.
+		 */
+		snprintf(buf, IFNAMSIZ, "mon-%s-odin", drv->first_bss->ifname + 4);
+	} else {
+		/* Non-P2P interface with AP functionality. */
+		snprintf(buf, IFNAMSIZ, "mon.%s.odin", drv->first_bss->ifname);
+	}
+
+	buf[IFNAMSIZ - 1] = '\0';
+
+	drv->monitor_ifidx =
+		nl80211_create_iface_odin(drv, buf, NL80211_IFTYPE_MONITOR, NULL,
+				     0, NULL, NULL, 0);
+
+	if (drv->monitor_ifidx == -EOPNOTSUPP) {
+		/*
+		 * This is backward compatibility for a few versions of
+		 * the kernel only that didn't advertise the right
+		 * attributes for the only driver that then supported
+		 * AP mode w/o monitor -- ath6kl.
+		 */
+		wpa_printf(MSG_DEBUG, "nl80211: Driver does not support "
+			   "monitor interface type - try to run without it");
+		drv->device_ap_sme = 1;
+	}
+
+	if (drv->monitor_ifidx < 0)
+		return -1;
+
+	if (linux_set_iface_flags(drv->global->ioctl_sock, buf, 1))
+		goto error;
+
+	memset(&ll, 0, sizeof(ll));
+	ll.sll_family = AF_PACKET;
+	ll.sll_ifindex = drv->monitor_ifidx;
+	drv->monitor_sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+	if (drv->monitor_sock < 0) {
+		wpa_printf(MSG_ERROR, "nl80211: socket[PF_PACKET,SOCK_RAW] failed: %s",
+			   strerror(errno));
+		goto error;
+	}
+
+//	if (add_monitor_filter(drv->monitor_sock)) {
+//		wpa_printf(MSG_INFO, "Failed to set socket filter for monitor "
+//			   "interface; do filtering in user space");
+//		/* This works, but will cost in performance. */
+//	}
+
+	if (bind(drv->monitor_sock, (struct sockaddr *) &ll, sizeof(ll)) < 0) {
+		wpa_printf(MSG_ERROR, "nl80211: monitor socket bind failed: %s",
+			   strerror(errno));
+		goto error;
+	}
+
+	optlen = sizeof(optval);
+	optval = 20;
+	if (setsockopt
+	    (drv->monitor_sock, SOL_SOCKET, SO_PRIORITY, &optval, optlen)) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to set socket priority: %s",
+			   strerror(errno));
+		goto error;
+	}
+
+	if (eloop_register_read_sock(drv->monitor_sock, odin_handle_monitor_read,
+				     NULL, NULL)) {
+		wpa_printf(MSG_INFO, "nl80211: Could not register monitor read socket");
+		goto error;
+	}
+
+	drv->monitor_refcount++;
+	return 0;
+ error:
+	nl80211_remove_monitor_interface(drv);
+	return -1;
+}
+
+
 #ifdef CONFIG_TESTING_OPTIONS
 static int cmd_reply_handler(struct nl_msg *msg, void *arg)
 {
@@ -12410,6 +12640,10 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.get_survey = wpa_driver_nl80211_get_survey,
 	.status = wpa_driver_nl80211_status,
 	.switch_channel = nl80211_switch_channel,
+	//added by MagicCG
+	.create_odin_monitor_interface = nl80211_create_odin_monitor_interface,
+	.remove_odin_monitor_interface = nl80211_remove_odin_monitor_interface,
+	.send_mntr = driver_nl80211_send_mntr,
 #ifdef ANDROID_P2P
 	.set_noa = wpa_driver_set_p2p_noa,
 	.get_noa = wpa_driver_get_p2p_noa,
diff --git a/src/odin/odinagent.c b/src/odin/odinagent.c
new file mode 100644
index 0000000..d73c0a8
--- /dev/null
+++ b/src/odin/odinagent.c
@@ -0,0 +1,1564 @@
+#include <pthread.h>
+#include <sys/time.h>
+#include <signal.h>
+
+#include "odin/odinagent.h"
+#include "utils/wpa_debug.h"
+#include "utils/radiotap.h"
+#include "utils/radiotap_iter.h"
+#include "drivers/driver.h"
+#include "common/ieee802_11_defs.h"
+#include "ap/ieee802_11.h"
+#include "ap/sta_info.h"
+
+char *protocol_string[15] = {"table", "channel", "interval", "rxstats",
+						  "subscriptions", "debug", "report_mean", "spectral_scan",
+						  "add_vap", "set_vap", "remove_vap", "send_probe_response",
+						  "testing_send_probe_request", "handler_update_signal_strength",
+						  "signal_strength_offset"};
+
+static inline int string_comparer(void *x, void *y)
+{
+	int length = (((String *)(x))->length) > (((String *)(y))->length) ? (((String *)(y))->length) : (((String *)(x))->length);
+	int i;
+
+	for (i = 0; i < length; i++)
+	{
+		if ( ( ((String *)(x))->str[i] - ((String *)(y))->str[i] ) == 0 ) {
+			continue;
+		}
+		else {
+			return ((String *)(x))->str[i] - ((String *)(y))->str[i];
+		}
+	}
+    return 0;
+}
+
+static inline int subscription_comparer(void * x, void * y)
+{
+	return ((Subscription *)(x))->subscription_id - ((Subscription *)(y))->subscription_id;
+}
+
+static inline int etheraddress_comparer(void * x, void * y)
+{
+	int i;
+    for (i = 0; i < ETH_ALEN; i++) {
+    	if ( ( ((EtherAddress *)(x))->mac_addr[i] - ((EtherAddress *)(y))->mac_addr[i]) == 0 ) {
+    		continue;
+    	}
+    	else {
+    		return ((EtherAddress *)(x))->mac_addr[i] - ((EtherAddress *)(y))->mac_addr[i];
+    	}
+    }
+    return 0;
+}
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+void free_map(c_pmap thiz)
+{
+	c_iterator iter = c_map_begin(thiz);
+	c_iterator end = c_map_end(thiz);
+
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		free(((c_ppair)ITER_REF(iter))->first);
+		free(((c_ppair)ITER_REF(iter))->second);
+		((c_ppair)ITER_REF(iter))->first = NULL;
+		((c_ppair)ITER_REF(iter))->second = NULL;
+		free(ITER_REF(iter));
+		c_map_erase(thiz, iter);
+	}
+	return;
+}
+
+void map_init(c_pmap *map, int (*comparer_function)(void *, void *))
+{
+	*map = (c_pmap)malloc(sizeof(c_map));
+	if(*map == NULL) {
+		wpa_printf(MSG_INFO, "malloc map error......");
+	}
+	c_map_create(*map, comparer_function);
+}
+
+void map_deinit(c_pmap *map)
+{
+	free_map(*map);
+	//c_map_clear(_sta_mapping_table);
+	//c_map_clear(_rx_stats);
+	c_map_destroy(*map);
+}
+
+void free_vector(c_pvector p)
+{
+	c_iterator iter;
+	c_iterator first, last;
+
+    first = c_vector_begin(p);
+    last = c_vector_end(p);
+    //printf("free vector is :\n");
+    for(iter = first;
+          !ITER_EQUAL(iter, last); ITER_INC(iter))
+    {
+        if(ITER_REF(iter)) {
+            free(ITER_REF(iter));
+			//c_vector_erase cannot be used here
+        }
+    }
+
+	//c_vector_erase2(p, c_vector_begin(p), c_vector_end(p));
+	c_vector_clear(p);
+}
+
+void vector_init(c_pvector *vec, int (*comparer_function)(void *, void *))
+{
+    *vec = (c_pvector)malloc(sizeof(c_vector));
+    if(*vec == NULL) {
+    	wpa_printf(MSG_INFO, "malloc vector error......");
+    }
+    __c_vector(*vec, comparer_function);
+}
+
+void vector_deinit(c_pvector *vec)
+{
+	free_vector(*vec);
+	free(*vec);//和c_map不同，此处可以使用free
+    __c_rotcev(*vec);
+}
+
+void udp_sockfd_init()
+{
+	if ((odin_udp_sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
+		wpa_printf(MSG_ERROR, "Create socket error.");
+		return;
+	}
+}
+
+void udp_sockfd_deinit()
+{
+	close(odin_udp_sockfd);
+	odin_udp_sockfd = -1;
+}
+
+void udp_send_msg(const char *dest_host, int dest_port, const char *msg) {
+	struct sockaddr_in dest_addr;
+	dest_addr.sin_family = AF_INET;
+	dest_addr.sin_port = htons(dest_port);
+	dest_addr.sin_addr.s_addr = inet_addr(dest_host);
+
+	//udp_sockfd_init();
+	if (odin_udp_sockfd == -1) {
+		udp_sockfd_init();
+	}
+	if (dest_addr.sin_addr.s_addr == INADDR_NONE) {
+		wpa_printf(MSG_ERROR, "Incorrect ip address!");
+		udp_sockfd_deinit();
+		return;
+	}
+	if(sendto(odin_udp_sockfd, msg, strlen(msg), 0, (struct sockaddr *)&dest_addr,
+						sizeof(struct sockaddr)) < 0) {
+		wpa_printf(MSG_ERROR, "Send message error.");
+		udp_sockfd_deinit();
+	    return;
+	}
+
+//	wpa_printf(MSG_INFO, "Send message:%s", msg);
+	//udp_sockfd_deinit();
+}
+
+void* ping_thread(void *arg)
+{
+	while (1) {
+		udp_send_msg(CONTROLLER, UDP_DEST_PORT, "ping");
+		sleep(2);
+	}
+}
+
+int ping_thread_init()
+{
+	if((pthread_create(&odin_thread_id, NULL, (void *) ping_thread, NULL)) != 0) {
+		wpa_printf(MSG_ERROR, "Create ping pthread error!");
+		return 0;
+	}
+	return 1;
+}
+
+void finish_thread()
+{
+  	pthread_cancel(odin_thread_id);
+ 	pthread_join(odin_thread_id, NULL);
+}
+
+protocol_type protocol_string_to_enum(const char *protocol_str)
+{
+	int i;
+
+	for(i = 0; i < PROTOCOL_TYPE_NUM; i++) {
+		if(strcasecmp(protocol_str, protocol_string[i]) == 0) {
+			return (protocol_type)i;
+		}
+	}
+	return (protocol_type)0;
+}
+
+char *add_bss_config_file(const char *ctrl_config_path, OdinStationState *state, EtherAddress *sta)
+{
+    FILE *fp_read, *fp_write, *fp_write_acl;
+    char buf_read[1024], buf_write[1024], *buf_read_pos, *bss_config;
+    //c_iterator iter, first, last;
+    String *ssid;
+    char tmp_bss_config[] = "/tmp/run/hostapd-swan.conf";
+    char tmp_accept_maclist[] = "/tmp/run/hostapd.acceptmaclist";
+
+    fp_read = fopen(ctrl_config_path, "r");
+    fp_write = fopen(tmp_bss_config, "w");
+    fp_write_acl = fopen(tmp_accept_maclist, "w");
+    bss_config = malloc(sizeof(tmp_bss_config)+16*sizeof(unsigned char));//bss_config=phy0:
+
+    sprintf(bss_config, "bss_config=phy0:%s", tmp_bss_config);
+
+    ssid = &(state->_vap_ssids);
+    /*first = c_vector_begin(state->_vap_ssids);
+    last = c_vector_end(state->_vap_ssids);
+    for(iter = first; !ITER_EQUAL(iter, last); ITER_INC(iter)){
+    	if(ITER_REF(iter))
+    		ssid = (String *)(ITER_REF(iter));
+    }*/
+
+    while (fgets(buf_read, 1024, fp_read) != NULL) {
+        buf_read_pos = buf_read;
+
+        if (strstr(buf_read_pos, "interface=wlan0") != NULL) {
+            strsep(&buf_read_pos, "=");
+
+            sprintf(buf_write, "%s=%s\n", buf_read, ssid->str);
+
+            wpa_printf(MSG_INFO, "add_bss_config_file : %s", buf_write);
+            fputs(buf_write, fp_write);
+            continue;
+        }
+        if (strstr(buf_read_pos, "bssid=") != NULL) {
+        	strsep(&buf_read_pos, "=");
+
+            sprintf(buf_write, "%s=%02x:%02x:%02x:%02x:%02x:%02x\n", buf_read, MAC2STR(state->_vap_bssid.mac_addr));
+
+            wpa_printf(MSG_INFO, "add_bss_config_file : %s", buf_write);
+            fputs(buf_write, fp_write);
+           	continue;
+        }
+        else if (strstr(buf_read_pos, "ssid=") != NULL) {
+            strsep(&buf_read_pos, "=");
+
+            sprintf(buf_write, "%s=%s\n", buf_read, ssid->str);
+
+            wpa_printf(MSG_INFO, "add_bss_config_file : %s", buf_write);
+            fputs(buf_write, fp_write);
+            continue;
+        }
+
+
+        sprintf(buf_write, "%s", buf_read);
+        //printf("%s", buf_read);
+        fputs(buf_write, fp_write);
+    }
+
+    fputs("macaddr_acl=1\n", fp_write);
+    sprintf(buf_write, "accept_mac_file=%s\n", tmp_accept_maclist);
+    fputs(buf_write, fp_write);
+
+    sprintf(buf_write, MACSTR, MAC2STR(sta->mac_addr));
+    fputs(buf_write, fp_write_acl);
+
+    fclose(fp_read);
+    fclose(fp_write);
+    fclose(fp_write_acl);
+
+    return bss_config;
+//    remove("/tmp/hostapd-swan.conf");
+
+}
+
+int remove_vap (EtherAddress *sta_mac)
+{
+	c_iterator target, map_end, vector_iter, vector_last;
+	String *sta_ssid;
+	OdinStationState *state;
+
+	target = c_map_find(_sta_mapping_table, sta_mac);
+	map_end = c_map_end(_sta_mapping_table);
+	if (ITER_EQUAL(map_end, target)) {
+		wpa_printf(MSG_INFO, "The removing VAP is not exist");
+		return -1;
+	}
+
+	state = (OdinStationState *)(((c_ppair)ITER_REF(target))->second);
+	sta_ssid = &(state->_vap_ssids);
+
+	//for remove the bss
+	hostapd_remove_iface_odin(interfaces, sta_ssid->str);
+	//vector_deinit(&(state->_vap_ssids));
+
+	free(((c_ppair)ITER_REF(target))->first);
+	free(((c_ppair)ITER_REF(target))->second);
+	((c_ppair)ITER_REF(target))->first = NULL;
+	((c_ppair)ITER_REF(target))->second = NULL;
+	free(ITER_REF(target));
+	c_map_erase(_sta_mapping_table, target);
+
+	return 0;
+}
+
+int add_vap (EtherAddress sta_mac, IPAddress sta_ip, EtherAddress vap_bssid, String *ssid)
+{
+	c_iterator target, map_end;
+	c_pair *p;
+	OdinStationState *state;
+	EtherAddress *sta_mac_p;
+	char *bss_config;
+	char *ctrl_config_path = "/root/hostapd-phy0.conf";
+	struct sta_info *sta;
+	struct hostapd_data *hapd;
+	int i;
+
+	u8 supp_rates[4] = {2, 4, 11, 22};
+	struct ieee80211_ht_capabilities cap;
+	struct hostapd_hw_modes *current_mode;
+	u16 num_modes;
+	u16 flags;
+	//char bss_config[] = "bss_config=phy0:/root/hostapd-swan.conf";
+
+	target = c_map_find(_sta_mapping_table, &sta_mac);
+	map_end = c_map_end(_sta_mapping_table);
+	if (!ITER_EQUAL(map_end, target))
+	{
+		wpa_printf(MSG_INFO, "Ignoring VAP add request because it has already been assigned a slot");
+		return -1;
+	}
+
+	state = (OdinStationState *)malloc(sizeof(OdinStationState) + (ssid->length)*sizeof(unsigned char));
+	//state->_vap_bssid = vap_bssid;
+	//state->_sta_ip_addr_v4 = sta_ip;
+	memcpy(state->_vap_bssid.mac_addr, vap_bssid.mac_addr, ETH_ALEN);
+	memcpy(state->_sta_ip_addr_v4.ip, sta_ip.ip, IP_ALEN);
+	//state->_vap_ssids = ssid; // _vap_ssids needed to be freed when the lvap is removed
+	state->_vap_ssids.length = ssid->length;
+	memcpy(state->_vap_ssids.str, ssid->str, (ssid->length)*sizeof(unsigned char));
+	sta_mac_p = (EtherAddress *)malloc(sizeof(EtherAddress));
+	*sta_mac_p = sta_mac;
+	//memcpy(sta_mac_p, sta_mac, sizeof(sta_mac));
+
+	p = (c_pair *)malloc(sizeof(c_pair));
+	*p = c_make_pair(sta_mac_p, state);
+	c_map_insert(_sta_mapping_table, p);
+	//_sta_mapping_table.set(sta_mac, state);
+	wpa_printf(MSG_INFO, "ssid address %x", ssid);
+	wpa_printf(MSG_INFO, "state's _vap_ssids address %x", &(state->_vap_ssids));
+	//now registing the hostapd beacon frame
+	bss_config = add_bss_config_file(ctrl_config_path, state, sta_mac_p);
+	wpa_printf(MSG_INFO, "add_vap : %s", bss_config);
+	hostapd_add_iface_odin(interfaces, bss_config);
+
+	for (i = 0; i < interfaces->count; i++) {
+		if (strcmp(interfaces->iface[i]->conf->bss[0]->iface, "wlan0") == 0)
+			hapd = interfaces->iface[i]->bss[interfaces->iface[i]->num_bss - 1];
+	}
+	sta = ap_sta_add(hapd, sta_mac_p->mac_addr);
+	memset(&cap, 0, sizeof(cap));
+	current_mode = hapd->driver->get_hw_feature_data(hapd->drv_priv, &num_modes, &flags);
+	memcpy(cap.supported_mcs_set, current_mode->mcs_set, 16);
+	cap.a_mpdu_params = current_mode->a_mpdu_params;
+	sta->aid = 0;
+	sta->capability = 0x01;
+	sta->supported_rates_len = 4;
+	memcpy(&(sta->supported_rates), supp_rates, sta->supported_rates_len);
+	sta->listen_interval = 100;
+	sta->flags |= WLAN_STA_HT | WLAN_STA_AUTH | WLAN_STA_ASSOC | WLAN_STA_WMM | WLAN_STA_SHORT_PREAMBLE;//WPA_STA_AUTHORIZED | WPA_STA_WMM | WPA_STA_SHORT_PREAMBLE;
+	sta->qosinfo = 0;
+	if (hostapd_sta_add(hapd, sta->addr, sta->aid, sta->capability,
+			    sta->supported_rates, sta->supported_rates_len,
+			    sta->listen_interval,
+			    sta->flags & WLAN_STA_HT ? &cap : NULL,
+			    NULL,
+			    sta->flags, sta->qosinfo)) {
+		wpa_printf(MSG_INFO, "添加不成功");
+	}
+
+	free(bss_config);
+
+	return 0;
+}
+
+void clear_subscriptions ()
+{
+	free_vector(_subscription_list);
+}
+
+void add_subscription(long subscription_id, EtherAddress sta_addr, String *statistic, relation_t rel, double val)
+{
+	Subscription *sub = (Subscription *)malloc(sizeof(Subscription) + statistic->length*sizeof(unsigned char));
+	sub->subscription_id = subscription_id;
+	sub->sta_addr = sta_addr;
+	//memcpy(sub->sta_addr, sta_addr, sizeof(EtherAddress));
+	memcpy(&(sub->statistic), statistic, sizeof(String) + statistic->length);
+	sub->rel = rel;
+	sub->val = val;
+	c_vector_push_back(_subscription_list, sub);
+}
+
+// added by MagicCG
+static u8 * hostapd_eid_bss_load_odin(struct hostapd_data *hapd, u8 *eid, size_t len)
+{
+#ifdef CONFIG_TESTING_OPTIONS
+	if (hapd->conf->bss_load_test_set) {
+		if (2 + 5 > len)
+			return eid;
+		*eid++ = WLAN_EID_BSS_LOAD;
+		*eid++ = 5;
+		os_memcpy(eid, hapd->conf->bss_load_test, 5);
+		eid += 5;
+	}
+#endif /* CONFIG_TESTING_OPTIONS */
+	return eid;
+}
+
+
+static u8 ieee802_11_erp_info_odin(struct hostapd_data *hapd)
+{
+	u8 erp = 0;
+
+	if (hapd->iface->current_mode == NULL ||
+	    hapd->iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G)
+		return 0;
+
+	if (hapd->iface->olbc)
+		erp |= ERP_INFO_USE_PROTECTION;
+	if (hapd->iface->num_sta_non_erp > 0) {
+		erp |= ERP_INFO_NON_ERP_PRESENT |
+			ERP_INFO_USE_PROTECTION;
+	}
+	if (hapd->iface->num_sta_no_short_preamble > 0 ||
+	    hapd->iconf->preamble == LONG_PREAMBLE)
+		erp |= ERP_INFO_BARKER_PREAMBLE_MODE;
+
+	return erp;
+}
+
+
+static u8 * hostapd_eid_ds_params_odin(struct hostapd_data *hapd, u8 *eid)
+{
+	*eid++ = WLAN_EID_DS_PARAMS;
+	*eid++ = 1;
+	*eid++ = hapd->iconf->channel;
+	return eid;
+}
+
+
+static u8 * hostapd_eid_erp_info_odin(struct hostapd_data *hapd, u8 *eid)
+{
+	if (hapd->iface->current_mode == NULL ||
+	    hapd->iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G)
+		return eid;
+
+	/* Set NonERP_present and use_protection bits if there
+	 * are any associated NonERP stations. */
+	/* TODO: use_protection bit can be set to zero even if
+	 * there are NonERP stations present. This optimization
+	 * might be useful if NonERP stations are "quiet".
+	 * See 802.11g/D6 E-1 for recommended practice.
+	 * In addition, Non ERP present might be set, if AP detects Non ERP
+	 * operation on other APs. */
+
+	/* Add ERP Information element */
+	*eid++ = WLAN_EID_ERP_INFO;
+	*eid++ = 1;
+	*eid++ = ieee802_11_erp_info_odin(hapd);
+
+	return eid;
+}
+
+
+static u8 * hostapd_eid_country_add_odin(u8 *pos, u8 *end, int chan_spacing,
+				    struct hostapd_channel_data *start,
+				    struct hostapd_channel_data *prev)
+{
+	if (end - pos < 3)
+		return pos;
+
+	/* first channel number */
+	*pos++ = start->chan;
+	/* number of channels */
+	*pos++ = (prev->chan - start->chan) / chan_spacing + 1;
+	/* maximum transmit power level */
+	*pos++ = start->max_tx_power;
+
+	return pos;
+}
+
+
+static u8 * hostapd_eid_country_odin(struct hostapd_data *hapd, u8 *eid,
+				int max_len)
+{
+	u8 *pos = eid;
+	u8 *end = eid + max_len;
+	int i;
+	struct hostapd_hw_modes *mode;
+	struct hostapd_channel_data *start, *prev;
+	int chan_spacing = 1;
+
+	if (!hapd->iconf->ieee80211d || max_len < 6 ||
+	    hapd->iface->current_mode == NULL)
+		return eid;
+
+	*pos++ = WLAN_EID_COUNTRY;
+	pos++; /* length will be set later */
+	os_memcpy(pos, hapd->iconf->country, 3); /* e.g., 'US ' */
+	pos += 3;
+
+	mode = hapd->iface->current_mode;
+	if (mode->mode == HOSTAPD_MODE_IEEE80211A)
+		chan_spacing = 4;
+
+	start = prev = NULL;
+	for (i = 0; i < mode->num_channels; i++) {
+		struct hostapd_channel_data *chan = &mode->channels[i];
+		if (chan->flag & HOSTAPD_CHAN_DISABLED)
+			continue;
+		if (start && prev &&
+		    prev->chan + chan_spacing == chan->chan &&
+		    start->max_tx_power == chan->max_tx_power) {
+			prev = chan;
+			continue; /* can use same entry */
+		}
+
+		if (start) {
+			pos = hostapd_eid_country_add_odin(pos, end, chan_spacing,
+						      start, prev);
+			start = NULL;
+		}
+
+		/* Start new group */
+		start = prev = chan;
+	}
+
+	if (start) {
+		pos = hostapd_eid_country_add_odin(pos, end, chan_spacing,
+					      start, prev);
+	}
+
+	if ((pos - eid) & 1) {
+		if (end - pos < 1)
+			return eid;
+		*pos++ = 0; /* pad for 16-bit alignment */
+	}
+
+	eid[1] = (pos - eid) - 2;
+
+	return pos;
+}
+
+
+static u8 * hostapd_eid_wpa_odin(struct hostapd_data *hapd, u8 *eid, size_t len)
+{
+	const u8 *ie;
+	size_t ielen;
+
+	ie = (const u8 *)wpa_auth_get_wpa_ie(hapd->wpa_auth, &ielen);
+	if (ie == NULL || ielen > len)
+		return eid;
+
+	os_memcpy(eid, ie, ielen);
+	return eid + ielen;
+}
+
+
+static u8 * hostapd_eid_csa_odin(struct hostapd_data *hapd, u8 *eid)
+{
+	u8 chan;
+
+	if (!hapd->iface->cs_freq)
+		return eid;
+
+	if (ieee80211_freq_to_chan(hapd->iface->cs_freq, &chan) ==
+	    NUM_HOSTAPD_MODES)
+		return eid;
+
+	*eid++ = WLAN_EID_CHANNEL_SWITCH;
+	*eid++ = 3;
+	*eid++ = hapd->iface->cs_block_tx;
+	*eid++ = chan;
+	*eid++ = hapd->iface->cs_count;
+
+	return eid;
+}
+
+static u8 * hostapd_gen_probe_resp_odin(struct hostapd_data *hapd,
+				   struct sta_info *sta,
+				   EtherAddress dst,
+				   EtherAddress bssid,
+				   String *my_ssid,
+				   int is_p2p, size_t *resp_len)
+{
+	struct ieee80211_mgmt *resp;
+	u8 *pos, *epos, *old_pos;
+	size_t buflen;
+//	u8 apple[6] = {0x30, 0x10, 0xe4, 0xec, 0x54, 0xf6};
+//	u8 bssid_apple[6] = {0x00, 0x1b, 0xb3, 0xec, 0x54, 0xf6};
+
+#define MAX_PROBERESP_LEN 768
+	buflen = MAX_PROBERESP_LEN;
+#ifdef CONFIG_WPS
+	if (hapd->wps_probe_resp_ie)
+		buflen += wpabuf_len(hapd->wps_probe_resp_ie);
+#endif /* CONFIG_WPS */
+#ifdef CONFIG_P2P
+	if (hapd->p2p_probe_resp_ie)
+		buflen += wpabuf_len(hapd->p2p_probe_resp_ie);
+#endif /* CONFIG_P2P */
+	if (hapd->conf->vendor_elements)
+		buflen += wpabuf_len(hapd->conf->vendor_elements);
+	resp = os_zalloc(buflen);
+	if (resp == NULL)
+		return NULL;
+
+	epos = ((u8 *) resp) + MAX_PROBERESP_LEN;
+
+	resp->frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
+					   WLAN_FC_STYPE_PROBE_RESP);
+	os_memcpy(resp->da, dst.mac_addr, ETH_ALEN);//dst->mac_addr, ETH_ALEN);
+	os_memcpy(resp->sa, hapd->own_addr, ETH_ALEN);
+
+	os_memcpy(resp->bssid, bssid.mac_addr, ETH_ALEN);//bssid->mac_addr, ETH_ALEN);
+	resp->u.probe_resp.beacon_int =
+		host_to_le16(hapd->iconf->beacon_int);
+
+	/* hardware or low-level driver will setup seq_ctrl and timestamp */
+	resp->u.probe_resp.capab_info =
+		host_to_le16(hostapd_own_capab_info(hapd, sta, 1));
+
+	pos = resp->u.probe_resp.variable;
+	*pos++ = WLAN_EID_SSID;
+	*pos++ = my_ssid->length;
+	os_memcpy(pos, my_ssid->str, my_ssid->length);
+	pos += my_ssid->length;
+
+	//wpa_printf(MSG_INFO, MACSTR, MAC2STR(dst.mac_addr));
+	//wpa_printf(MSG_INFO, MACSTR, MAC2STR(bssid.mac_addr));
+
+	/* Supported rates */
+	pos = hostapd_eid_supp_rates(hapd, pos);
+
+	/* DS Params */
+	pos = hostapd_eid_ds_params_odin(hapd, pos);
+
+	pos = hostapd_eid_country_odin(hapd, pos, epos - pos);
+
+	/* ERP Information element */
+	pos = hostapd_eid_erp_info_odin(hapd, pos);
+
+	/* Extended supported rates */
+	pos = hostapd_eid_ext_supp_rates(hapd, pos);
+
+	/* RSN, MDIE, WPA */
+	pos = hostapd_eid_wpa_odin(hapd, pos, epos - pos);
+
+	pos = hostapd_eid_bss_load_odin(hapd, pos, epos - pos);
+
+#ifdef CONFIG_IEEE80211N
+	pos = hostapd_eid_ht_capabilities(hapd, pos);
+	pos = hostapd_eid_ht_operation(hapd, pos);
+#endif /* CONFIG_IEEE80211N */
+
+	pos = hostapd_eid_ext_capab(hapd, pos);
+
+	pos = hostapd_eid_time_adv(hapd, pos);
+	pos = hostapd_eid_time_zone(hapd, pos);
+
+	pos = hostapd_eid_interworking(hapd, pos);
+	pos = hostapd_eid_adv_proto(hapd, pos);
+	pos = hostapd_eid_roaming_consortium(hapd, pos);
+
+	old_pos = pos;
+	pos = hostapd_eid_csa_odin(hapd, pos);
+
+	/* save an offset to the counter - should be last byte */
+	hapd->iface->cs_c_off_proberesp = (pos != old_pos) ?
+		pos - (u8 *) resp - 1 : 0;
+
+#ifdef CONFIG_IEEE80211AC
+	pos = hostapd_eid_vht_capabilities(hapd, pos);
+	pos = hostapd_eid_vht_operation(hapd, pos);
+#endif /* CONFIG_IEEE80211AC */
+
+	/* Wi-Fi Alliance WMM */
+	pos = (u8 *)hostapd_eid_wmm(hapd, pos);
+
+#ifdef CONFIG_WPS
+	if (hapd->conf->wps_state && hapd->wps_probe_resp_ie) {
+		os_memcpy(pos, wpabuf_head(hapd->wps_probe_resp_ie),
+			  wpabuf_len(hapd->wps_probe_resp_ie));
+		pos += wpabuf_len(hapd->wps_probe_resp_ie);
+	}
+#endif /* CONFIG_WPS */
+
+#ifdef CONFIG_P2P
+	if ((hapd->conf->p2p & P2P_ENABLED) && is_p2p &&
+	    hapd->p2p_probe_resp_ie) {
+		os_memcpy(pos, wpabuf_head(hapd->p2p_probe_resp_ie),
+			  wpabuf_len(hapd->p2p_probe_resp_ie));
+		pos += wpabuf_len(hapd->p2p_probe_resp_ie);
+	}
+#endif /* CONFIG_P2P */
+#ifdef CONFIG_P2P_MANAGER
+	if ((hapd->conf->p2p & (P2P_MANAGE | P2P_ENABLED | P2P_GROUP_OWNER)) ==
+	    P2P_MANAGE)
+		pos = hostapd_eid_p2p_manage(hapd, pos);
+#endif /* CONFIG_P2P_MANAGER */
+
+#ifdef CONFIG_HS20
+	pos = hostapd_eid_hs20_indication(hapd, pos);
+#endif /* CONFIG_HS20 */
+
+	if (hapd->conf->vendor_elements) {
+		os_memcpy(pos, wpabuf_head(hapd->conf->vendor_elements),
+			  wpabuf_len(hapd->conf->vendor_elements));
+		pos += wpabuf_len(hapd->conf->vendor_elements);
+	}
+
+	*resp_len = pos - (u8 *) resp;
+	return (u8 *) resp;
+}
+
+static void send_probe_resp(EtherAddress dst, EtherAddress bssid, String *my_ssid)
+{
+	u8 *resp;
+	size_t resp_len;
+	struct hostapd_data *hapd = interfaces->iface[0]->bss[0];
+
+	resp = hostapd_gen_probe_resp_odin(hapd, NULL,
+									dst, bssid, my_ssid, 0, &resp_len);
+	if (resp == NULL)
+			return;
+
+//	if ((hapd->driver->send_mntr(hapd->drv_priv, resp, resp_len)) < 0)
+//		wpa_printf(MSG_INFO, "handle_probe_resp: send failed");
+	if (hostapd_drv_send_mlme(hapd, resp, resp_len, 0) < 0)
+		wpa_printf(MSG_INFO, "handle_probe_resp: send failed");
+	os_free(resp);
+}
+
+void parse_odin_protocol(char *buf, int reply_sock)
+{
+	char msg[1024] = "DATA 0\n";
+	char tmp[20];
+	char *value, *tp;
+	char **recv_msg;
+	EtherAddress *iter_key;
+	OdinStationState *iter_value;
+	protocol_type type;
+	c_iterator iter_sta = c_map_begin(_sta_mapping_table);
+	c_iterator end_sta = c_map_end(_sta_mapping_table);
+
+	//for the handler_subscriptions write handler
+	int num_rows, i;
+	long sub_id;
+	EtherAddress sta_addr;
+	String *statistic;
+	relation_t relation;
+	double sub_value;
+
+	//for the handler_add_vap write handler
+	IPAddress sta_ip;
+	EtherAddress sta_mac;
+	EtherAddress vap_bssid;
+	String *vap_ssid = NULL;
+	int num_ssid = 1;
+
+	// for the handler_probe_response write handler:
+	EtherAddress dst_mac;
+	EtherAddress dst_bssid;
+	String *ssid_no_endchar;
+
+	value = buf;
+	//wpa_printf(MSG_INFO, "Incoming......");
+	if (strcasecmp(strsep(&value, " "), "READ") == 0) {
+		tp = strsep(&value, "\n");
+		value = tp;
+		strsep(&value, ".");
+		//wpa_printf(MSG_INFO, "Incoming......");
+		type = protocol_string_to_enum(value);
+		//wpa_printf(MSG_INFO, "Incoming......");
+		switch (type) {
+		case handler_view_mapping_table:
+
+			for (; !ITER_EQUAL(iter_sta, end_sta); ITER_INC(iter_sta))
+			{
+				iter_key = (EtherAddress *)(((c_ppair)ITER_REF(iter_sta))->first);
+				iter_value = (OdinStationState *)(((c_ppair)ITER_REF(iter_sta))->second);
+
+				sprintf(tmp, MACSTR, MAC2STR(iter_key->mac_addr));
+				strcat(msg, tmp);
+
+				strcat(msg, " ");
+
+				sprintf(tmp, IPSTR,
+						IP2STR(iter_value->_sta_ip_addr_v4.ip));
+				strcat(msg, tmp);
+
+				strcat(msg, " ");
+
+				sprintf(tmp, MACSTR, MAC2STR(iter_value->_vap_bssid.mac_addr));
+				strcat(msg, tmp);
+
+				strcat(msg, " ");
+				sprintf(tmp, "%s", iter_value->_vap_ssids.str);
+				strcat(msg, tmp);
+
+
+				strcat(msg, "\n");
+		    }
+		    break;
+		case handler_channel:
+		case handler_interval:
+		case handler_rxstat:
+		case handler_subscriptions:
+		case handler_debug:
+		case handler_report_mean:
+		case handler_spectral_scan:
+			break;
+		}
+		if (send(reply_sock, msg, strlen(msg), 0) == -1) {
+			wpa_printf(MSG_INFO, "Send the message error");
+		}
+		else {
+			wpa_printf(MSG_INFO, "Send the message:%s", msg);
+		}
+	} else {
+		tp = strsep(&value, "\n");
+		value = tp;
+		tp = strsep(&value, " ");
+		strsep(&tp, ".");
+		type = protocol_string_to_enum(tp);
+
+		switch (type) {
+	    case handler_add_vap:
+    		tp = strsep(&value, " ");
+    		COPY_STR2MAC(tp, sta_mac.mac_addr);
+    		//sscanf(tp, MACSTR, sta_mac.mac_addr, sta_mac.mac_addr+1, sta_mac.mac_addr+2,
+    		//		sta_mac.mac_addr+3, sta_mac.mac_addr+4, sta_mac.mac_addr+5);
+    		tp = strsep(&value, " ");
+    		COPY_STR2IP(tp, sta_ip.ip);
+    		//sscanf(tp, IPSTR, sta_ip.ip, sta_ip.ip+1, sta_ip.ip+2, sta_ip.ip+3);
+    		tp = strsep(&value, " ");
+    		COPY_STR2MAC(tp, vap_bssid.mac_addr);
+    		//sscanf(tp, MACSTR, vap_bssid.mac_addr, vap_bssid.mac_addr+1, vap_bssid.mac_addr+2,
+    		//		vap_bssid.mac_addr+3, vap_bssid.mac_addr+4, vap_bssid.mac_addr+5);
+
+    		tp = value;
+    		while (strsep(&value, " "))
+    		        num_ssid++;
+    		for (; num_ssid > 1; num_ssid--) {
+    			if (vap_ssid != NULL) {
+    				free(vap_ssid);
+    				vap_ssid = NULL;
+    			}
+    			vap_ssid = (String *)malloc(sizeof(String) + (strlen(tp) + 1)*sizeof(unsigned char) );
+    			vap_ssid->length = (strlen(tp) + 1);
+    			memcpy(vap_ssid->str, tp, vap_ssid->length);
+    			tp += (strlen(tp) + 1);
+    		}
+
+    		add_vap (sta_mac, sta_ip, vap_bssid, vap_ssid);
+    		if (vap_ssid != NULL) {
+    			free(vap_ssid);
+    		}
+	        break;
+	    case handler_set_vap:
+	    	break;
+	    case handler_remove_vap:
+	    	tp = strsep(&value, " ");
+	    	COPY_STR2MAC(tp, sta_mac.mac_addr);
+	    	remove_vap(&sta_mac);
+	    	break;
+	    case handler_channel:
+	    case handler_interval:
+	    	break;
+	    case handler_subscriptions:
+
+	    	clear_subscriptions();
+
+	    	tp = strsep(&value, " ");
+	    	num_rows = atoi(tp);
+	    	for (i = 0; i < num_rows; i++) {
+	    		tp = strsep(&value, " ");
+	    		sub_id = atol(tp);
+	    		tp = strsep(&value, " ");
+	    		COPY_STR2MAC(tp, sta_mac.mac_addr);
+	    		//sscanf(tp, MACSTR, sta_addr.mac_addr, sta_addr.mac_addr+1, sta_addr.mac_addr+2,
+	    		//		sta_addr.mac_addr+3, sta_addr.mac_addr+4, sta_addr.mac_addr+5);
+	    		tp = strsep(&value, " ");
+	    		statistic = malloc(sizeof(String) + (strlen(tp) + 1)*sizeof(unsigned char) );
+	    		statistic->length = (strlen(tp) + 1);
+	    		memcpy(statistic->str, tp, statistic->length);
+	    		tp = strsep(&value, " ");
+	    		relation = (protocol_type)atoi(tp);
+	    		tp = strsep(&value, " ");
+	    		sub_value = atof(tp);
+
+	    		add_subscription (sub_id, sta_addr, statistic, relation, sub_value);
+	    		free(statistic);
+	    		statistic = NULL;
+	    	}
+	    	break;
+	    case handler_debug:
+	    case handler_probe_response:
+
+    		tp = strsep(&value, " ");
+    		COPY_STR2MAC(tp, dst_mac.mac_addr);
+    		//sscanf(tp, MACSTR, &(dst_mac.mac_addr[0]), &(dst_mac.mac_addr[1]), &(dst_mac.mac_addr[2]),
+    		//		&(dst_mac.mac_addr[3]), &(dst_mac.mac_addr[4]), &(dst_mac.mac_addr[5]));
+    		//wpa_printf(MSG_INFO, "%s", tp);
+    		//wpa_printf(MSG_INFO, MACSTR, MAC2STR(dst_mac.mac_addr));
+    		//printf("%02x:%02x:%02x:%02x:%02x:%02x", dst_mac.mac_addr[0], dst_mac.mac_addr[1], dst_mac.mac_addr[2],
+			//		dst_mac.mac_addr[3], dst_mac.mac_addr[4], dst_mac.mac_addr[5]);
+
+    		tp = strsep(&value, " ");
+    		//wpa_printf(MSG_INFO, "%s", tp);
+    		COPY_STR2MAC(tp, dst_bssid.mac_addr);
+			//sscanf(tp, MACSTR, dst_bssid.mac_addr, dst_bssid.mac_addr+1, dst_bssid.mac_addr+2,
+    		//		dst_bssid.mac_addr+3, dst_bssid.mac_addr+4, dst_bssid.mac_addr+5);
+    		//wpa_printf(MSG_INFO, MACSTR, MAC2STR(dst_bssid.mac_addr));
+    		// FIXME:此处需要添加对多ssid的支持
+    		tp = value;
+    		while (strsep(&value, " "))
+    			num_ssid++;
+    		for (; num_ssid > 1; num_ssid--) {
+    			ssid_no_endchar = (String *)malloc(sizeof(String) + strlen(tp)*sizeof(unsigned char) );
+    			ssid_no_endchar->length = strlen(tp);
+    		    memcpy(ssid_no_endchar->str, tp, ssid_no_endchar->length);
+    		    send_probe_resp(dst_mac, dst_bssid, ssid_no_endchar);
+    		    free(ssid_no_endchar);
+    		    tp += (strlen(tp) + 1);
+    		}
+	    	break;
+	    case handler_probe_request:
+	    case handler_update_signal_strength:
+	    case handler_signal_strength_offset:
+	    case handler_spectral_scan:
+	    	break;
+		}
+	}
+}
+
+void odin_protocol_handler(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	int count;
+	char buf[BUFFER_SIZE];
+	c_iterator iter;
+	c_iterator first, last;
+
+	if ((count = recv(sock, buf, BUFFER_SIZE, 0)) > 0) {
+		wpa_printf(MSG_INFO, "Receive the message from client:%s", buf);
+		//printf("Received a message from %d: %s\n", fd, buf);
+		parse_odin_protocol(buf, sock);
+	}
+	else
+	{
+		close(sock);
+		eloop_unregister_read_sock(sock);
+
+		first = c_vector_begin(client_sock_vector);
+		last = c_vector_end(client_sock_vector);
+
+		for(iter = first;
+			 !ITER_EQUAL(iter, last); ITER_INC(iter))
+		{
+			if((*((int *)(ITER_REF(iter)))) == sock) {
+				c_vector_erase(client_sock_vector, iter);
+			}
+		}
+		wpa_printf(MSG_INFO, "Client has left");
+	    //printf("Client %d(socket) has left\n", fd);
+	}
+}
+
+void handle_tcp_client_connection(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	int client_sockfd, *client;
+	struct sockaddr_in client_sockaddr;
+	int sin_size;
+
+	if ((client_sockfd = accept(sock, (struct sockaddr *)&client_sockaddr,
+		 	 	 	 	 	 &sin_size))== -1) {
+		wpa_printf(MSG_INFO, "Could not accept the tcp connection from client");
+		return;
+	}
+	if (eloop_register_read_sock(client_sockfd, odin_protocol_handler,
+						     NULL, NULL)) {
+		wpa_printf(MSG_INFO, "Could not register odin protocol eloop read socket");
+		return;
+	}
+
+	wpa_printf(MSG_INFO, "New connection from client");
+	client = (int *)malloc(sizeof(int));
+	*client = client_sockfd;
+	c_vector_push_back(client_sock_vector, client);
+}
+
+void odin_protocol_eloop_init(int socket_port_recv)
+{
+	struct sockaddr_in server_sockaddr;
+	int i = 1;/* 使得重复使用本地地址与套接字进行绑定 */
+
+	if ((server_sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
+		wpa_printf(MSG_ERROR, "Create odin protocol server socket error!");
+	    return;
+	}
+
+	server_sockaddr.sin_family = AF_INET;
+	server_sockaddr.sin_port = htons(socket_port_recv);
+	server_sockaddr.sin_addr.s_addr = INADDR_ANY;
+
+	setsockopt(server_sockfd, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));
+	if (bind(server_sockfd, (struct sockaddr *)&server_sockaddr,
+						sizeof(struct sockaddr)) == -1) {
+		wpa_printf(MSG_ERROR, "Bind odin protocol server socket error!");
+		close(server_sockfd);
+	    return;
+	}
+	if(listen(server_sockfd, MAX_QUE_CONN_NM) == -1) {
+		wpa_printf(MSG_ERROR, "Listen odin protocol server socket error!");
+		close(server_sockfd);
+	    return;
+	}
+
+	wpa_printf(MSG_INFO, "Listening......");
+
+	if (eloop_register_read_sock(server_sockfd, handle_tcp_client_connection,
+					     NULL, NULL)) {
+		wpa_printf(MSG_INFO, "Could not register odin protocol eloop read socket");
+		return;
+	}
+}
+
+void odin_protocol_eloop_deinit()
+{
+	close(server_sockfd);
+	eloop_unregister_read_sock(server_sockfd);
+}
+
+void params_init()
+{
+	map_init(&_sta_mapping_table, etheraddress_comparer);
+	map_init(&_rx_stats, etheraddress_comparer);
+	map_init(&_mean_table, etheraddress_comparer);
+	vector_init(&_subscription_list, subscription_comparer);
+}
+
+void params_deinit()
+{
+	vector_deinit(&_subscription_list);
+	map_deinit(&_mean_table);
+	map_deinit(&_rx_stats);
+	map_deinit(&_sta_mapping_table);
+}
+
+//merge into the params_init
+void client_sock_init()
+{
+	client_sock_vector = (c_pvector)malloc(sizeof(c_vector));
+	if(client_sock_vector == NULL) {
+		wpa_printf(MSG_INFO, "malloc vector error......");
+	}
+	__c_vector(client_sock_vector, int_comparer);
+}
+
+void client_sock_deinit()
+{
+	c_iterator iter;
+	c_iterator first, last;
+
+	first = c_vector_begin(client_sock_vector);
+	last = c_vector_end(client_sock_vector);
+
+	for(iter = first;
+	     !ITER_EQUAL(iter, last); ITER_INC(iter))
+	{
+	    if(ITER_REF(iter)) {
+	    	close(*((int *)(ITER_REF(iter))));
+	    	eloop_unregister_read_sock(*((int *)(ITER_REF(iter))));
+	    }
+	}
+
+	vector_deinit(&client_sock_vector);
+}
+
+void odin_protocol_init_monitor_interface()
+{
+	int i;
+	for (i = 0; i < interfaces->count; i++) {
+		/* FIXME:从这个接口传下去一个handler的函数指针 */
+		interfaces->iface[i]->bss[0]->driver->create_odin_monitor_interface(interfaces->iface[i]->bss[0]->drv_priv);
+	}
+}
+
+void odin_protocol_deinit_monitor_interface()
+{
+	int i;
+	for (i = 0; i < interfaces->count; i++) {
+		interfaces->iface[i]->bss[0]->driver->remove_odin_monitor_interface(interfaces->iface[i]->bss[0]->drv_priv);
+	}
+}
+
+void remove_odin_lvaps_all()
+{
+	//hostapd_remove_iface(interfaces, "wlan0");
+	/*
+	c_iterator vector_iter, vector_last;
+	String *sta_ssid, *ssid;
+	OdinStationState *state;
+	c_pvector ssids;
+	c_iterator iter = c_map_begin(_sta_mapping_table);
+	c_iterator end = c_map_end(_sta_mapping_table);
+
+	vector_init(&ssids, string_comparer);
+
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		state = (OdinStationState *)(((c_ppair)ITER_REF(iter))->second);
+		sta_ssid = &(state->_vap_ssids);
+
+		ssid = malloc(sizeof(String)+(sta_ssid->length)*sizeof(unsigned char));
+		memcpy(ssid, sta_ssid,
+				sizeof(String)+(sta_ssid->length)*sizeof(unsigned char));
+		c_vector_push_back(ssids, ssid);
+		//for remove the bss
+		//hostapd_remove_iface(interfaces, sta_ssid->str);
+		wpa_printf(MSG_INFO, "delete %s",sta_ssid->str);
+		free(((c_ppair)ITER_REF(iter))->first);
+		free(((c_ppair)ITER_REF(iter))->second);
+		((c_ppair)ITER_REF(iter))->first = NULL;
+		((c_ppair)ITER_REF(iter))->second = NULL;
+		free(ITER_REF(iter));
+		c_map_erase(_sta_mapping_table, iter);
+	}
+
+	vector_iter = c_vector_begin(ssids);
+	vector_last = c_vector_end(ssids);
+	for(; !ITER_EQUAL(vector_iter, vector_last); ITER_INC(vector_iter))
+	{
+	    if(ITER_REF(vector_iter)) {
+	        hostapd_remove_iface(interfaces,
+	        		((String *)(ITER_REF(vector_iter)))->str);
+	        wpa_printf(MSG_INFO, "delete %s",
+	        		((String *)(ITER_REF(vector_iter)))->str);
+	    }
+	}
+	vector_deinit(&ssids);*/
+	int i, j;
+	struct hostapd_iface *hapd_iface;
+	for (i = 0; i < interfaces->count; i++) {
+		hapd_iface = interfaces->iface[i];
+		if (hapd_iface == NULL)
+			return;
+
+		while ((hapd_iface->conf->num_bss) > 1) {
+			wpa_printf(MSG_INFO, "delete %s", hapd_iface->conf->bss[1]->iface);
+			hostapd_remove_iface_odin(interfaces, hapd_iface->conf->bss[1]->iface);
+		}
+	}
+}
+
+void odin_protocol_init(struct hapd_interfaces *ifaces)
+{
+	//odin_ping protocol
+	//start a new thread
+	interfaces = ifaces;
+	odin_protocol_eloop_init(TCP_LISTEN_PORT);
+	udp_sockfd_init();
+	params_init();
+	ping_thread_init();
+	client_sock_init();
+	odin_protocol_init_monitor_interface();
+}
+
+void odin_protocol_deinit()
+{
+	remove_odin_lvaps_all();
+	odin_protocol_deinit_monitor_interface();
+	client_sock_deinit();
+	finish_thread();
+	params_deinit();
+	udp_sockfd_deinit();
+	odin_protocol_eloop_deinit();
+}
+
+int odin_send_msg(protocol_type type)
+{
+	return 0;
+}
+
+void match_against_subscriptions(StationStats *stats, EtherAddress *src)
+{
+	int count = 0;
+	char publish_msg[1024] = "";
+	char subscription_matches[512] = "";
+	char tmp_match[100] = "";
+	c_iterator iter, last;
+	Subscription *sub;
+	EtherAddress zero;
+
+	memset(&zero, 0, sizeof(EtherAddress));
+	if (c_vector_size(_subscription_list) == 0)
+		return;
+
+	iter = c_vector_begin(_subscription_list);
+	last = c_vector_end(_subscription_list);
+	for (; !ITER_EQUAL(iter, last); ITER_INC(iter)) {
+
+		sub = ITER_REF(iter);
+
+		if (memcmp( &(sub->sta_addr), &zero, sizeof(EtherAddress) ) != 0
+			&& memcmp( &(sub->sta_addr), src, sizeof(EtherAddress) ) != 0 )
+			continue;
+
+		/* TODO: Refactor to use a series of hash maps instead */
+		switch (sub->rel) {
+		case EQUALS: {
+			if (sub->statistic.length == (strlen("signal") + 1)
+				&& strcmp(sub->statistic.str, "signal") == 0
+				&& stats->_signal == sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_signal);
+				count++;
+			} else if (sub->statistic.length == (strlen("rate") + 1)
+				&& strcmp(sub->statistic.str, "rate") == 0
+				&& stats->_rate == sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_rate);
+				count++;
+			} else if (sub->statistic.length == (strlen("noise") + 1)
+				&& strcmp(sub->statistic.str, "noise") == 0
+				&& stats->_noise == sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_noise);
+				count++;
+			} else if (sub->statistic.length == (strlen("_packets") + 1)
+				&& strcmp(sub->statistic.str, "_packets") == 0
+				&& stats->_packets == sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_packets);
+				count++;
+			}
+			break;
+		}
+		case GREATER_THAN: {
+			if (sub->statistic.length == (strlen("signal") + 1)
+				&& strcmp(sub->statistic.str, "signal") == 0
+				&& stats->_signal > sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_signal);
+				count++;
+			} else if (sub->statistic.length == (strlen("rate") + 1)
+				&& strcmp(sub->statistic.str, "rate") == 0
+				&& stats->_rate > sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_rate);
+				count++;
+			} else if (sub->statistic.length == (strlen("noise") + 1)
+				&& strcmp(sub->statistic.str, "noise") == 0
+				&& stats->_noise > sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_noise);
+				count++;
+			} else if (sub->statistic.length == (strlen("_packets") + 1)
+				&& strcmp(sub->statistic.str, "_packets") == 0
+				&& stats->_packets > sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_packets);
+				count++;
+			}
+			break;
+		}
+		case LESSER_THAN: {
+			if (sub->statistic.length == (strlen("signal") + 1)
+				&& strcmp(sub->statistic.str, "signal") == 0
+				&& stats->_signal < sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_signal);
+				count++;
+			} else if (sub->statistic.length == (strlen("rate") + 1)
+				&& strcmp(sub->statistic.str, "rate") == 0
+				&& stats->_rate < sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_rate);
+				count++;
+			} else if (sub->statistic.length == (strlen("noise") + 1)
+				&& strcmp(sub->statistic.str, "noise") == 0
+				&& stats->_noise < sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_noise);
+				count++;
+			} else if (sub->statistic.length == (strlen("_packets") + 1)
+				&& strcmp(sub->statistic.str, "_packets") == 0
+				&& stats->_packets < sub->val) {
+				sprintf(tmp_match, " %d:%d", sub->subscription_id, stats->_packets);
+				count++;
+			}
+			break;
+		}
+		}
+		strcat(subscription_matches, tmp_match);
+	}
+
+	sprintf(publish_msg, "publish %02x:%02x:%02x:%02x:%02x:%02x %d%s\n",
+			MAC2STR(src->mac_addr), count, subscription_matches);
+	udp_send_msg(CONTROLLER, UDP_DEST_PORT, publish_msg);
+//	wpa_printf(MSG_INFO, "match sub: 上传订阅: %s", publish_msg);
+}
+
+void update_rx_stats(struct ieee80211_hdr *hdr, int datarate,
+		int rssi_signal, int noise)
+{
+	EtherAddress src;
+	EtherAddress *src_p;
+	memcpy(&src, hdr->addr2, ETH_ALEN);
+	c_pair *p;
+	c_iterator end, target;
+	StationStats *stat;
+
+	end = c_map_end(_rx_stats);
+	target = c_map_find(_rx_stats, &src);
+
+	if (ITER_EQUAL(end, target)) {
+		src_p = malloc(sizeof(EtherAddress));
+		stat = malloc(sizeof(StationStats));
+
+		memset(stat, 0, sizeof(stat));
+		memcpy(src_p, &src, sizeof(EtherAddress));
+
+		p = (c_pair *)malloc(sizeof(c_pair));
+		*p = c_make_pair(src_p, stat);
+		c_map_insert(_rx_stats, p);
+	}
+	else {
+		stat = (StationStats *)( ((c_ppair)ITER_REF(target))->second );
+	}
+
+	stat->_rate = datarate;
+	stat->_noise = noise;
+	stat->_signal = rssi_signal + SIGNAL_OFFSET;
+	stat->_packets++;
+	stat->_last_received = time(NULL);
+
+	match_against_subscriptions(stat, &src);
+
+}
+
+const OdinStationState * get_state_by_sta_mac(EtherAddress sta_mac)
+{
+	OdinStationState *state;
+
+	state = (OdinStationState *)c_map_at(_sta_mapping_table, &sta_mac);
+	return state;
+}
+
+void recv_auth(unsigned char *buf)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) buf;
+	u16 auth_alg, auth_transaction, status_code;
+	EtherAddress sa;
+	const OdinStationState *state;
+	int res;
+	struct sta_info *sta;
+
+	auth_alg = le_to_host16(mgmt->u.auth.auth_alg);
+	auth_transaction = le_to_host16(mgmt->u.auth.auth_transaction);
+	status_code = le_to_host16(mgmt->u.auth.status_code);
+
+	if ((auth_transaction == 1) || (auth_transaction == 3)) {
+		memcpy(&sa, mgmt->sa, ETH_ALEN);
+		state = get_state_by_sta_mac(sa);
+		if (state != NULL) {
+			wpa_printf(MSG_INFO, "station");
+			wpa_printf(MSG_INFO, MACSTR, MAC2STR(sa.mac_addr));
+			wpa_printf(MSG_INFO, "frame bssid");
+			wpa_printf(MSG_INFO, MACSTR, MAC2STR(mgmt->bssid));
+			wpa_printf(MSG_INFO, "frame da");
+			wpa_printf(MSG_INFO, MACSTR, MAC2STR(mgmt->da));
+			wpa_printf(MSG_INFO, "state bssid");
+			wpa_printf(MSG_INFO, MACSTR, MAC2STR(state->_vap_bssid.mac_addr));
+			wpa_printf(MSG_INFO, "state ip");
+			wpa_printf(MSG_INFO, IPSTR, IP2STR(state->_sta_ip_addr_v4.ip));
+			wpa_printf(MSG_INFO, "state ssid");
+			wpa_printf(MSG_INFO, "%s", state->_vap_ssids.str);
+			if (memcmp(&(state->_vap_bssid), mgmt->bssid, ETH_ALEN) != 0) {
+				//res = hostapd_drv_sta_deauth(interfaces->iface[0]->bss[0],
+				//		mgmt->da, WLAN_REASON_DEAUTH_LEAVING);
+				//if (res == 0) {
+				//	wpa_printf(MSG_INFO, "发送DEAUTH成功");
+				//}
+				//else {
+				//	wpa_printf(MSG_INFO, "发送DEAUTH失败");
+				//}
+
+				/*
+				int i, j;
+				struct hostapd_iface *hapd_iface;
+				for (i = 0; i < interfaces->count; i++) {
+					hapd_iface = interfaces->iface[i];
+					if (hapd_iface == NULL)
+						return;
+					for (j = 1; hapd_iface->num_bss; j++) {
+						if (hapd_iface->bss[j]->conf->accept_mac)
+						wpa_printf(MSG_INFO, "delete %s", hapd_iface->conf->bss[1]->iface);
+						hostapd_remove_iface_odin(interfaces, hapd_iface->conf->bss[1]->iface);
+					}
+				}
+				sta = ap_get_sta(hapd, mgmt->da);
+				if (!sta) {
+					wpa_printf(MSG_INFO, "set sta state: STA " MACSTR " not found",
+						MAC2STR(mgmt->da));
+					return;
+				}
+				sta->flags |= WLAN_STA_AUTH;
+				wpa_printf(MSG_INFO, "set sta state success");
+				*/
+			}
+		}
+	}
+}
+
+void recv_probe_request(unsigned char *buf)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) buf;
+	u8 *ptr = mgmt->u.probe_req.variable;
+	u8 ssid_empty = 0;
+	char tmp[SSID_MAX_LEN];
+	EtherAddress src;
+	String *ssid = NULL;
+	c_iterator map_end, target;
+//wpa_printf(MSG_INFO, "recvprobe: come into the recv_probe_request");
+	if (*ptr == WLAN_EID_SSID) {
+		if(ptr[1] == 0) {
+			ssid_empty = 1;
+		}
+		else {
+			ssid = malloc(sizeof(String) + (ptr[1] + 1)*sizeof(unsigned char));
+			ssid->length = (ptr[1] + 1);
+			if (ssid->length > SSID_MAX_LEN) {
+				free(ssid);
+				return;
+			}
+			memcpy(ssid->str, ptr+2, ptr[1]*sizeof(unsigned char));
+			ssid->str[(ssid->length)-1] = '\0';
+		}
+	}
+
+	memcpy(&src, mgmt->sa, ETH_ALEN);
+
+	map_end = c_map_end(_sta_mapping_table);
+	target = c_map_find(_sta_mapping_table, &src);
+
+	if (!ITER_EQUAL(map_end, target)) {
+		return;
+	}
+	if (ssid_empty) {
+		sprintf(tmp, "probe %02x:%02x:%02x:%02x:%02x:%02x \n", MAC2STR(src.mac_addr));
+		//wpa_printf(MSG_INFO, "recvprobe : 接收到空ssid的%s", tmp);
+		udp_send_msg(CONTROLLER, UDP_DEST_PORT, tmp);
+		return;
+	}
+
+	sprintf(tmp, "probe %02x:%02x:%02x:%02x:%02x:%02x %s\n", MAC2STR(src.mac_addr), ssid->str);
+	//wpa_printf(MSG_INFO, "recvprobe : 接收到ssid:%s的%s", ssid->str, tmp);
+	udp_send_msg(CONTROLLER, UDP_DEST_PORT, tmp);
+	if (ssid != NULL)
+		free(ssid);
+	//wpa_printf(MSG_INFO, "recvprobe : free ssid success");
+}
+
+void odin_handle_monitor_read(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	int len;
+	unsigned char buf[3000];
+	struct ieee80211_radiotap_iterator iter;
+	int ret;
+	int datarate = 0, ssi_signal = 0, noise = 0;
+	int injected = 0, failed = 0, rxflags = 0;
+
+	struct ieee80211_hdr *hdr;
+	u16 fc, stype;
+	unsigned char *buf_p;
+	int len_buf_p;
+
+	len = recv(sock, buf, sizeof(buf), 0);
+	if (len < 0) {
+		wpa_printf(MSG_ERROR, "nl80211: Monitor socket recv failed: %s",
+			   strerror(errno));
+		return;
+	}
+
+	if (ieee80211_radiotap_iterator_init(&iter, (void*)buf, len)) {
+		wpa_printf(MSG_INFO, "nl80211: received invalid radiotap frame");
+		return;
+	}
+
+	while (1) {
+		ret = ieee80211_radiotap_iterator_next(&iter);
+		if (ret == -ENOENT)
+			break;
+		if (ret) {
+			wpa_printf(MSG_INFO, "nl80211: received invalid radiotap frame (%d)",
+				   ret);
+			return;
+		}
+		switch (iter.this_arg_index) {
+		case IEEE80211_RADIOTAP_FLAGS:
+			if (*iter.this_arg & IEEE80211_RADIOTAP_F_FCS)
+				len -= 4;
+			break;
+		case IEEE80211_RADIOTAP_RX_FLAGS:
+			rxflags = 1;
+			break;
+		case IEEE80211_RADIOTAP_TX_FLAGS:
+			injected = 1;
+			failed = le_to_host16((*(uint16_t *) iter.this_arg)) &
+					IEEE80211_RADIOTAP_F_TX_FAIL;
+			break;
+		case IEEE80211_RADIOTAP_DATA_RETRIES:
+			break;
+		case IEEE80211_RADIOTAP_CHANNEL:
+			/* TODO: convert from freq/flags to channel number */
+			break;
+		case IEEE80211_RADIOTAP_RATE:
+			datarate = *iter.this_arg * 0.5;
+			break;
+		case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:
+			ssi_signal = (s8) *iter.this_arg;
+			break;
+		case IEEE80211_RADIOTAP_DBM_ANTNOISE:
+			noise = (s8) *iter.this_arg;
+		}
+	}
+
+	buf_p = buf + iter.max_length;
+	len_buf_p = len - iter.max_length;
+	hdr = (struct ieee80211_hdr *) buf_p;
+	fc = le_to_host16(hdr->frame_control);
+	stype = WLAN_FC_GET_STYPE(fc);
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case WLAN_FC_TYPE_MGMT:
+		if (stype == WLAN_FC_STYPE_PROBE_REQ) {
+			//wpa_printf(MSG_INFO, "recvprobe : recv the mgmt, type : %d, stype : %d", WLAN_FC_GET_TYPE(fc), stype);
+			recv_probe_request(buf_p);
+			return;
+		}
+		if (stype == WLAN_FC_STYPE_AUTH) {
+			recv_auth(buf_p);
+			return;
+		}
+		break;
+	case WLAN_FC_TYPE_CTRL:
+		break;
+	case WLAN_FC_TYPE_DATA:
+		if ((datarate != 0) &&(ssi_signal != 0)) {
+			update_rx_stats(hdr, datarate, ssi_signal, noise);
+		//	wpa_printf(MSG_INFO, "odin nl80211: rate is %d Mbps, rssi is %d dbm.", datarate, ssi_signal);
+		}
+		break;
+	}
+
+}
diff --git a/src/odin/odinagent.h b/src/odin/odinagent.h
new file mode 100644
index 0000000..f195563
--- /dev/null
+++ b/src/odin/odinagent.h
@@ -0,0 +1,173 @@
+#ifndef ODINAGENT_H
+#define ODINAGENT_H
+
+#include "utils/includes.h"
+#include <pthread.h>
+#include <time.h>
+#include <strings.h>
+#ifndef CONFIG_NATIVE_WINDOWS
+#include <syslog.h>
+#include <grp.h>
+#endif /* CONFIG_NATIVE_WINDOWS */
+
+#include "utils/eloop.h"
+#include "utils/common.h"
+#include "tstl2cl/include/c_def.h"
+#include "tstl2cl/include/c_vector.h"
+#include "tstl2cl/include/c_map.h"
+#include "ap/hostapd.h"
+
+#define CONTROLLER 			"192.168.0.99"
+#define TCP_LISTEN_PORT     6777
+#define UDP_DEST_PORT       2819
+#define MAX_QUE_CONN_NM     5
+#define MAX_SOCK_FD         FD_SETSIZE
+#define BUFFER_SIZE         1024
+#define PROTOCOL_TYPE_NUM	15
+#define IP_ALEN				4
+#define STRING_MAX_LEN		50
+#define SSID_MAX_LEN		50
+#define SIGNAL_OFFSET		256
+
+#ifndef IP2STR
+#define IP2STR(a) a[0], a[1], a[2], a[3]
+#define IPSTR	"%d.%d.%d.%d"
+#endif
+
+static inline unsigned char a2x(const char c) {
+	switch (c) {
+	case '0' ... '9':
+		return (unsigned char) atoi(&c);
+	case 'a' ... 'f':
+		return 0xa + (c - 'a');
+	case 'A' ... 'F':
+		return 0xa + (c - 'A');
+	default:
+		goto error;
+	}
+	error: exit(0);
+}
+
+static inline void str2mac(const char *str, u8 *mac)
+{
+	int i;
+	for (i = 0; i < ETH_ALEN; i++) {
+	  mac[i] = (a2x(str[i*3]) << 4) + a2x(str[i*3 + 1]);
+	}
+}
+static inline void str2ip(const char *str, u8 *ip)
+{
+	int i;
+	const char *p = str;
+	for (i = 0; i < IP_ALEN; i++) {
+	  ip[i] = atoi(p);
+	  p = strchr(p, '.');
+	  p++;
+	}
+}
+/*convert a string to a macaddress data type.*/
+#define COPY_STR2MAC(str, mac)  \
+do { \
+	str2mac(str, mac);\
+} while(0)
+/*convert a string to a ip data type.*/
+#define COPY_STR2IP(str, ip)  \
+do { \
+	str2ip(str, ip);\
+} while(0)
+
+typedef struct EtherAddress {
+	u8 mac_addr[ETH_ALEN];
+}EtherAddress;
+
+typedef struct IPAddress {
+	u8 ip[IP_ALEN];
+}IPAddress;
+
+typedef struct String {
+	int length;
+	unsigned char str[0];
+}String;
+
+typedef enum relation_t {
+    EQUALS = 0,
+    GREATER_THAN = 1,
+    LESSER_THAN = 2,
+}relation_t;
+
+typedef struct OdinStationState {
+	EtherAddress _vap_bssid;
+	IPAddress _sta_ip_addr_v4;
+	//Vector<String> _vap_ssids;
+	//c_pvector _vap_ssids;
+	String _vap_ssids;// FIXME
+}OdinStationState;
+
+typedef struct Subscription {
+    long subscription_id;
+    EtherAddress sta_addr;
+    //char statistic[STATISTIC_MAX_LEN];
+    enum relation_t rel;
+    double val;
+    String statistic;
+}Subscription;
+
+// Rx-stats about stations
+typedef struct StationStats {
+  int _rate;
+  int _noise;
+  int _signal;
+  int _packets;
+  time_t _last_received;//以秒为单位的日历时间(即从1970年1月1日0时0分0秒到现在的秒数)
+}StationStats;
+
+// All VAP related information should be accessible here on
+// a per client basis
+//HashTable<EtherAddress, OdinStationState> _sta_mapping_table;
+c_pmap _sta_mapping_table;
+c_pmap _mean_table;
+
+// Keep track of rx-statistics of stations from which
+// we hear frames. Only keeping track of data frames for
+// now.
+//HashTable<EtherAddress, StationStats> _rx_stats;
+c_pmap _rx_stats;
+
+c_pvector _subscription_list;
+
+typedef enum protocol_type {
+    handler_view_mapping_table,
+    handler_channel,
+    handler_interval,
+    handler_rxstat,
+    handler_subscriptions,
+    handler_debug,
+    handler_report_mean,
+    handler_spectral_scan,
+    handler_add_vap,
+    handler_set_vap,
+    handler_remove_vap,
+    handler_probe_response,
+    handler_probe_request,
+    handler_update_signal_strength,
+    handler_signal_strength_offset,
+}protocol_type;
+
+extern char *protocol_string[15];
+
+//global thread id
+pthread_t odin_thread_id;
+int server_sockfd, odin_udp_sockfd;
+c_pvector client_sock_vector;
+
+// global hapd_interfaces
+struct hapd_interfaces *interfaces;
+
+/* odinagent.c */
+void odin_protocol_init();
+void odin_protocol_deinit();
+int odin_send_msg(protocol_type type);
+void odin_protocol_handler(int sock, void *eloop_ctx, void *sock_ctx);
+void odin_handle_monitor_read(int sock, void *eloop_ctx, void *sock_ctx);
+
+#endif /* ODINAGENT_H */
diff --git a/src/tstl2cl/Makefile b/src/tstl2cl/Makefile
new file mode 100644
index 0000000..bc5b325
--- /dev/null
+++ b/src/tstl2cl/Makefile
@@ -0,0 +1,23 @@
+CC = gcc
+CFLAGS = -g -Wall -I. -I./include
+LDFLAGS = 
+BIN = tstl2cl
+LIBBIN = libtstl2cl.a
+OBJS = c_algo.o c_function.o c_list.o c_memory.o c_vector.o c_pair.o c_tree.o c_set.o c_map.o test/t_main.o \
+	test/t_list.o test/t_vector.o test/t_tree.o test/t_map.o test/t_set.o \
+	c_queue.o c_stack.o test/t_queue.o test/t_stack.o c_iterator.o test/t_algo.o
+
+LIBOBJS = c_algo.o c_function.o c_list.o c_memory.o c_vector.o c_pair.o c_tree.o c_set.o c_map.o \
+		c_queue.o c_stack.o c_iterator.o 
+
+all:	$(BIN)
+
+$(BIN):	$(OBJS)
+	$(CC) $^ -o $@
+	
+lib: $(LIBOBJS)
+	$(AR) rcs $(LIBBIN) $^
+	ranlib $(LIBBIN)
+
+clean:
+	$(RM) *.o ./test/*.o $(BIN)
diff --git a/src/tstl2cl/Makefile.win b/src/tstl2cl/Makefile.win
new file mode 100644
index 0000000..e768e69
--- /dev/null
+++ b/src/tstl2cl/Makefile.win
@@ -0,0 +1,103 @@
+# Project: tstl2cl
+# Makefile created by Dev-C++ 4.9.9.2
+
+CPP  = g++.exe -D__DEBUG__ -Wall
+CC   = gcc.exe -D__DEBUG__ -Wall
+WINDRES = windres.exe
+RES  = 
+OBJ  = c_list.o c_memory.o test/t_list.o c_algo.o c_function.o c_vector.o test/t_vector.o \
+       c_pair.o test/t_main.o c_tree.o test/t_tree.o c_map.o c_set.o test/t_map.o test/t_set.o \
+       test/t_stack.o c_stack.o test/t_queue.o c_queue.o c_iterator.o test/t_algo.o $(RES)
+LINKOBJ  = c_list.o c_memory.o test/t_list.o c_algo.o c_function.o c_vector.o test/t_vector.o \
+	   c_pair.o test/t_main.o c_tree.o test/t_tree.o c_map.o c_set.o test/t_map.o test/t_set.o \
+	   test/t_stack.o c_stack.o test/t_queue.o c_queue.o c_iterator.o test/t_algo.o $(RES)
+LIBOBJ = c_list.o c_memory.o c_algo.o c_function.o c_vector.o \
+       c_pair.o c_tree.o c_map.o c_set.o \
+       c_stack.o c_queue.o c_iterator.o 
+
+LIBS = -g3 
+INCS = -I"./include"  -I"./"  
+CXXINCS = -I"./include" -I"./"  
+BIN  = tstl2cl.exe
+LIBBIN = libtstl2cl.a
+CXXFLAGS = $(CXXINCS)   -g3
+CFLAGS = $(INCS)   -g3
+RM = rm -f
+
+.PHONY: all all-before all-after clean clean-custom lib
+
+all: all-before tstl2cl.exe all-after
+
+
+clean: clean-custom
+	${RM} $(OBJ) $(BIN)
+
+$(BIN): $(OBJ)
+	$(CC) $(LINKOBJ) -o "tstl2cl.exe" $(LIBS)
+
+c_list.o: c_list.c
+	$(CC) -c c_list.c -o c_list.o $(CFLAGS)
+
+c_memory.o: c_memory.c
+	$(CC) -c c_memory.c -o c_memory.o $(CFLAGS)
+
+test/t_list.o: test/t_list.c
+	$(CC) -c test/t_list.c -o test/t_list.o $(CFLAGS)
+
+c_algo.o: c_algo.c
+	$(CC) -c c_algo.c -o c_algo.o $(CFLAGS)
+
+c_function.o: c_function.c
+	$(CC) -c c_function.c -o c_function.o $(CFLAGS)
+
+c_vector.o: c_vector.c
+	$(CC) -c c_vector.c -o c_vector.o $(CFLAGS)
+
+test/t_vector.o: test/t_vector.c
+	$(CC) -c test/t_vector.c -o test/t_vector.o $(CFLAGS)
+
+c_pair.o: c_pair.c
+	$(CC) -c c_pair.c -o c_pair.o $(CFLAGS)
+
+test/t_main.o: test/t_main.c
+	$(CC) -c test/t_main.c -o test/t_main.o $(CFLAGS)
+
+c_tree.o: c_tree.c
+	$(CC) -c c_tree.c -o c_tree.o $(CFLAGS)
+
+test/t_tree.o: test/t_tree.c
+	$(CC) -c test/t_tree.c -o test/t_tree.o $(CFLAGS)
+
+c_map.o: c_map.c
+	$(CC) -c c_map.c -o c_map.o $(CFLAGS)
+
+c_set.o: c_set.c
+	$(CC) -c c_set.c -o c_set.o $(CFLAGS)
+
+test/t_map.o: test/t_map.c
+	$(CC) -c test/t_map.c -o test/t_map.o $(CFLAGS)
+
+test/t_set.o: test/t_set.c
+	$(CC) -c test/t_set.c -o test/t_set.o $(CFLAGS)
+
+c_stack.o: c_stack.c
+	$(CC) -c c_stack.c -o c_stack.o $(CFLAGS)
+
+test/t_stack.o: test/t_stack.c
+	$(CC) -c test/t_stack.c -o test/t_stack.o $(CFLAGS)
+
+c_queue.o: c_queue.c
+	$(CC) -c c_queue.c -o c_queue.o $(CFLAGS)
+
+test/t_queue.o: test/t_queue.c
+	$(CC) -c test/t_queue.c -o test/t_queue.o $(CFLAGS)
+
+c_iterator.o: c_iterator.c
+	$(CC) -c c_iterator.c -o c_iterator.o $(CFLAGS)
+
+t_algo.o: test/t_algo.c
+	$(CC) -c test/t_algo.c -o test/t_algo.o $(CFLAGS)
+
+lib: $(LIBOBJ)	
+	ar r $(LIBBIN) $(LIBOBJ)
+	ranlib $(LIBBIN)
diff --git a/src/tstl2cl/README b/src/tstl2cl/README
new file mode 100644
index 0000000..4a49289
--- /dev/null
+++ b/src/tstl2cl/README
@@ -0,0 +1,32 @@
+README for "Translate STL 2 CL" library 1.0
+The project could be found at http://sourceforge.net/projects/tstl2cl, using 'tstl2cl' for short in the following text.
+
+LICENSE
+'tstl2cl' has been distributing under the zlib/libpng license, you should have already received license.txt in this folder.
+For more information about free software, you could browse http://www.opensource.org/
+
+WHAT IS THIS
+This directory holds a library for using standard vector list map set stack queue etc in a pure C environment.
+All those of concepts in tstl2cl are inspired by STL. You could have a look at http://www.sgi.com/tech/stl/index.html 
+to know about C++ Standard Template Library i.e STL.
+
+WHEN TO USE 
+Make sure that you are working in a C environment rather than C++ or anything else before going on reading.
+If you get boring with writing basic data struct and algorithm again and agagin in C, tstl2cl would probably be the very 
+library kits for you. It will save you much of time of coding, then you could focus more on your applications' function. 
+  
+HOW TO USE
+Read documents in 'doc' folder, and many a samples could be found in 'test' folder. If you are familiar with STL, you would 
+probably find that to use this library is a snap.
+ 
+TO BUILD SAMPLES
+On linux 
+make clean all
+On cygwin
+make -f Makefile.win clean all
+You may have some problems to build this library in some minority C compiler, feel free to fix them. You could also report 
+bugs on the project's website: http://sourceforge.net/projects/tstl2cl.
+
+AUTHOR
+Wenbo Lao(Rob Lao) 
+viewpl(at)gmail.com
diff --git a/src/tstl2cl/c_algo.c b/src/tstl2cl/c_algo.c
new file mode 100644
index 0000000..7135eaf
--- /dev/null
+++ b/src/tstl2cl/c_algo.c
@@ -0,0 +1,373 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_algo.h"
+
+void c_iter_swap(c_iterator x, c_iterator y)
+{
+	value_type tmp = ITER_REF(x);
+	ITER_REF_ASSIGN(x, ITER_REF(y));
+	ITER_REF_ASSIGN(y, tmp);
+}
+
+c_iterator c_copy(c_iterator first, c_iterator last, c_iterator result)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first), ITER_INC(result))
+		ITER_REF_ASSIGN(result, ITER_REF(first));
+	return result;
+}
+
+c_iterator c_copy_backward(c_iterator first, c_iterator last, c_iterator result)
+{
+	while(!ITER_EQUAL(first, last))
+	{
+		ITER_DEC(result);
+		ITER_DEC(last);
+		ITER_REF_ASSIGN(result, ITER_REF(last));
+	}
+	return result;
+}
+
+c_bool c_lexicographical_compare(c_iterator first1, 
+                                    c_iterator last1, 
+                                    c_iterator first2, 
+                                    c_iterator last2,
+                                    COMPARER cmp)
+{
+	for(; !ITER_EQUAL(first1, last1) &&
+			!ITER_EQUAL(first2, last2);
+			ITER_INC(first1), ITER_INC(first2))
+	{
+		if((*cmp)(ITER_REF(first1), ITER_REF(first2)) < 0)
+			return true;
+		if((*cmp)(ITER_REF(first1), ITER_REF(first2)) > 0)
+			return false;
+	}
+	return (ITER_EQUAL(first1, last1) && !ITER_EQUAL(first2, last2));
+}
+
+c_iterator c_uninitialized_copy(c_iterator first, c_iterator last, c_iterator result)
+{
+	return c_copy(first, last, result);    
+}
+
+void c_fill(c_iterator first, c_iterator last, const value_type val)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		ITER_REF_ASSIGN(first, val);
+}
+
+c_iterator c_fill_n(c_iterator first, size_type n, const value_type val)
+{
+	for(; n > 0; -- n, ITER_INC(first))
+		ITER_REF_ASSIGN(first, val);
+	return first;
+}
+
+c_iterator c_uninitialized_fill_n(c_iterator first, size_type n, const value_type val)
+{
+	return c_fill_n(first, n, val);
+}
+
+c_bool c_equal(c_iterator first1, c_iterator last1, c_iterator first2, BINARY_PREDICATE pf)
+{
+	for(; !ITER_EQUAL(first1, last1); ITER_INC(first1), ITER_INC(first2))
+		if(!(pf)(ITER_REF(first1), ITER_REF(first2)))
+			return false;
+	return true;
+}
+
+c_bool c_equal2(c_iterator first1, c_iterator last1, c_iterator first2, c_binary_predicate binary_pred)
+{
+	for(; !ITER_EQUAL(first1, last1); ITER_INC(first1), ITER_INC(first2))
+		if(!(binary_pred.O)(&binary_pred, ITER_REF(first1), ITER_REF(first2)))
+			return false;
+	return true;
+}
+
+UNARY_FUNCTION c_for_each(c_iterator first, c_iterator last, UNARY_FUNCTION pf)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		pf(ITER_REF(first));
+	return pf;
+}
+
+c_iterator c_find(c_iterator first, c_iterator last, const value_type val)
+{
+	if(CHECK_RANDOM_ACCESS_ITERATOR(first))
+	{
+		difference_type tpc = ITER_DIFF(last, first) >> 2;
+		for(; tpc > 0; -- tpc)
+		{
+			if(ITER_REF(first) == val) 
+				return first;
+			ITER_INC(first);
+
+			if(ITER_REF(first) == val) 
+				return first;
+			ITER_INC(first);
+
+			if(ITER_REF(first) == val) 
+				return first;
+			ITER_INC(first);
+
+			if(ITER_REF(first) == val) 
+				return first;
+			ITER_INC(first);			
+		}
+
+		switch(ITER_DIFF(last, first))
+		{
+			case 3:
+				if(ITER_REF(first) == val)
+					return first;
+				ITER_INC(first);
+			case 2:
+				if(ITER_REF(first) == val)
+					return first;
+				ITER_INC(first);
+			case 1:
+				if(ITER_REF(first) == val)
+					return first;
+				ITER_INC(first);
+			case 0:
+			default:
+				return last;
+		}
+	}
+	else
+	{
+		while(!ITER_EQUAL(first, last) && !(ITER_REF(first) == val))
+			ITER_INC(first);
+		return first;
+	}
+}
+
+c_iterator c_find_if(c_iterator first, c_iterator last, UNARY_PREDICATE pf)
+{
+	if(CHECK_RANDOM_ACCESS_ITERATOR(first))
+	{
+		difference_type tpc = ITER_DIFF(last, first) >> 2;
+		for(; tpc > 0; -- tpc)
+		{
+			if(pf(ITER_REF(first))) 
+				return first;
+			ITER_INC(first);
+
+			if(pf(ITER_REF(first))) 
+				return first;
+			ITER_INC(first);
+
+			if(pf(ITER_REF(first))) 
+				return first;
+			ITER_INC(first);
+
+			if(pf(ITER_REF(first))) 
+				return first;
+			ITER_INC(first);			
+		}
+
+		switch(ITER_DIFF(last, first))
+		{
+			case 3:
+				if(pf(ITER_REF(first)))
+					return first;
+				ITER_INC(first);
+			case 2:
+				if(pf(ITER_REF(first)))
+					return first;
+				ITER_INC(first);
+			case 1:
+				if(pf(ITER_REF(first)))
+					return first;
+				ITER_INC(first);
+			case 0:
+			default:
+				return last;
+		}
+	}
+	else
+	{
+		while(!ITER_EQUAL(first, last) && !pf(ITER_REF(first)))
+			ITER_INC(first);
+		return first;
+	}
+}
+
+c_iterator c_adjacent_find(c_iterator first, c_iterator last, BINARY_PREDICATE pf)
+{
+	c_iterator next = first;
+
+	if(ITER_EQUAL(first, last))
+		return last;
+
+	while(!c_iter_equal(ITER_INC(next), last))
+	{
+		if(pf(ITER_REF(first), ITER_REF(next)))
+			return first;
+		first = next;
+	}
+	return last;
+}
+
+size_type c_count(c_iterator first, c_iterator last, const value_type val)
+{
+	size_type n = 0;
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		if(ITER_REF(first) == val)
+			++ n;
+	return n;
+}
+
+size_type c_count_if(c_iterator first, c_iterator last, UNARY_PREDICATE pf)
+{
+	size_type n = 0;
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		if(pf(ITER_REF(first)))
+			++ n;
+	return n;
+}
+
+void c_reverse(c_iterator first, c_iterator last)
+{
+	if(CHECK_RANDOM_ACCESS_ITERATOR(first))
+	{
+		while(ITER_LESS(first, last))
+		{
+			c_iter_swap(first, ITER_DEC(last));
+			ITER_INC(first);
+		}
+	}
+	else
+	{
+		while(true)
+			if(ITER_EQUAL(first, last) || 
+					c_iter_equal(first, ITER_DEC(last)))
+				return;
+			else
+			{
+				c_iter_swap(first, last);
+				ITER_INC(first);
+			}
+	}
+}
+
+c_iterator c_search(c_iterator first1, 
+			c_iterator last1, 
+			c_iterator first2, 
+			c_iterator last2,
+			BINARY_PREDICATE pf)
+{
+	if(ITER_EQUAL(first1, last1) ||
+			ITER_EQUAL(first2, last2))
+		return first1;
+
+	if(true)	
+	{
+		c_iterator tmp = first2;
+		ITER_INC(tmp);
+		if(ITER_EQUAL(tmp, last2))
+		{
+			while(!ITER_EQUAL(first1, last1) &&
+					!pf(ITER_REF(first1), ITER_REF(first2)))
+				ITER_INC(first1);
+			return first1;
+		}
+	}
+
+	if(true)
+	{
+		c_iterator p1, p;
+		c_iterator current = first1;
+		
+		p1 = first2;
+		ITER_INC(p1);
+
+		while(!ITER_EQUAL(first1, last1))
+		{
+			while(!ITER_EQUAL(first1, last1))
+			{
+				if(pf(ITER_REF(first1), ITER_REF(first2)))
+					break;
+				ITER_INC(first1);
+			}
+			
+			while(!ITER_EQUAL(first1, last1) &&
+					!pf(ITER_REF(first1), ITER_REF(first2)))
+				ITER_INC(first1);
+			if(ITER_EQUAL(first1, last1))
+				return last1;
+
+			p = p1;
+			current = first1;
+			ITER_INC(current);
+			if(ITER_EQUAL(current, last1))
+				return last1;
+
+			while(pf(ITER_REF(current), ITER_REF(p)))
+			{
+				ITER_INC(p);
+				if(ITER_EQUAL(p, last2))
+					return first1;
+				ITER_INC(current);
+				if(ITER_EQUAL(current, last1))
+					return last1;
+			}
+
+			ITER_INC(first1);
+		}
+
+		return first1;
+	}
+}
+
+
diff --git a/src/tstl2cl/c_algo.h b/src/tstl2cl/c_algo.h
new file mode 100644
index 0000000..0af8484
--- /dev/null
+++ b/src/tstl2cl/c_algo.h
@@ -0,0 +1,114 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+/* 
+NOTE: This is an internal header file, You should not attempt to use it directly.
+*/
+
+#ifndef _C_ALGO_H
+#define _C_ALGO_H
+
+#include "c_iterator.h"
+#include "c_function.h"
+
+#define c_iter_swap			_c_iter_swap
+#define c_copy                          _c_copy  
+#define c_copy_backward                 _c_copy_backward
+#define c_lexicographical_compare       _c_lexicographical_compare
+#define c_uninitialized_copy            _c_uninitialized_copy
+#define c_fill                          _c_fill
+#define c_fill_n                        _c_fill_n
+#define c_uninitialized_fill_n          _c_unintialized_fill_n
+#define c_equal                         _c_equal
+#define c_equal2                        _c_equal2
+#define c_for_each			_c_for_each
+#define c_find				_c_find
+#define c_find_if			_c_find_if
+#define c_adjacent_find			_c_adjacent_find
+#define c_count				_c_count
+#define c_count_if			_c_count_if
+#define c_reverse			_c_reverse
+#define c_search			_c_search
+
+void c_iter_swap(c_iterator x, c_iterator y);
+c_iterator c_copy(c_iterator first, c_iterator last, c_iterator result);
+c_iterator c_copy_backward(c_iterator first, c_iterator last, c_iterator result);
+c_bool c_lexicographical_compare(c_iterator first1, 
+                                    c_iterator last1, 
+                                    c_iterator first2, 
+                                    c_iterator last2,
+                                    COMPARER cmp);
+c_iterator c_uninitialized_copy(c_iterator first, c_iterator last, c_iterator result);
+void c_fill(c_iterator first, c_iterator last, const value_type val);
+c_iterator c_fill_n(c_iterator first, size_type n, const value_type val);
+c_iterator c_uninitialized_fill_n(c_iterator first, size_type n, const value_type val);
+c_bool c_equal(c_iterator first1, c_iterator last1, c_iterator first2, BINARY_PREDICATE pf);
+c_bool c_equal2(c_iterator first1, c_iterator last1, c_iterator first2, c_binary_predicate binary_pred);
+UNARY_FUNCTION c_for_each(c_iterator first, c_iterator last, UNARY_FUNCTION pf);
+c_iterator c_find(c_iterator first, c_iterator last, const value_type val);
+c_iterator c_find_if(c_iterator first, c_iterator last, UNARY_PREDICATE pf);
+c_iterator c_adjacent_find(c_iterator first, c_iterator last, BINARY_PREDICATE pf);
+size_type c_count(c_iterator first, c_iterator last, const value_type val);
+size_type c_count_if(c_iterator first, c_iterator last, UNARY_PREDICATE pf);
+void c_reverse(c_iterator first, c_iterator last);
+c_iterator c_search(c_iterator first1, 
+			c_iterator last1, 
+			c_iterator first2, 
+			c_iterator last2,
+			BINARY_PREDICATE pf);
+
+
+#define C_SWAP(X, Y, TMP)   do{(TMP)=(X);(X)=(Y);(Y)=(TMP);}while(0)
+#define C_MAX(X, Y) ((X) >= (Y) ? (X) : (Y))
+#define C_MIN(X, Y) ((X) <= (Y) ? (X) : (Y))
+
+#endif /* _C_ALGO_H */
diff --git a/src/tstl2cl/c_function.c b/src/tstl2cl/c_function.c
new file mode 100644
index 0000000..74dc3fe
--- /dev/null
+++ b/src/tstl2cl/c_function.c
@@ -0,0 +1,146 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_function.h"
+#include "c_pair.h"
+
+static c_bool _c_unary_negate_impl(c_unary_predicate * thiz, value_type val)
+{
+	return !((UNARY_PREDICATE)(thiz->_l))(val);
+}
+
+c_unary_predicate c_unary_negate(UNARY_PREDICATE unary_pred)
+{
+	c_unary_predicate up;
+	up.O = _c_unary_negate_impl;
+	up._l = unary_pred;
+	return up;
+}
+
+static c_bool _c_binary_negate_impl(c_binary_predicate * thiz, value_type val1, value_type val2)
+{
+	return !((BINARY_PREDICATE)(thiz->_l))(val1, val2);    
+}
+
+c_binary_predicate c_binary_negate(BINARY_PREDICATE binary_pred)
+{
+	c_binary_predicate bp;
+	bp.O = _c_binary_negate_impl;
+	bp._l = binary_pred;
+	return bp;
+}
+
+static value_type _c_identity_impl(c_unary_function * thiz, value_type val)
+{
+	return val;	
+}
+
+c_unary_function c_identity()
+{
+	c_unary_function uf;
+	uf.O = _c_identity_impl;
+	uf._l = NULL;
+	return uf;
+}
+
+static value_type _c_select1st_impl(c_unary_function * thiz, value_type val)
+{
+	return ((c_ppair)(val))->first;
+}
+
+c_unary_function c_select1st()
+{
+	c_unary_function uf;
+	uf.O = _c_select1st_impl;
+	uf._l = NULL;
+	return uf;    
+}
+
+static value_type _c_select1stptr_impl(c_unary_function * thiz, value_type val)
+{
+	return (value_type)(&((c_ppair)(val))->first);
+}
+
+c_unary_function c_select1stptr()
+{
+	c_unary_function uf;
+	uf.O = _c_select1stptr_impl;
+	uf._l = NULL;
+	return uf;
+}
+
+static c_bool _c_unary_adapt_impl(c_unary_predicate * thiz, value_type val)
+{
+	return ((UNARY_PREDICATE)(thiz->_l))(val);
+}
+
+c_unary_predicate c_unary_adapt(UNARY_PREDICATE unary_pred)
+{
+	c_unary_predicate up;
+	up.O = _c_unary_adapt_impl;
+	up._l = unary_pred;
+	return up;	
+}
+
+static c_bool _c_binary_adapt_impl(c_binary_predicate * thiz, value_type val1, value_type val2)
+{
+	return ((BINARY_PREDICATE)(thiz->_l))(val1, val2);    
+}
+
+c_binary_predicate c_binary_adapt(BINARY_PREDICATE binary_pred)
+{
+	c_binary_predicate bp;
+	bp.O = _c_binary_adapt_impl;
+	bp._l = binary_pred;
+	return bp;
+}
+
diff --git a/src/tstl2cl/c_function.h b/src/tstl2cl/c_function.h
new file mode 100644
index 0000000..04cba2d
--- /dev/null
+++ b/src/tstl2cl/c_function.h
@@ -0,0 +1,126 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+/* 
+NOTE: This is an internal header file, You should not attempt to use it directly.
+*/
+
+#ifndef _C_FUNCTION_H
+#define _C_FUNCTION_H
+
+#include "c_iterator.h"
+
+#define c_unary_function		_c_unary_function
+#define c_binary_function		_c_binary_function
+#define c_unary_predicate		_c_unary_predicate
+#define c_binary_predicate		_c_binary_predicate
+
+#define c_unary_negate			_c_unary_negate
+#define c_binary_negate			_c_binary_negate
+
+#define c_identity			_c_identity
+#define c_select1st			_c_select1st
+#define c_select1stptr			_c_select1stptr
+
+#define c_unary_adapt			_c_unary_adapt
+#define c_binary_adapt			_c_binary_adapt
+
+typedef value_type (*UNARY_FUNCTION)(value_type);
+typedef value_type (*BINARY_FUNCTION)(value_type, value_type);
+typedef c_bool (*UNARY_PREDICATE)(value_type);
+typedef c_bool (*BINARY_PREDICATE)(value_type, value_type);
+typedef c_bool (*PREDICATE)(value_type);
+
+
+typedef struct c_unary_function c_unary_function;
+typedef struct c_binary_function c_binary_function;
+
+struct c_unary_function
+{
+	value_type (*O)(c_unary_function * thiz, value_type val);
+	void * _l;
+};
+
+struct c_binary_fuction
+{
+	value_type (*O)(c_binary_function * thiz, value_type val1, value_type val2);
+	void * _l;
+};
+
+typedef struct c_unary_predicate c_unary_predicate;
+typedef struct c_binary_predicate c_binary_predicate;
+
+struct c_unary_predicate
+{
+	c_bool (*O)(c_unary_predicate * thiz, value_type val);
+	void * _l;
+};
+
+struct c_binary_predicate
+{
+	c_bool (*O)(c_binary_predicate * thiz, value_type val1, value_type val2);
+	void * _l;
+};
+
+
+c_unary_predicate c_unary_negate(UNARY_PREDICATE unary_pred);
+c_binary_predicate c_binary_negate(BINARY_PREDICATE binary_pred);
+
+c_unary_function c_identity();
+c_unary_function c_select1st();
+c_unary_function c_select1stptr();
+
+c_unary_predicate c_unary_adapt(UNARY_PREDICATE unary_pred);
+c_binary_predicate c_binary_adapt(BINARY_PREDICATE binary_pred);
+
+#endif /* _C_FUNCTION_H */
+
diff --git a/src/tstl2cl/c_iterator.c b/src/tstl2cl/c_iterator.c
new file mode 100644
index 0000000..a500363
--- /dev/null
+++ b/src/tstl2cl/c_iterator.c
@@ -0,0 +1,375 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_iterator.h"
+
+typedef void ** pp_t;
+
+static c_iterator _c_array_iterator_assign(c_piterator thiz, const c_piterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_array_iterator_ref(c_piterator thiz)
+{
+	return *(pp_t)thiz->_i;
+}
+
+static value_type _c_array_iterator_ref_assign(c_piterator thiz, const value_type val)
+{
+	return *(pp_t)thiz->_i = val;
+}
+
+static c_iterator _c_array_iterator_inc(c_piterator thiz)
+{
+	pp_t p = thiz->_i;
+	++ p;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_iterator _c_array_iterator_inc_n(c_piterator thiz, difference_type n)
+{
+	pp_t p = thiz->_i;
+	p += n;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_iterator _c_array_iterator_dec(c_piterator thiz)
+{
+	pp_t p = thiz->_i;
+	-- p;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_iterator _c_array_iterator_dec_n(c_piterator thiz, difference_type n)
+{
+	pp_t p = thiz->_i;
+	p -= n;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static difference_type _c_array_iterator_diff(c_piterator thiz, const c_piterator val)
+{
+	return ((pp_t)thiz->_i - (pp_t)val->_i);
+}
+
+static value_type _c_array_iterator_at(c_piterator thiz, difference_type n)
+{
+	return *((pp_t)thiz->_i + n);
+}
+
+static c_iterator _c_array_iterator_positive_n(c_piterator thiz, difference_type n)
+{
+	c_iterator iter;
+	pp_t p = thiz->_i;
+	p += n;    
+	iter = c_get_array_iterator(p);
+	return iter;   
+}
+
+static c_iterator _c_array_iterator_negative_n(c_piterator thiz, difference_type n)
+{
+	c_iterator iter;
+	pp_t p = thiz->_i;
+	p -= n;
+	iter = c_get_array_iterator(p);
+	return iter;
+}
+
+static c_bool _c_array_iterator_equal(c_piterator thiz, const c_piterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_bool _c_array_iterator_less(c_piterator thiz, const c_piterator val)
+{
+	return ((pp_t)thiz->_i < (pp_t)val->_i);
+}
+
+static c_iterator_ft _c_array_iterator_ft = 
+{
+	_c_array_iterator_assign,
+	_c_array_iterator_ref,
+	_c_array_iterator_ref_assign,
+	_c_array_iterator_inc,
+	_c_array_iterator_inc_n,
+	_c_array_iterator_dec,
+	_c_array_iterator_dec_n,
+	_c_array_iterator_diff,
+	_c_array_iterator_at,
+	_c_array_iterator_positive_n,
+	_c_array_iterator_negative_n,
+	_c_array_iterator_equal,
+	_c_array_iterator_less
+};
+
+c_iterator c_get_array_iterator(void ** ppt)
+{
+	c_iterator iter;
+	iter._pft = &_c_array_iterator_ft;
+	iter._i = ppt;
+	return iter;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_assign(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_array_reverse_iterator_ref(c_preverse_iterator thiz)
+{
+	return *(pp_t)thiz->_i;
+}
+
+static value_type _c_array_reverse_iterator_ref_assign(c_preverse_iterator thiz, const value_type val)
+{
+	return *(pp_t)thiz->_i = val;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_inc(c_preverse_iterator thiz)
+{
+	pp_t p = thiz->_i;
+	-- p;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_inc_n(c_preverse_iterator thiz, difference_type n)
+{
+	pp_t p = thiz->_i;
+	p -= n;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_dec(c_preverse_iterator thiz)
+{
+	pp_t p = thiz->_i;
+	++ p;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_dec_n(c_preverse_iterator thiz, difference_type n)
+{
+	pp_t p = thiz->_i;
+	p += n;
+	thiz->_i = p;
+	return *thiz;
+}
+
+static difference_type _c_array_reverse_iterator_diff(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return ((pp_t)val->_i - (pp_t)thiz->_i);
+}
+
+static value_type _c_array_reverse_iterator_at(c_preverse_iterator thiz, difference_type n)
+{
+	return *((pp_t)thiz->_i - n);
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_positive_n(c_preverse_iterator thiz, difference_type n)
+{
+	c_reverse_iterator iter;
+	pp_t p = thiz->_i;
+	p -= n;
+	iter = c_get_array_reverse_iterator(p);
+	return iter;
+}
+
+static c_reverse_iterator _c_array_reverse_iterator_negative_n(c_preverse_iterator thiz, difference_type n)
+{
+	c_reverse_iterator iter;
+	pp_t p = thiz->_i;
+	p += n;
+	iter = c_get_array_reverse_iterator(p);
+	return iter;
+}
+
+static c_bool _c_array_reverse_iterator_equal(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_bool _c_array_reverse_iterator_less(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return ((pp_t)thiz->_i > (pp_t)val->_i);
+}
+
+static c_reverse_iterator_ft _c_array_reverse_iterator_ft = 
+{
+	_c_array_reverse_iterator_assign,
+	_c_array_reverse_iterator_ref,
+	_c_array_reverse_iterator_ref_assign,
+	_c_array_reverse_iterator_inc,
+	_c_array_reverse_iterator_inc_n,
+	_c_array_reverse_iterator_dec,
+	_c_array_reverse_iterator_dec_n,
+	_c_array_reverse_iterator_diff,
+	_c_array_reverse_iterator_at,
+	_c_array_reverse_iterator_positive_n,
+	_c_array_reverse_iterator_negative_n,
+	_c_array_reverse_iterator_equal,
+	_c_array_reverse_iterator_less
+};
+
+c_reverse_iterator c_get_array_reverse_iterator(void ** ppt)
+{
+	c_reverse_iterator iter;
+	iter._pft = &_c_array_reverse_iterator_ft;
+	iter._i = ppt;
+	return iter;
+}
+
+difference_type c_distance(c_iterator first, c_iterator last)
+{
+	if(CHECK_RANDOM_ACCESS_ITERATOR(first) &&
+		CHECK_RANDOM_ACCESS_ITERATOR(last))
+		return ITER_DIFF(last, first);
+	else
+	{
+		difference_type n = 0;
+		while(!ITER_EQUAL(first, last))
+		{
+			ITER_INC(first);
+			++ n;
+		}
+		return n;
+	}
+}
+
+void c_distance1(c_iterator first, c_iterator last, difference_type * pn)
+{
+	if(CHECK_RANDOM_ACCESS_ITERATOR(first) &&
+		CHECK_RANDOM_ACCESS_ITERATOR(last))
+		*pn += ITER_DIFF(last, first);
+	else
+	{
+		while(!ITER_EQUAL(first, last))
+		{
+			ITER_INC(first);
+			++ *pn;
+		}
+    	}
+}
+
+void c_advance(c_piterator pval, difference_type n)
+{
+	c_iterator val = *pval;
+	if(CHECK_RANDOM_ACCESS_ITERATOR(val))
+		ITER_INC_N(val, n);
+	else if(CHECK_BIDIRECTIONAL_ITERATOR(val))
+	{
+		if(n >= 0)
+			while(n --)
+				ITER_INC(val);
+		else
+			while(n ++)
+				ITER_DEC(val);
+	}
+	else
+		while(n --)
+			ITER_INC(val);
+	*pval = val;
+}
+
+value_type c_iter_ref(c_iterator x)
+{
+	return ITER_REF(x);
+}
+
+value_type c_iter_ref_assign(c_iterator x, const value_type val)
+{
+	return ITER_REF_ASSIGN(x, val);
+}
+
+difference_type c_iter_diff(c_iterator x, c_iterator y)
+{
+	return ITER_DIFF(x, y);
+}
+
+value_type c_iter_at(c_iterator x, difference_type n)
+{
+	return ITER_AT(x, n);
+}
+
+c_iterator c_iter_positive_n(c_iterator x, difference_type n)
+{
+	return ITER_POSITIVE_N(x, n);
+}
+
+c_iterator c_iter_negative_n(c_iterator x, difference_type n)
+{
+	return ITER_NEGATIVE_N(x, n);
+}
+
+c_bool c_iter_equal(c_iterator x, c_iterator y)
+{
+	return ITER_EQUAL(x, y);
+}
+
+c_bool c_iter_less(c_iterator x, c_iterator y)
+{
+	return ITER_LESS(x, y);
+}
+
+
diff --git a/src/tstl2cl/c_list.c b/src/tstl2cl/c_list.c
new file mode 100644
index 0000000..1b4b6c2
--- /dev/null
+++ b/src/tstl2cl/c_list.c
@@ -0,0 +1,540 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_list.h"
+#include "c_memory.h"
+#include "c_algo.h"
+
+typedef struct _A_list_node  _A_list_node;
+
+struct _A_list_node {
+	_A_list_node * _A_next;
+	_A_list_node * _A_prev;
+	void * _A_node;
+};
+
+static _A_list_node * _A_list_node_next(_A_list_node * thiz)
+{
+	return (thiz ? thiz->_A_next : NULL);
+}
+
+static _A_list_node * _A_list_node_prev(_A_list_node * thiz)
+{
+	return (thiz ? thiz->_A_prev : NULL);
+}
+
+static c_iterator _c_list_iterator_assign(c_piterator thiz, const c_piterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_list_iterator_ref(c_piterator thiz)
+{
+	return ((_A_list_node *)thiz->_i)->_A_node;
+}
+
+static value_type _c_list_iterator_ref_assign(c_piterator thiz, const value_type val)
+{
+	return ((_A_list_node *)thiz->_i)->_A_node = val;
+}
+
+static c_iterator _c_list_iterator_inc(c_piterator thiz)
+{
+	thiz->_i = _A_list_node_next((_A_list_node *)thiz->_i);
+	return *thiz;
+}
+
+static c_iterator _c_list_iterator_dec(c_piterator thiz)
+{
+	thiz->_i = _A_list_node_prev((_A_list_node *)thiz->_i);
+	return *thiz;
+}
+
+static c_bool _c_list_iterator_equal(c_piterator thiz, const c_piterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_iterator_ft _c_list_iter_ft = 
+{
+	_c_list_iterator_assign,
+	_c_list_iterator_ref,
+	_c_list_iterator_ref_assign,
+	_c_list_iterator_inc,
+	NULL,   /* _c_list_iterator_inc_n */
+	_c_list_iterator_dec,
+	NULL,   /* _c_list_iterator_dec_n */
+	NULL,   /* _c_list_iterator_diff */
+	NULL,   /* _c_list_iterator_at */
+	NULL,   /* _c_list_iterator_positive_n */
+	NULL,   /* _c_list_iterator_negative_n */
+	_c_list_iterator_equal,
+	NULL,   /* _c_list_iterator_less */
+};
+
+
+static c_reverse_iterator _c_list_reverse_iterator_assign(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_list_reverse_iterator_ref(c_preverse_iterator thiz)
+{
+	return ((_A_list_node *)thiz->_i)->_A_prev->_A_node;    
+}
+
+value_type _c_list_reverse_iterator_ref_assign(c_preverse_iterator thiz, const value_type val)
+{
+	return ((_A_list_node *)thiz->_i)->_A_node = val;    
+}
+    
+static c_reverse_iterator _c_list_reverse_iterator_inc(c_preverse_iterator thiz)
+{
+	thiz->_i = _A_list_node_prev((_A_list_node *)thiz->_i);
+	return *thiz;
+}
+
+static c_reverse_iterator _c_list_reverse_iterator_dec(c_preverse_iterator thiz)
+{
+	thiz->_i = _A_list_node_next((_A_list_node *)thiz->_i);
+	return *thiz;
+}
+
+static c_bool _c_list_reverse_iterator_equal(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_reverse_iterator_ft _c_list_rev_iter_ft = 
+{
+	_c_list_reverse_iterator_assign,
+	_c_list_reverse_iterator_ref,
+	_c_list_reverse_iterator_ref_assign,
+	_c_list_reverse_iterator_inc,
+	NULL,   /* _c_list_reverse_iterator_inc_n */
+	_c_list_reverse_iterator_dec,
+	NULL,   /* _c_list_reverse_iterator_dec_n */
+	NULL,   /* _c_list_reverse_iterator_diff */
+	NULL,   /* _c_list_reverse_iterator_at */
+	NULL,   /* _c_list_reverse_iterator_positive_n */
+	NULL,   /* _c_list_reverse_iterator_negative_n */
+	_c_list_reverse_iterator_equal,
+	NULL,   /* _c_list_reverse_iterator_less */      
+};
+
+typedef struct _c_list_impl
+{
+	_A_list_node * _end_node;
+} _c_list_impl;
+
+static c_iterator _A_get_iterator(_A_list_node * val)
+{
+	c_iterator iter;
+	iter._pft = &_c_list_iter_ft;
+	iter._i = val;
+	return iter;
+}
+
+static c_reverse_iterator _A_get_reverse_iterator(_A_list_node * val)
+{
+	c_reverse_iterator iter;
+	iter._pft = &_c_list_rev_iter_ft;
+	iter._i = val;
+	return iter;    
+}
+
+static _A_list_node * _A_get_list_node(c_plist thiz)
+{
+	return __c_malloc(sizeof(_A_list_node));
+}
+
+static void _A_put_list_node(c_plist thiz, _A_list_node * p)
+{
+	__c_free(p);
+}
+
+static void _A_transfer(c_plist thiz, c_iterator pos, c_iterator first, c_iterator last)
+{
+	if(!ITER_EQUAL(first, last))
+	{
+		_A_list_node * tmp;
+		((_A_list_node *)last._i)->_A_prev->_A_next = pos._i;
+		((_A_list_node *)first._i)->_A_prev->_A_next = last._i;
+		((_A_list_node *)pos._i)->_A_prev->_A_next = first._i;
+        
+		tmp = ((_A_list_node *)pos._i)->_A_prev;
+		((_A_list_node *)pos._i)->_A_prev = ((_A_list_node *)last._i)->_A_prev;
+		((_A_list_node *)last._i)->_A_prev = ((_A_list_node *)first._i)->_A_prev;
+		((_A_list_node *)first._i)->_A_prev = tmp;
+	}
+}
+
+void __c_list(c_plist thiz, COMPARER pcmp)
+{
+	_A_list_node * node;
+	thiz->_cmp = pcmp;
+	node = _A_get_list_node(thiz);
+	node->_A_node = NULL;
+	node->_A_next = node;
+	node->_A_prev = node;
+	thiz->_l = __c_malloc(sizeof(_c_list_impl));
+	((_c_list_impl *)thiz->_l)->_end_node = node;
+}
+
+void __c_tsil(c_plist thiz)
+{
+	c_list_clear(thiz);
+	_A_put_list_node(thiz, ((_c_list_impl *)thiz->_l)->_end_node);
+	__c_free(thiz->_l);
+}
+
+c_iterator c_list_begin(c_plist thiz)
+{
+	return _A_get_iterator(((_c_list_impl *)thiz->_l)->_end_node->_A_next);
+}
+
+c_iterator c_list_end(c_plist thiz)
+{
+	return _A_get_iterator(((_c_list_impl *)thiz->_l)->_end_node);    
+}
+
+c_reverse_iterator c_list_rbegin(c_plist thiz)
+{
+	c_reverse_iterator riter = _A_get_reverse_iterator(NULL);
+	c_iterator iter = c_list_end(thiz); 
+	riter._i = iter._i;
+	return riter;
+}
+
+c_reverse_iterator c_list_rend(c_plist thiz)
+{
+	c_reverse_iterator riter = _A_get_reverse_iterator(NULL);
+	c_iterator iter = c_list_begin(thiz);
+	riter._i = iter._i; 
+	return riter;
+}
+
+size_t c_list_size(c_plist thiz)
+{
+	return c_distance(c_list_begin(thiz), c_list_end(thiz));
+}
+    
+c_bool c_list_empty(c_plist thiz)
+{
+	_A_list_node * end_node = ((_c_list_impl *)thiz->_l)->_end_node;     
+	return end_node == end_node->_A_next;
+}
+
+c_plist c_list_assign(c_plist thiz, const c_plist L)
+{
+	if(!c_list_equal(thiz, L))
+	{
+		c_iterator first1 = c_list_begin(thiz);
+		c_iterator last1 = c_list_end(thiz);
+		c_iterator first2 = c_list_begin(L);
+		c_iterator last2 = c_list_end(L);
+		while(!ITER_EQUAL(first1, last1) && 
+				!ITER_EQUAL(first2, last2))
+		{
+			ITER_REF_ASSIGN(first1, ITER_REF(first2));
+			ITER_INC(first1);
+			ITER_INC(first2);
+		}
+		if(ITER_EQUAL(first2, last2))
+			c_list_erase2(thiz, first1, last1); 
+		else
+			c_list_insert2(thiz, last1, first2, last2);            
+	}
+	return thiz;
+}
+
+value_type c_list_front(c_plist thiz)
+{
+	c_iterator iter = c_list_begin(thiz);
+	return ITER_REF(iter); 
+}
+
+value_type c_list_back(c_plist thiz)
+{
+	c_iterator iter = c_list_end(thiz);
+	ITER_DEC(iter); 
+	return ITER_REF(iter); 
+}
+
+void c_list_push_front(c_plist thiz, const value_type val)
+{
+	c_list_insert(thiz, c_list_begin(thiz), val);
+}
+
+void c_list_push_back(c_plist thiz, const value_type val)
+{
+	c_list_insert(thiz, c_list_end(thiz), val);
+}
+
+void c_list_pop_front(c_plist thiz)
+{
+	c_list_erase(thiz, c_list_begin(thiz));
+}
+
+void c_list_pop_back(c_plist thiz)
+{
+	c_iterator iter = c_list_end(thiz);
+	ITER_DEC(iter); 
+	c_list_erase(thiz, iter);
+}
+
+void c_list_swap(c_plist thiz, c_plist L)
+{
+	c_list tmp = *thiz;
+	*thiz = *L;
+	*L = tmp;   
+}
+
+c_iterator c_list_insert(c_plist thiz, c_iterator pos, const value_type val)
+{
+	_A_list_node * node = _A_get_list_node(thiz);
+	node->_A_node = val; 
+	node->_A_next = (_A_list_node *)pos._i;
+	node->_A_prev = ((_A_list_node *)pos._i)->_A_prev;
+	((_A_list_node *)pos._i)->_A_prev->_A_next = node;
+	((_A_list_node *)pos._i)->_A_prev = node;
+	return _A_get_iterator(node);
+}
+
+void c_list_insert2(c_plist thiz, c_iterator pos, c_iterator first, c_iterator last)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		c_list_insert(thiz, pos, ITER_REF(first)); 
+}
+
+c_iterator c_list_erase(c_plist thiz, c_iterator pos)
+{
+	c_iterator end = c_list_end(thiz); 
+	if(!ITER_EQUAL(end, pos))
+	{
+		_A_list_node * next = ((_A_list_node *)pos._i)->_A_next;
+		_A_list_node * prev = ((_A_list_node *)pos._i)->_A_prev;
+		_A_list_node * nd = (_A_list_node *)pos._i;
+		prev->_A_next = next;
+		next->_A_prev = prev;
+		_A_put_list_node(thiz, nd);
+		return _A_get_iterator(next);   
+	}
+	return end;   
+}
+
+c_iterator c_list_erase2(c_plist thiz, c_iterator first, c_iterator last)
+{
+	while(!ITER_EQUAL(first, last))
+		first = c_list_erase(thiz, first);
+	return last;
+}
+
+void c_list_clear(c_plist thiz)
+{
+	_A_list_node * end_node = ((_c_list_impl *)thiz->_l)->_end_node;
+	_A_list_node * iter = end_node->_A_next;
+	while(iter != end_node)
+	{
+		_A_list_node * tmp = iter;
+		iter = iter->_A_next;
+		_A_put_list_node(thiz, tmp);
+	}
+	end_node->_A_next = end_node;
+	end_node->_A_prev = end_node;
+}
+
+void c_list_splice(c_plist thiz, c_iterator pos, c_plist L)
+{
+	if(!c_list_empty(L))
+		_A_transfer(thiz, pos, c_list_begin(L), c_list_end(L));
+}
+
+void c_list_splice1(c_plist thiz, c_iterator pos, c_plist L, c_iterator i)
+{
+	c_iterator j = i;
+	ITER_INC(j);
+	if(ITER_EQUAL(pos, i) || ITER_EQUAL(pos, j))
+		return;
+	_A_transfer(thiz, pos, i, j);
+}
+
+void c_list_splice2(c_plist thiz, c_iterator pos, c_plist L, c_iterator first, c_iterator last)
+{
+	if(!ITER_EQUAL(first, last))
+		_A_transfer(thiz, pos, first, last);
+}
+
+void c_list_remove(c_plist thiz, value_type val)
+{
+	c_iterator iter = c_list_begin(thiz);
+	c_iterator end = c_list_end(thiz);
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator tmp = iter;
+		ITER_INC(iter);
+		if((ITER_REF(tmp) == val) ||
+				!(*thiz->_cmp)(val, ((_A_list_node *)tmp._i)->_A_node))
+			c_list_erase(thiz, tmp);
+	}
+}
+
+void c_list_unique(c_plist thiz)
+{
+	c_iterator first = c_list_begin(thiz); 
+	c_iterator last = c_list_end(thiz);
+	c_iterator next; 
+	if(ITER_EQUAL(first, last))
+		return;
+	next = first;
+	ITER_INC(next);
+	while(!ITER_EQUAL(last, next))
+	{
+		if(!(*thiz->_cmp)(ITER_REF(first), ITER_REF(next)))
+			c_list_erase(thiz, next); 
+		else
+			ITER_ASSIGN(first, next);
+		ITER_ASSIGN(next, first);
+		ITER_INC(next);
+	}
+}
+
+void c_list_merge(c_plist thiz, c_plist L)
+{
+	c_iterator first1 = c_list_begin(thiz);
+	c_iterator last1 = c_list_end(thiz);
+	c_iterator first2 = c_list_begin(L);
+	c_iterator last2 = c_list_end(L);
+    
+	while(!ITER_EQUAL(first1, last1) &&
+			!ITER_EQUAL(first2, last2))
+		if((*thiz->_cmp)(ITER_REF(first2),
+					ITER_REF(first1)) < 0)
+		{
+			c_iterator next = first2;
+			_A_transfer(thiz, first1, first2, ITER_INC(next));
+			ITER_ASSIGN(first2, next);
+		}
+		else
+			ITER_INC(first1);
+	if(!ITER_EQUAL(first2, last2))
+		_A_transfer(thiz, last1, first2, last2);
+}
+
+void c_list_sort(c_plist thiz)
+{
+	_A_list_node * node = ((_c_list_impl *)thiz->_l)->_end_node;
+    
+	if(node->_A_next != node && node->_A_next->_A_next != node)
+	{
+		c_list cry;
+		c_list cnt[64];
+		int fill = 0, i = 0;
+		__c_list(&cry, thiz->_cmp);
+		for(fill = 0; fill < 64; ++ fill)
+			__c_list(&cnt[fill], thiz->_cmp);
+        	
+		fill = 0;
+		while(!c_list_empty(thiz))
+		{
+			c_list_splice1(&cry, c_list_begin(&cry), thiz, c_list_begin(thiz));
+			i = 0;
+			while(i < fill && !c_list_empty(&cnt[i]))
+			{
+				c_list_merge(&cnt[i], &cry);
+				c_list_swap(&cry, &cnt[i ++]);
+			}
+			c_list_swap(&cry, &cnt[i]);
+			if(i == fill)
+				++ fill;
+		}
+		for(i = 1; i < fill; ++ i)
+			c_list_merge(&cnt[i], &cnt[i - 1]);
+		c_list_swap(thiz, &cnt[fill - 1]);
+        
+		__c_tsil(&cry);
+		for(fill = 0; fill < 64; ++ fill)
+			__c_tsil(&cnt[fill]);
+	}
+}
+
+c_bool c_list_equal(c_plist thiz, const c_plist L)
+{
+	c_iterator end1 = c_list_end(thiz);
+	c_iterator end2 = c_list_end(L);
+	c_iterator i1 = c_list_begin(thiz);
+	c_iterator i2 = c_list_begin(L);
+    
+	while(!ITER_EQUAL(i1, end1) &&
+		!ITER_EQUAL(i2, end2) &&
+		!(*thiz->_cmp)(ITER_REF(i1), ITER_REF(i2)))
+	{
+		ITER_INC(i1);
+		ITER_INC(i2);
+	}
+	return (ITER_EQUAL(i1, end1) && (ITER_EQUAL(i2, end2)));
+}
+
+c_bool c_list_less(c_plist thiz, const c_plist L)
+{
+	return c_lexicographical_compare(c_list_begin(thiz),
+						c_list_end(thiz),
+						c_list_begin(L),
+						c_list_end(L), thiz->_cmp);
+}
+
diff --git a/src/tstl2cl/c_map.c b/src/tstl2cl/c_map.c
new file mode 100644
index 0000000..9b9ab0d
--- /dev/null
+++ b/src/tstl2cl/c_map.c
@@ -0,0 +1,197 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#include "c_map.h"
+
+void __c_map(c_pmap thiz, COMPARER keycmp)
+{
+	c_prb_tree ptree = (c_prb_tree)__c_malloc(sizeof(c_rb_tree));
+	__c_rb_tree(ptree, keycmp);
+	ptree->_A_keyofvalue = c_select1st();
+	thiz->_l = ptree;
+}
+
+void __c_pam(c_pmap thiz)
+{
+	__c_eert_br((c_prb_tree)thiz->_l);
+	__c_free(thiz->_l);
+}
+
+c_pmap c_map_assign(c_pmap thiz, const c_pmap M)
+{
+	c_rb_tree_assign((c_prb_tree)thiz->_l, (c_prb_tree)M->_l);
+	return thiz;
+}
+
+c_iterator c_map_begin(c_pmap thiz)
+{
+	return c_rb_tree_begin((c_prb_tree)thiz->_l);
+}
+
+c_iterator c_map_end(c_pmap thiz)
+{
+	return c_rb_tree_end((c_prb_tree)thiz->_l);
+}
+
+c_reverse_iterator c_map_rbegin(c_pmap thiz)
+{
+	return c_rb_tree_rbegin((c_prb_tree)thiz->_l);
+}
+
+c_reverse_iterator c_map_rend(c_pmap thiz)
+{
+	return c_rb_tree_rend((c_prb_tree)thiz->_l);
+}
+
+c_bool c_map_empty(c_pmap thiz)
+{
+	return c_rb_tree_empty((c_prb_tree)thiz->_l);
+}
+
+size_type c_map_size(c_pmap thiz)
+{
+	return c_rb_tree_size((c_prb_tree)thiz->_l);
+}
+
+size_type c_map_max_size(c_pmap thiz)
+{
+	return c_rb_tree_max_size((c_prb_tree)thiz->_l);
+}
+
+value_type c_map_at(c_pmap thiz, key_type key)
+{
+	c_iterator iter = c_map_lower_bound(thiz, key);
+	c_iterator end = c_map_end(thiz);
+	if(ITER_EQUAL(iter, end) ||
+		((c_prb_tree)thiz->_l)->_A_key_compare(key, 
+						       ((c_ppair)ITER_REF(iter))->first) < 0)
+		return NULL;	/* difference between STL */
+	return ((c_ppair)ITER_REF(iter))->second;
+}
+
+void c_map_swap(c_pmap thiz, c_pmap M)
+{
+	c_rb_tree_swap((c_prb_tree)thiz->_l, (c_prb_tree)M->_l);
+}
+
+c_iter_bool_pair c_map_insert(c_pmap thiz, const value_type val)
+{
+	return c_rb_tree_insert_unique((c_prb_tree)thiz->_l, val);
+}
+
+c_iterator c_map_insert1(c_pmap thiz, c_iterator position, const value_type val)
+{
+	return c_rb_tree_insert_unique1((c_prb_tree)thiz->_l, position, val);
+}
+
+void c_map_insert2(c_pmap thiz, c_iterator first, c_iterator last)
+{
+	c_rb_tree_insert_unique2((c_prb_tree)thiz->_l, first, last);
+}
+
+void c_map_erase(c_pmap thiz, c_iterator position)
+{
+	c_rb_tree_erase((c_prb_tree)thiz->_l, position);
+}
+
+size_type c_map_erase1(c_pmap thiz, key_type key)
+{
+	return c_rb_tree_erase1((c_prb_tree)thiz->_l, key);
+}
+
+void c_map_erase2(c_pmap thiz, c_iterator first, c_iterator last)
+{
+	c_rb_tree_erase2((c_prb_tree)thiz->_l, first, last);
+}
+
+void c_map_clear(c_pmap thiz)
+{
+	c_rb_tree_clear((c_prb_tree)thiz->_l);
+}
+
+c_iterator c_map_find(c_pmap thiz, key_type key)
+{
+	return c_rb_tree_find((c_prb_tree)thiz->_l, key);
+}
+
+size_type c_map_count(c_pmap thiz, key_type key)
+{
+	c_iterator key_iter = c_rb_tree_find((c_prb_tree)thiz->_l, key);
+	c_iterator end = c_rb_tree_end((c_prb_tree)thiz->_l);
+	return ITER_EQUAL(key_iter, end) ? 0 : 1;
+}
+
+c_iterator c_map_lower_bound(c_pmap thiz, key_type key)
+{
+	return c_rb_tree_lower_bound((c_prb_tree)thiz->_l, key);
+}
+
+c_iterator c_map_upper_bound(c_pmap thiz, key_type key)
+{
+	return c_rb_tree_upper_bound((c_prb_tree)thiz->_l, key);
+}
+
+c_iter_iter_pair c_map_equal_range(c_pmap thiz, key_type key)
+{
+	return c_rb_tree_equal_range((c_prb_tree)thiz->_l, key);
+}
+
+c_bool c_map_less(c_pmap thiz, const c_pmap M, COMPARER paircmp)
+{
+	return c_rb_tree_less((c_prb_tree)thiz->_l, (c_prb_tree)M->_l, paircmp);
+}
+
+c_bool c_map_equal(c_pmap thiz, const c_pmap M, COMPARER paircmp)
+{
+	return c_rb_tree_equal((c_prb_tree)thiz->_l, (c_prb_tree)M->_l, paircmp);
+}
+
diff --git a/src/tstl2cl/c_memory.c b/src/tstl2cl/c_memory.c
new file mode 100644
index 0000000..d3329fd
--- /dev/null
+++ b/src/tstl2cl/c_memory.c
@@ -0,0 +1,69 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_memory.h"
+
+
+void * __c_malloc(size_t s)
+{
+	return (void *)(malloc(s));
+}
+
+void __c_free(void * p)
+{
+	free(p);
+}
+
+
+
+
+
diff --git a/src/tstl2cl/c_memory.h b/src/tstl2cl/c_memory.h
new file mode 100644
index 0000000..5d41f23
--- /dev/null
+++ b/src/tstl2cl/c_memory.h
@@ -0,0 +1,65 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+/* 
+NOTE: This is an internal header file, You should not attempt to use it directly.
+*/
+
+#ifndef _C_MEMORY_H
+#define _C_MEMORY_H
+
+#include "c_def.h"
+
+void * __c_malloc(size_t s);
+void __c_free(void * p);
+
+#endif /* _C_MEMORY_H */
diff --git a/src/tstl2cl/c_pair.c b/src/tstl2cl/c_pair.c
new file mode 100644
index 0000000..bf97577
--- /dev/null
+++ b/src/tstl2cl/c_pair.c
@@ -0,0 +1,78 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+ 
+#include "c_pair.h"
+
+
+c_pair c_make_pair(const value_type x, const value_type y)
+{
+	c_pair tmp;
+	tmp.first = x;
+	tmp.second = y;
+	return tmp;
+}
+
+c_iter_bool_pair c_make_iter_bool_pair(c_iterator x, c_bool y)
+{
+	c_iter_bool_pair tmp;
+	tmp.first = x;
+	tmp.second = y;
+	return tmp;
+}
+
+c_iter_iter_pair c_make_iter_iter_pair(c_iterator x, c_iterator y)
+{
+	c_iter_iter_pair tmp;
+	tmp.first = x;
+	tmp.second = y;
+	return tmp;
+}
diff --git a/src/tstl2cl/c_pair.h b/src/tstl2cl/c_pair.h
new file mode 100644
index 0000000..2658982
--- /dev/null
+++ b/src/tstl2cl/c_pair.h
@@ -0,0 +1,116 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+/* 
+NOTE: This is an internal header file, You should not attempt to use it directly.
+*/
+
+#ifndef _C_PAIR_H
+#define _C_PAIR_H
+
+#include "c_iterator.h"
+#include "c_memory.h"
+
+#define c_pair      		_c_pair
+#define c_ppair     		_c_ppair
+#define c_iter_bool_pair	_c_iter_bool_pair
+#define c_piter_bool_pair	_c_piter_bool_pair
+#define c_iter_iter_pair	_c_iter_iter_pair
+#define c_piter_iter_pair	_c_piter_iter_pair
+#define c_make_pair 		_c_make_pair
+#define c_make_iter_bool_pair	_c_make_iter_bool_pair
+#define c_make_iter_iter_pair	_c_make_iter_iter_pair
+
+typedef value_type first_type;
+typedef value_type second_type;
+
+typedef struct c_pair c_pair, * c_ppair;
+typedef int (*PAIR_COMPARER)(c_ppair, c_ppair);
+
+struct c_pair
+{    
+	first_type first;
+	second_type second;
+};
+
+
+typedef struct c_iter_bool_pair c_iter_bool_pair, c_piter_bool_pair;
+
+struct c_iter_bool_pair
+{
+	c_iterator first;
+	c_bool second;
+};
+
+
+typedef struct c_iter_iter_pair c_iter_iter_pair, c_piter_iter_pair;
+
+struct c_iter_iter_pair
+{
+	c_iterator first;
+	c_iterator second;
+};
+
+
+c_pair c_make_pair(const value_type x, const value_type y);
+c_iter_bool_pair c_make_iter_bool_pair(c_iterator x, c_bool y);
+c_iter_iter_pair c_make_iter_iter_pair(c_iterator x, c_iterator y);
+
+
+
+
+#endif /* _C_PAIR_H */
+
+
+
+
+
diff --git a/src/tstl2cl/c_queue.c b/src/tstl2cl/c_queue.c
new file mode 100644
index 0000000..1b864aa
--- /dev/null
+++ b/src/tstl2cl/c_queue.c
@@ -0,0 +1,114 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#include "c_queue.h"
+#include "c_memory.h"
+#include "c_list.h"
+
+
+void __c_queue(c_pqueue thiz, COMPARER pcmp)
+{
+	thiz->_l = __c_malloc(sizeof(c_list));
+	__c_list((c_plist)thiz->_l, pcmp);
+}
+
+void __c_eueuq(c_pqueue thiz)
+{
+	__c_tsil((c_plist)thiz->_l);
+	__c_free(thiz->_l);
+}
+
+c_pqueue c_queue_assign(c_pqueue thiz, const c_pqueue Q)
+{	
+	c_list_assign((c_plist)thiz->_l, (c_plist)Q->_l);
+	return thiz;
+}
+
+c_bool c_queue_empty(c_pqueue thiz)
+{
+	return c_list_empty((c_plist)thiz->_l);
+}
+
+size_type c_queue_size(c_pqueue thiz)
+{
+	return c_list_size((c_plist)thiz->_l);
+}
+
+value_type c_queue_front(c_pqueue thiz)
+{
+	return c_list_front((c_plist)thiz->_l);
+}
+
+value_type c_queue_back(c_pqueue thiz)
+{
+	return c_list_back((c_plist)thiz->_l);
+}
+
+void c_queue_push(c_pqueue thiz, const value_type val)
+{
+	c_list_push_back((c_plist)thiz->_l, val);
+}
+
+void c_queue_pop(c_pqueue thiz)
+{
+	c_list_pop_front((c_plist)thiz->_l);
+}
+
+c_bool c_queue_equal(c_pqueue thiz, const c_pqueue Q)
+{
+	return c_list_equal((c_plist)thiz->_l, (c_plist)Q->_l);
+}
+
+c_bool c_queue_less(c_pqueue thiz, const c_pqueue Q)
+{
+	return c_list_less((c_plist)thiz->_l, (c_plist)Q->_l);
+}
diff --git a/src/tstl2cl/c_set.c b/src/tstl2cl/c_set.c
new file mode 100644
index 0000000..aea58b1
--- /dev/null
+++ b/src/tstl2cl/c_set.c
@@ -0,0 +1,191 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#include "c_set.h"
+
+
+void __c_set(c_pset thiz, COMPARER pcmp)
+{
+	c_prb_tree ptree = (c_prb_tree)__c_malloc(sizeof(c_rb_tree));
+	__c_rb_tree(ptree, pcmp);
+	ptree->_A_keyofvalue = c_identity();
+	thiz->_l = ptree;	
+}
+
+void __c_tes(c_pset thiz)
+{
+	__c_eert_br((c_prb_tree)thiz->_l);
+	__c_free(thiz->_l);
+}
+
+c_pset c_set_assign(c_pset thiz, const c_pset S)
+{
+	c_rb_tree_assign((c_prb_tree)thiz->_l, (c_prb_tree)S->_l);
+	return thiz;
+}
+
+c_iterator c_set_begin(c_pset thiz)
+{
+	return c_rb_tree_begin((c_prb_tree)thiz->_l);
+}
+
+c_iterator c_set_end(c_pset thiz)
+{
+	return c_rb_tree_end((c_prb_tree)thiz->_l);
+}
+
+c_reverse_iterator c_set_rbegin(c_pset thiz)
+{
+	return c_rb_tree_rbegin((c_prb_tree)thiz->_l);
+}
+
+c_reverse_iterator c_set_rend(c_pset thiz)
+{
+	return c_rb_tree_rend((c_prb_tree)thiz->_l);
+}
+
+c_bool c_set_empty(c_pset thiz)
+{
+	return c_rb_tree_empty((c_prb_tree)thiz->_l);
+}
+
+size_type c_set_size(c_pset thiz)
+{
+	return c_rb_tree_size((c_prb_tree)thiz->_l);
+}
+
+size_type c_set_max_size(c_pset thiz)
+{
+	return c_rb_tree_max_size((c_prb_tree)thiz->_l);
+}
+
+void c_set_swap(c_pset thiz, c_pset S)
+{
+	c_rb_tree_swap((c_prb_tree)thiz->_l, (c_prb_tree)S->_l);
+}
+
+c_iter_bool_pair c_set_insert(c_pset thiz, const value_type val)
+{
+	return c_rb_tree_insert_unique((c_prb_tree)thiz->_l, val);
+}
+
+c_iterator c_set_insert1(c_pset thiz, c_iterator position, const value_type val)
+{
+	return c_rb_tree_insert_unique1((c_prb_tree)thiz->_l, position, val);
+}
+
+void c_set_insert2(c_pset thiz, c_iterator first, c_iterator last)
+{
+	c_rb_tree_insert_unique2((c_prb_tree)thiz->_l, first, last);
+}
+
+void c_set_erase(c_pset thiz, c_iterator position)
+{
+	c_rb_tree_erase((c_prb_tree)thiz->_l, position);
+}
+
+size_type c_set_erase1(c_pset thiz, key_type key)
+{
+	return c_rb_tree_erase1((c_prb_tree)thiz->_l, key);
+}
+
+void c_set_erase2(c_pset thiz, c_iterator first, c_iterator last)
+{
+	c_rb_tree_erase2((c_prb_tree)thiz->_l, first, last);
+}
+
+void c_set_clear(c_pset thiz)
+{
+	c_rb_tree_clear((c_prb_tree)thiz->_l);
+}
+
+c_iterator c_set_find(c_pset thiz, key_type key)
+{
+	return c_rb_tree_find((c_prb_tree)thiz->_l, key);
+}
+
+size_type c_set_count(c_pset thiz, key_type key)
+{
+	c_iterator key_iter = c_rb_tree_find((c_prb_tree)thiz->_l, key);
+	c_iterator end = c_rb_tree_end((c_prb_tree)thiz->_l);
+	return ITER_EQUAL(key_iter, end) ? 0 : 1;
+}
+
+c_iterator c_set_lower_bound(c_pset thiz, key_type key)
+{
+	return c_rb_tree_lower_bound((c_prb_tree)thiz->_l, key);
+}
+
+c_iterator c_set_upper_bound(c_pset thiz, key_type key)
+{
+	return c_rb_tree_upper_bound((c_prb_tree)thiz->_l, key);
+}
+
+c_iter_iter_pair c_set_equal_range(c_pset thiz, key_type key)
+{
+	return c_rb_tree_equal_range((c_prb_tree)thiz->_l, key);
+}
+
+c_bool c_set_less(c_pset thiz, const c_pset S)
+{
+	return c_rb_tree_less((c_prb_tree)thiz->_l, 
+				(c_prb_tree)S->_l,
+		       		((c_prb_tree)S->_l)->_A_key_compare);
+}
+
+c_bool c_set_equal(c_pset thiz, const c_pset S)
+{
+	return c_rb_tree_equal((c_prb_tree)thiz->_l, 
+				(c_prb_tree)S->_l,
+		       		((c_prb_tree)S->_l)->_A_key_compare);
+}
+
diff --git a/src/tstl2cl/c_stack.c b/src/tstl2cl/c_stack.c
new file mode 100644
index 0000000..9ad11b9
--- /dev/null
+++ b/src/tstl2cl/c_stack.c
@@ -0,0 +1,109 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#include "c_stack.h"
+#include "c_vector.h"
+#include "c_memory.h"
+
+
+void __c_stack(c_pstack thiz, COMPARER pcmp)
+{
+	thiz->_l = __c_malloc(sizeof(c_vector));
+	__c_vector((c_pvector)thiz->_l, pcmp);
+}
+
+void __c_kcats(c_pstack thiz)
+{
+	__c_rotcev((c_pvector)thiz->_l);
+	__c_free((c_pvector)thiz->_l);
+}
+
+c_pstack c_stack_assign(c_pstack thiz, const c_pstack S)
+{
+	c_vector_assign((c_pvector)thiz->_l, (c_pvector)S->_l);
+	return thiz;
+}
+
+c_bool c_stack_empty(c_pstack thiz)
+{
+	return c_vector_empty((c_pvector)thiz->_l);
+}
+
+size_type c_stack_size(c_pstack thiz)
+{
+	return c_vector_size((c_pvector)thiz->_l);
+}
+
+value_type c_stack_top(c_pstack thiz)
+{
+	return c_vector_back((c_pvector)thiz->_l);
+}
+
+void c_stack_push(c_pstack thiz, const value_type val)
+{
+	c_vector_push_back((c_pvector)thiz->_l, val);
+}
+
+void c_stack_pop(c_pstack thiz)
+{
+	c_vector_pop_back((c_pvector)thiz->_l);		
+}
+
+c_bool c_stack_equal(c_pstack thiz, const c_pstack S)
+{
+	return c_vector_equal((c_pvector)thiz->_l, (c_pvector)S->_l);
+}
+
+c_bool c_stack_less(c_pstack thiz, const c_pstack S)
+{
+	return c_vector_less((c_pvector)thiz->_l, (c_pvector)S->_l);
+}
diff --git a/src/tstl2cl/c_tree.c b/src/tstl2cl/c_tree.c
new file mode 100644
index 0000000..609d8b2
--- /dev/null
+++ b/src/tstl2cl/c_tree.c
@@ -0,0 +1,1077 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#include "c_tree.h"
+#include "c_algo.h"
+
+static const _c_rb_tree_color_type _S_c_rb_tree_red = false;
+static const _c_rb_tree_color_type _S_c_rb_tree_black = true;
+
+static _base_ptr _S_minimum(_base_ptr val)
+{
+    while(val->_A_left)
+        val = val->_A_left;
+    return val;
+}
+
+static _base_ptr _S_maximum(_base_ptr val)
+{
+    while(val->_A_right)
+        val = val->_A_right;
+    return val;
+}
+
+static void _A_iterator_increment(c_piterator thiz)
+{
+    if(((_base_ptr)(thiz->_i))->_A_right)
+    {
+        thiz->_i = ((_base_ptr)(thiz->_i))->_A_right;
+        while(((_base_ptr)(thiz->_i))->_A_left)
+            thiz->_i = ((_base_ptr)(thiz->_i))->_A_left;
+    }
+    else
+    {
+        _base_ptr val = ((_base_ptr)(thiz->_i))->_A_parent;
+        while(((_base_ptr)(thiz->_i)) == val->_A_right)
+        {
+            thiz->_i = val;
+            val = val->_A_parent;
+        }
+        if(((_base_ptr)(thiz->_i))->_A_right != val)
+            thiz->_i = val;
+    }    
+}
+
+static void _A_iterator_decrement(c_piterator thiz)
+{
+    if((((_base_ptr)(thiz->_i))->_A_color == _S_c_rb_tree_red) &&
+       ((_base_ptr)(thiz->_i))->_A_parent->_A_parent == ((_base_ptr)(thiz->_i)))
+        thiz->_i = ((_base_ptr)(thiz->_i))->_A_right;
+    else if(((_base_ptr)(thiz->_i))->_A_left)
+    {
+        _base_ptr val = ((_base_ptr)(thiz->_i))->_A_left;
+        while(val->_A_right)
+            val = val->_A_right;
+        thiz->_i = val;
+    }
+    else
+    {
+        _base_ptr val = ((_base_ptr)(thiz->_i))->_A_parent;
+        while(((_base_ptr)(thiz->_i)) == val->_A_left)
+        {
+            thiz->_i = val;
+            val = val->_A_parent;
+        }
+        thiz->_i = val;
+    }
+}
+
+static void _A_reverse_iterator_increment(c_preverse_iterator thiz)
+{
+	c_iterator iter;
+	iter._i = thiz->_i;
+	_A_iterator_decrement(&iter);
+	thiz->_i = iter._i;
+}
+
+static void _A_reverse_iterator_decrement(c_preverse_iterator thiz)
+{
+	c_iterator iter;
+	iter._i = thiz->_i;
+	_A_iterator_increment(&iter);
+	thiz->_i = iter._i;
+}
+
+static c_iterator _c_rb_tree_iterator_assign(c_piterator thiz, const c_piterator val)
+{
+    if(thiz != val)
+        thiz->_i = val->_i;
+    return *thiz;
+}
+
+static value_type _c_rb_tree_iterator_ref(c_piterator thiz)
+{
+    return ((_base_ptr)(thiz->_i))->_A_value_field;
+}
+
+static value_type _c_rb_tree_iterator_ref_assign(c_piterator thiz, const value_type val)
+{
+    return ((_base_ptr)(thiz->_i))->_A_value_field = val;
+}
+
+static c_iterator _c_rb_tree_iterator_inc(c_piterator thiz)
+{
+    _A_iterator_increment(thiz);
+    return *thiz;    
+}
+
+static c_iterator _c_rb_tree_iterator_dec(c_piterator thiz)
+{
+    _A_iterator_decrement(thiz);
+    return *thiz;
+}
+
+static c_bool _c_rb_tree_iterator_equal(c_piterator thiz, const c_piterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_iterator_ft _c_rb_tree_iter_ft =
+{
+    _c_rb_tree_iterator_assign,
+    _c_rb_tree_iterator_ref,
+    _c_rb_tree_iterator_ref_assign,
+    _c_rb_tree_iterator_inc,
+    NULL, /* _c_rb_tree_iterator_inc_n */
+    _c_rb_tree_iterator_dec,
+    NULL, /* _c_rb_tree_iterator_dec_n */
+    NULL, /* _c_rb_tree_iterator_diff */
+    NULL, /* _c_rb_tree_iterator_at */
+    NULL, /* _c_rb_tree_iterator_positive_n */
+    NULL, /* _c_rb_tree_iterator_negative_n */
+    _c_rb_tree_iterator_equal,
+    NULL /* _c_rb_tree_iterator_less */
+};
+
+static c_iterator _A_get_iterator(_base_ptr val)
+{
+	c_iterator iter;
+	iter._pft = &_c_rb_tree_iter_ft;
+	iter._i = val;
+	return iter;
+}
+
+static c_reverse_iterator _c_rb_tree_reverse_iterator_assign(c_preverse_iterator thiz, 
+								const c_preverse_iterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_rb_tree_reverse_iterator_ref(c_preverse_iterator thiz)
+{
+	c_iterator iter = _A_get_iterator(thiz->_i);
+	_A_iterator_decrement(&iter);
+	return ((_base_ptr)(iter._i))->_A_value_field;
+}
+
+static value_type _c_rb_tree_reverse_iterator_ref_assign(c_preverse_iterator thiz, const value_type val)
+{
+	c_iterator iter = _A_get_iterator(thiz->_i);
+	_A_iterator_decrement(&iter);
+	return ((_base_ptr)(iter._i))->_A_value_field = val;	
+}
+
+static c_reverse_iterator _c_rb_tree_reverse_iterator_inc(c_preverse_iterator thiz)
+{
+	_A_reverse_iterator_increment(thiz);
+	return *thiz;
+}
+
+static c_reverse_iterator _c_rb_tree_reverse_iterator_dec(c_preverse_iterator thiz)
+{
+	_A_reverse_iterator_decrement(thiz);
+	return *thiz;
+}
+
+static c_bool _c_rb_tree_reverse_iterator_equal(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_reverse_iterator_ft _c_rb_tree_reverse_iter_ft = 
+{
+    _c_rb_tree_reverse_iterator_assign,
+    _c_rb_tree_reverse_iterator_ref,
+    _c_rb_tree_reverse_iterator_ref_assign,
+    _c_rb_tree_reverse_iterator_inc,
+    NULL, /* _c_rb_tree_reverse_iterator_inc_n */
+    _c_rb_tree_reverse_iterator_dec,
+    NULL, /* _c_rb_tree_reverse_iterator_dec_n */
+    NULL, /* _c_rb_tree_reverse_iterator_diff */
+    NULL, /* _c_rb_tree_reverse_iterator_at */
+    NULL, /* _c_rb_tree_reverse_iterator_positive_n */
+    NULL, /* _c_rb_tree_reverse_iterator_negative_n */
+    _c_rb_tree_reverse_iterator_equal,
+    NULL, /* _c_rb_tree_reverse_iterator_less */
+};
+
+static c_reverse_iterator _A_get_reverse_iterator(_base_ptr val)
+{
+	c_reverse_iterator iter;
+	iter._pft = &_c_rb_tree_reverse_iter_ft;
+	iter._i = val;
+	return iter;
+}
+
+static void _c_rb_tree_rotate_left(_base_ptr val, _base_ptr * proot)
+{
+	_base_ptr wal = val->_A_right;
+	val->_A_right = wal->_A_left;
+	if(wal->_A_left != NULL)
+		wal->_A_left->_A_parent = val;
+	wal->_A_parent = val->_A_parent;
+
+	if(val == *proot)
+		*proot = wal;
+	else if(val == val->_A_parent->_A_left)
+		val->_A_parent->_A_left = wal;
+	else
+		val->_A_parent->_A_right = wal;
+	wal->_A_left = val;
+	val->_A_parent = wal;
+}
+
+static void _c_rb_tree_rotate_right(_base_ptr val, _base_ptr * proot)
+{
+	_base_ptr wal = val->_A_left;
+	val->_A_left = wal->_A_right;
+	if(wal->_A_right != NULL)
+		wal->_A_right->_A_parent = val;
+	wal->_A_parent = val->_A_parent;
+
+	if(val == *proot)
+		*proot = wal;
+	else if(val == val->_A_parent->_A_right)
+		val->_A_parent->_A_right = wal;
+	else
+		val->_A_parent->_A_left = wal;
+	wal->_A_right = val;
+	val->_A_parent = wal;
+}
+
+void _c_rb_tree_rebalance(_base_ptr val, _base_ptr * proot)
+{
+	val->_A_color = _S_c_rb_tree_red;
+	while(val != *proot && val->_A_parent->_A_color == _S_c_rb_tree_red)
+	{
+		if(val->_A_parent == val->_A_parent->_A_parent->_A_left)
+		{
+			_base_ptr wal = val->_A_parent->_A_parent->_A_right;
+			if(wal && wal->_A_color == _S_c_rb_tree_red)
+			{
+				val->_A_parent->_A_color = _S_c_rb_tree_black;
+				wal->_A_color = _S_c_rb_tree_black;
+				val->_A_parent->_A_parent->_A_color = _S_c_rb_tree_red;
+				val = val->_A_parent->_A_parent;
+			}
+			else
+			{
+				if(val == val->_A_parent->_A_right)
+				{
+					val = val->_A_parent;
+					_c_rb_tree_rotate_left(val, proot);
+				}
+				val->_A_parent->_A_color = _S_c_rb_tree_black;
+				val->_A_parent->_A_parent->_A_color = _S_c_rb_tree_red;
+				_c_rb_tree_rotate_right(val->_A_parent->_A_parent, proot);
+			}
+		}
+		else
+		{
+			_base_ptr wal = val->_A_parent->_A_parent->_A_left;
+			if(wal && wal->_A_color == _S_c_rb_tree_red)
+			{
+				val->_A_parent->_A_color = _S_c_rb_tree_black;
+				wal->_A_color = _S_c_rb_tree_black;
+				val->_A_parent->_A_parent->_A_color = _S_c_rb_tree_red;
+				val = val->_A_parent->_A_parent;
+			}
+			else
+			{
+				if(val == val->_A_parent->_A_left)
+				{
+					val = val->_A_parent;
+					_c_rb_tree_rotate_right(val, proot);
+				}
+				val->_A_parent->_A_color = _S_c_rb_tree_black;
+				val->_A_parent->_A_parent->_A_color = _S_c_rb_tree_red;
+				_c_rb_tree_rotate_left(val->_A_parent->_A_parent, proot);
+			}
+		}
+	}
+	(*proot)->_A_color = _S_c_rb_tree_black;	
+}
+
+static _base_ptr _c_rb_tree_rebalance_for_erase(_base_ptr z,
+						     _base_ptr * root,
+						     _base_ptr * leftmost,
+						     _base_ptr * rightmost)
+{
+	_base_ptr y = z;
+	_base_ptr x = NULL;
+	_base_ptr x_parent = NULL;
+	
+	if(y->_A_left == NULL)
+		x = y->_A_right;
+	else
+		if(y->_A_right == NULL)
+			x = y->_A_left;
+		else
+		{
+			y = y->_A_right;
+			while(y->_A_left != NULL)
+				y = y->_A_left;
+			x = y->_A_right;
+		}
+
+	if(y != z)
+	{
+		_c_rb_tree_color_type tmp;
+		z->_A_left->_A_parent = y;
+		y->_A_left = z->_A_left;
+		if(y != z->_A_right)
+		{
+			x_parent = y->_A_parent;
+			if(x)
+				x->_A_parent = y->_A_parent;
+			y->_A_parent->_A_left = x;
+			y->_A_right = z->_A_right;
+			z->_A_right->_A_parent = y;
+		}
+		else
+			x_parent = y;
+		if(*root == z)
+			*root = y;
+		else if(z->_A_parent->_A_left == z)
+			z->_A_parent->_A_left = y;
+		else
+			z->_A_parent->_A_right = y;
+		y->_A_parent = z->_A_parent;
+		C_SWAP(y->_A_color, z->_A_color, tmp);
+		y = z;
+	}
+	else
+	{
+		x_parent = y->_A_parent;
+		if(x)
+			x->_A_parent = y->_A_parent;
+		if(*root == z)
+			*root = x;
+		else
+		{
+			if(z->_A_parent->_A_left == z)
+				z->_A_parent->_A_left = x;
+			else
+				z->_A_parent->_A_right = x;
+		}
+		if(*leftmost == z)
+		{
+			if(z->_A_right == NULL)
+				*leftmost = z->_A_parent;
+			else
+				*leftmost = _S_minimum(x);
+		}
+		if(*rightmost == z)
+		{
+			if(z->_A_left == NULL)
+				*rightmost = z->_A_parent;
+			else
+				*rightmost = _S_maximum(x);
+		}
+	}
+	if(y->_A_color != _S_c_rb_tree_red)
+	{
+		while(x != *root && 
+			(x == NULL || 
+			 x->_A_color == _S_c_rb_tree_black))
+			if(x == x_parent->_A_left)
+			{
+				_base_ptr w = x_parent->_A_right;
+				if(w->_A_color == _S_c_rb_tree_red)
+				{
+					w->_A_color = _S_c_rb_tree_black;
+					x_parent->_A_color = _S_c_rb_tree_red;
+					_c_rb_tree_rotate_left(x_parent, root);
+					w = x_parent->_A_right;
+				}
+				if((w->_A_left == NULL ||
+				    w->_A_left->_A_color == _S_c_rb_tree_black) &&
+				   (w->_A_right == NULL ||
+				    w->_A_right->_A_color == _S_c_rb_tree_black))
+				{
+					w->_A_color = _S_c_rb_tree_red;
+					x = x_parent;
+					x_parent = x_parent->_A_parent;
+				}
+				else
+				{
+					if(w->_A_right == NULL ||
+					   w->_A_right->_A_color == _S_c_rb_tree_black)
+					{
+						if(w->_A_left)
+							w->_A_left->_A_color = _S_c_rb_tree_black;
+						w->_A_color = _S_c_rb_tree_red;
+						_c_rb_tree_rotate_right(w, root);
+						w = x_parent->_A_right;
+					}
+					w->_A_color = x_parent->_A_color;
+					x_parent->_A_color = _S_c_rb_tree_black;
+					if(w->_A_right)
+						w->_A_right->_A_color = _S_c_rb_tree_black;
+					_c_rb_tree_rotate_left(x_parent, root);
+					break;
+				}
+			}
+			else
+			{
+				_base_ptr w = x_parent->_A_left;
+				if(w->_A_color == _S_c_rb_tree_red)
+				{
+					w->_A_color = _S_c_rb_tree_black;
+					x_parent->_A_color = _S_c_rb_tree_red;
+					_c_rb_tree_rotate_right(x_parent, root);
+					w = x_parent->_A_left;
+				}
+				if((w->_A_right == NULL ||
+				    w->_A_right->_A_color == _S_c_rb_tree_black) &&
+				   (w->_A_left == NULL ||
+				    w->_A_left->_A_color == _S_c_rb_tree_black))
+				{
+					w->_A_color = _S_c_rb_tree_red;
+					x = x_parent;
+					x_parent = x_parent->_A_parent;
+				}
+				else
+				{
+					if(w->_A_left == NULL ||
+						w->_A_left->_A_color == _S_c_rb_tree_black)
+					{
+						if(w->_A_right)
+							w->_A_right->_A_color = _S_c_rb_tree_black;
+						w->_A_color = _S_c_rb_tree_red;
+						_c_rb_tree_rotate_left(w, root);
+						w = x_parent->_A_left;
+					}
+					w->_A_color = x_parent->_A_color;
+					x_parent->_A_color = _S_c_rb_tree_black;
+					if(w->_A_left)
+						w->_A_left->_A_color = _S_c_rb_tree_black;
+					_c_rb_tree_rotate_right(x_parent, root);
+					break;
+				}
+			}
+		if(x)
+			x->_A_color = _S_c_rb_tree_black;
+	}
+	return y;
+}
+
+static _base_ptr _A_get_node()
+{
+	_base_ptr tmp = __c_malloc(sizeof(_c_rb_tree_node));
+	tmp->_A_color = 0;
+	tmp->_A_parent = 0;
+	tmp->_A_left = 0;
+	tmp->_A_right = 0;
+	tmp->_A_value_field = 0;
+	return tmp;
+}
+
+static void _A_put_node(_base_ptr val)
+{
+	__c_free(val);
+}
+
+static _base_ptr _A_create_node(const value_type val)
+{
+	_base_ptr tmp = _A_get_node();
+	tmp->_A_value_field = val;
+	return tmp;	
+}
+
+static _base_ptr _A_clone_node(_base_ptr val)
+{
+	_base_ptr tmp = _A_create_node(val->_A_value_field);
+	tmp->_A_color = val->_A_color;
+	tmp->_A_left = NULL;
+	tmp->_A_right = NULL;
+	return tmp;
+}
+
+static void _A_destroy_node(_base_ptr val)
+{
+	_A_put_node(val);
+}
+
+static _base_ptr * _A_root(c_prb_tree thiz)
+{
+	return &thiz->_A_header->_A_parent;
+}
+
+static _base_ptr * _A_leftmost(c_prb_tree thiz)
+{
+	return &thiz->_A_header->_A_left;
+}
+
+static _base_ptr * _A_rightmost(c_prb_tree thiz)
+{
+	return &thiz->_A_header->_A_right;
+}
+
+static _base_ptr * _S_left(_base_ptr val)
+{
+	return &val->_A_left;
+}
+
+static _base_ptr * _S_right(_base_ptr val)
+{
+	return &val->_A_right;
+}
+
+static _base_ptr * _S_parent(_base_ptr val)
+{
+	return &val->_A_parent;
+}
+
+static value_type * _S_value(_base_ptr val)
+{
+	return &val->_A_value_field;
+}
+
+static key_type _S_key(c_prb_tree thiz, _base_ptr val)
+{
+	return thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, *_S_value(val));
+}
+
+static _color_type * _S_color(_base_ptr val)
+{
+	return &val->_A_color;
+}
+
+static c_iterator _A_insert(c_prb_tree thiz, _base_ptr x, _base_ptr y, const value_type val)
+{
+	_base_ptr _x = x;
+	_base_ptr _y = y;
+	_base_ptr _z = NULL;
+	if(_y == thiz->_A_header || 
+		_x != NULL ||
+		thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val),
+		       			_S_key(thiz, _y)) < 0)
+	{
+		_z = _A_create_node(val);
+		*_S_left(_y) = _z;
+
+		if(_y == thiz->_A_header)
+		{
+			*_A_root(thiz) = _z;
+			*_A_rightmost(thiz) = _z;
+				
+		}
+		else if(_y == *_A_leftmost(thiz))
+			*_A_leftmost(thiz) = _z;		
+	}
+	else
+	{
+		_z = _A_create_node(val);
+		*_S_right(_y) = _z;
+		if(_y == *_A_rightmost(thiz))
+			*_A_rightmost(thiz) = _z;
+	}
+
+	*_S_parent(_z) = _y;
+	*_S_left(_z) = NULL;
+	*_S_right(_z) = NULL;
+	_c_rb_tree_rebalance(_z, &thiz->_A_header->_A_parent);
+	++ thiz->_A_node_count;
+	return _A_get_iterator(_z);
+}
+
+static _base_ptr _A_copy(_base_ptr x, _base_ptr p)
+{
+	_base_ptr top = _A_clone_node(x);
+	top->_A_parent = p;
+
+	if(x->_A_right)
+		top->_A_right = _A_copy(*_S_right(x), top);
+	p = top;
+	x = *_S_left(x);
+
+	while(x != NULL)
+	{
+		_base_ptr y = _A_clone_node(x);
+		p->_A_left = y;
+		y->_A_parent = p;
+		if(x->_A_right)
+			y->_A_right = _A_copy(*_S_right(x), y);
+		p = y;
+		x = *_S_left(x);
+	}
+
+	return top;
+}
+
+static void _A_erase(_base_ptr x)
+{
+	while(x != NULL)
+	{
+		_base_ptr y;
+		_A_erase(*_S_right(x));
+		y = *_S_left(x);
+		_A_destroy_node(x);
+		x = y;
+	}
+}
+
+static void _A_empty_initialize(c_prb_tree thiz)
+{
+	*_S_color(thiz->_A_header) = _S_c_rb_tree_red;
+	*_A_root(thiz) = NULL;
+	*_A_leftmost(thiz) = thiz->_A_header;
+	*_A_rightmost(thiz) = thiz->_A_header;	
+}
+
+void __c_rb_tree(c_prb_tree thiz, COMPARER pcmp)
+{
+	thiz->_A_header = _A_get_node();
+	thiz->_A_node_count = 0;
+	thiz->_A_key_compare = pcmp; 
+	_A_empty_initialize(thiz);
+}
+
+void __c_eert_br(c_prb_tree thiz)
+{
+	c_rb_tree_clear(thiz);
+	_A_put_node(thiz->_A_header);
+}
+
+c_prb_tree c_rb_tree_assign(c_prb_tree thiz, const c_prb_tree T)
+{
+	if(thiz != T)
+	{
+		c_rb_tree_clear(thiz);
+		thiz->_A_node_count = 0;
+		thiz->_A_key_compare = T->_A_key_compare;
+		if(*_A_root(T) == NULL)
+		{
+			*_A_root(thiz) = NULL;
+			*_A_leftmost(thiz) = thiz->_A_header;
+			*_A_rightmost(thiz) = thiz->_A_header;			
+		}
+		else
+		{
+			*_A_root(thiz) = _A_copy(*_A_root(T), thiz->_A_header);
+			*_A_leftmost(thiz) = _S_minimum(*_A_root(thiz));
+			*_A_rightmost(thiz) = _S_maximum(*_A_root(thiz));
+			thiz->_A_node_count = T->_A_node_count;
+		}
+	}
+	return thiz;
+}
+
+c_iterator c_rb_tree_begin(c_prb_tree thiz)
+{
+	return _A_get_iterator(*_A_leftmost(thiz));
+}
+
+c_iterator c_rb_tree_end(c_prb_tree thiz)
+{
+	return _A_get_iterator(thiz->_A_header);
+}
+
+c_reverse_iterator c_rb_tree_rbegin(c_prb_tree thiz)
+{
+	return _A_get_reverse_iterator(thiz->_A_header);
+}
+
+c_reverse_iterator c_rb_tree_rend(c_prb_tree thiz)
+{
+	return _A_get_reverse_iterator(*_A_leftmost(thiz));
+}
+
+c_bool c_rb_tree_empty(c_prb_tree thiz)
+{
+	return thiz->_A_node_count == 0;
+}
+
+size_type c_rb_tree_size(c_prb_tree thiz)
+{
+	return thiz->_A_node_count;
+}
+
+size_type c_rb_tree_max_size(c_prb_tree thiz)
+{
+	return (size_type)(-1);
+}
+
+void c_rb_tree_swap(c_prb_tree thiz, c_prb_tree T)
+{
+	c_rb_tree tmp;
+	C_SWAP(*thiz, *T, tmp);
+}
+
+c_iter_bool_pair c_rb_tree_insert_unique(c_prb_tree thiz, const value_type val)
+{
+	_base_ptr y = thiz->_A_header;
+	_base_ptr x = *_A_root(thiz);
+	c_bool comp = 1;
+	c_iterator j;
+
+	while(x != NULL)
+	{
+		y = x;
+		comp = thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val), 
+									_S_key(thiz, x)) < 0;
+		x = comp ? *_S_left(x) : *_S_right(x);		
+	}
+	j = _A_get_iterator(y);
+	if(comp)
+	{
+		c_iterator beg = c_rb_tree_begin(thiz);
+		if(ITER_EQUAL(j, beg))
+			return c_make_iter_bool_pair(_A_insert(thiz, x, y, val), true);
+		else
+			ITER_DEC(j);
+	}
+	if(thiz->_A_key_compare(_S_key(thiz, j._i), 
+				thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val)) < 0)
+		return c_make_iter_bool_pair(_A_insert(thiz, x, y, val), true);
+	return c_make_iter_bool_pair(j, false);
+}
+
+c_iterator c_rb_tree_insert_equal(c_prb_tree thiz, const value_type val)
+{
+	_base_ptr y = thiz->_A_header;
+	_base_ptr x = *_A_root(thiz);
+	while(x != NULL)
+	{
+		y = x;
+		x = thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val),
+					_S_key(thiz, x)) < 0 ?
+			*_S_left(x) : *_S_right(x);
+	}
+	return _A_insert(thiz, x, y, val);
+}
+
+c_iterator c_rb_tree_insert_unique1(c_prb_tree thiz, c_iterator position, const value_type val)
+{
+	if(position._i == thiz->_A_header->_A_left)
+	{
+		if(c_rb_tree_size(thiz) > 0 &&
+			thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val), 
+						_S_key(thiz, position._i)) < 0)
+			return _A_insert(thiz, position._i, position._i, val);
+		else
+			return c_rb_tree_insert_unique(thiz, val).first;
+	}
+	else if(position._i == thiz->_A_header)
+	{
+		if(thiz->_A_key_compare(_S_key(thiz, *_A_rightmost(thiz)), 
+					thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue,
+								val)) < 0)
+			return _A_insert(thiz, 0, *_A_rightmost(thiz), val);
+		else
+			return c_rb_tree_insert_unique(thiz, val).first;
+	}
+	else
+	{
+		c_iterator before = position;
+		ITER_DEC(before);
+		if(thiz->_A_key_compare(_S_key(thiz, before._i), 
+					thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, 
+								val)) < 0 &&
+			thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue,
+									val),
+						_S_key(thiz, position._i)) < 0)
+			if(*_S_right(before._i) == NULL)
+				return _A_insert(thiz, 0, before._i, val);
+			else
+				return _A_insert(thiz, position._i, position._i, val);
+		else
+			return c_rb_tree_insert_unique(thiz, val).first;
+	}
+}
+
+c_iterator c_rb_tree_insert_equal1(c_prb_tree thiz, c_iterator position, const value_type val)
+{
+	if(position._i == thiz->_A_header->_A_left)
+	{
+		if(c_rb_tree_size(thiz) > 0 &&
+			thiz->_A_key_compare(_S_key(thiz, position._i), 
+						thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, 
+									val)) >= 0)
+			return _A_insert(thiz, position._i, position._i, val);	
+		else
+			return c_rb_tree_insert_equal(thiz, val);
+	}
+	else if(position._i == thiz->_A_header)
+	{
+		if(thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, val),
+					_S_key(thiz, *_A_rightmost(thiz)))  >= 0)
+			return _A_insert(thiz, 0, *_A_rightmost(thiz), val);
+		else
+			return c_rb_tree_insert_equal(thiz, val);
+	}
+	else
+	{
+		c_iterator before = position;
+		ITER_DEC(before);
+		if(thiz->_A_key_compare(thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue, 
+						    	val),
+			      	_S_key(thiz, before._i)) >= 0 &&
+			thiz->_A_key_compare(_S_key(thiz, position._i), 
+						thiz->_A_keyofvalue.O(&thiz->_A_keyofvalue,
+									val)) >= 0)
+		{
+			if(*_S_right(before._i) == NULL)	
+				return _A_insert(thiz, 0, before._i, val);
+			else
+				return _A_insert(thiz, position._i, position._i, val);
+		}
+		else
+			return c_rb_tree_insert_equal(thiz, val);
+
+	}
+}
+
+void c_rb_tree_insert_unique2(c_prb_tree thiz, c_iterator first, c_iterator last)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		c_rb_tree_insert_unique(thiz, ITER_REF(first));
+}
+
+void c_rb_tree_insert_equal2(c_prb_tree thiz, c_iterator first, c_iterator last)
+{
+	for(; !ITER_EQUAL(first, last); ITER_INC(first))
+		c_rb_tree_insert_equal(thiz, ITER_REF(first));
+}
+
+void c_rb_tree_erase(c_prb_tree thiz, c_iterator position)
+{
+	_base_ptr y = _c_rb_tree_rebalance_for_erase(position._i,
+		       					&thiz->_A_header->_A_parent,
+							&thiz->_A_header->_A_left,
+							&thiz->_A_header->_A_right);
+	_A_destroy_node(y);
+	-- thiz->_A_node_count;
+}
+
+size_type c_rb_tree_erase1(c_prb_tree thiz, key_type key)
+{
+	c_iter_iter_pair p = c_rb_tree_equal_range(thiz, key);
+	difference_type n = 0;
+	c_distance1(p.first, p.second, &n);
+	c_rb_tree_erase2(thiz, p.first, p.second);
+	return n;
+}
+
+void c_rb_tree_erase2(c_prb_tree thiz, c_iterator first, c_iterator last)
+{
+	c_iterator begin, end;
+	begin = c_rb_tree_begin(thiz);
+	end = c_rb_tree_end(thiz);
+	if(ITER_EQUAL(first, begin) && 
+		ITER_EQUAL(last, end))
+		c_rb_tree_clear(thiz);
+	else
+		while(!ITER_EQUAL(first, last))
+		{
+			c_rb_tree_erase(thiz, first);
+			ITER_INC(first);
+		}
+}
+
+void c_rb_tree_clear(c_prb_tree thiz)
+{
+	if(thiz->_A_node_count != 0)
+	{
+		_A_erase(*_A_root(thiz));
+		*_A_leftmost(thiz) = thiz->_A_header;
+		*_A_root(thiz) = NULL;
+		*_A_rightmost(thiz) = thiz->_A_header;
+		thiz->_A_node_count = 0;
+	}
+}
+
+
+c_iterator c_rb_tree_find(c_prb_tree thiz, key_type key)
+{
+	_base_ptr y = thiz->_A_header;
+	_base_ptr x = *_A_root(thiz);
+	c_iterator j;
+	c_iterator end = c_rb_tree_end(thiz);
+
+	while(x != NULL)
+		if(thiz->_A_key_compare(_S_key(thiz, x), key) >= 0)
+		{
+			y = x;
+			x = *_S_left(x);
+		}
+		else
+			x = *_S_right(x);
+	j = _A_get_iterator(y);
+	return (ITER_EQUAL(j, end) || 
+			thiz->_A_key_compare(key, _S_key(thiz, j._i)) < 0) ? 
+			end : j;
+}
+
+size_type c_rb_tree_count(c_prb_tree thiz, key_type key)
+{
+	c_iter_iter_pair p = c_rb_tree_equal_range(thiz, key);
+	difference_type n = 0;
+	c_distance1(p.first, p.second, &n);
+	return abs(n);
+}
+
+c_iterator c_rb_tree_lower_bound(c_prb_tree thiz, key_type key)
+{
+	_base_ptr y = thiz->_A_header;
+	_base_ptr x = *_A_root(thiz);
+
+	while(x != NULL)
+		if(thiz->_A_key_compare(_S_key(thiz, x), key) >= 0)
+		{
+			y = x;
+			x = *_S_left(x);
+		}
+		else
+			x = *_S_right(x);
+
+	return _A_get_iterator(y);
+}
+
+c_iterator c_rb_tree_upper_bound(c_prb_tree thiz, key_type key)
+{
+	_base_ptr y = thiz->_A_header;
+	_base_ptr x = *_A_root(thiz);
+	
+	while(x != NULL)
+		if(thiz->_A_key_compare(key, _S_key(thiz, x)) < 0)
+		{
+			y = x;
+			x = *_S_left(x);
+		}
+		else
+			x = *_S_right(x);
+
+	return _A_get_iterator(y);
+}
+
+c_iter_iter_pair c_rb_tree_equal_range(c_prb_tree thiz, key_type key)
+{
+	return c_make_iter_iter_pair(c_rb_tree_lower_bound(thiz, key), 
+					c_rb_tree_upper_bound(thiz, key));
+}
+
+c_bool c_rb_tree_less(c_prb_tree thiz, const c_prb_tree T, COMPARER cmp)
+{
+	return c_lexicographical_compare(c_rb_tree_begin(thiz),
+					 c_rb_tree_end(thiz),
+					 c_rb_tree_begin(T),
+					 c_rb_tree_end(T),
+					 cmp);
+}
+
+c_bool c_rb_tree_equal(c_prb_tree thiz, const c_prb_tree T, COMPARER cmp)
+{
+	c_binary_predicate bpred = c_binary_negate(cmp);
+	return c_rb_tree_size(thiz) == c_rb_tree_size(T) &&
+		c_equal2(c_rb_tree_begin(thiz), c_rb_tree_end(thiz), c_rb_tree_begin(T), bpred);	
+}
+
+static int __black_count(_base_ptr node, _base_ptr root)
+{
+	if(node == NULL)
+		return 0;
+	else
+	{
+		int bc = node->_A_color == _S_c_rb_tree_black ? 1 : 0;
+		if(node == root)
+			return bc;
+		else
+			return bc + __black_count(node->_A_parent, root);
+	}
+}
+
+c_bool __c_rb_tree_verify(c_prb_tree thiz)
+{
+	c_iterator begin = c_rb_tree_begin(thiz);
+	c_iterator end = c_rb_tree_end(thiz);
+	int len;
+	c_iterator iter;
+
+	if(thiz->_A_node_count == 0 || ITER_EQUAL(begin, end))
+		return thiz->_A_node_count == 0 && ITER_EQUAL(begin, end) &&
+			thiz->_A_header->_A_left == thiz->_A_header &&
+			thiz->_A_header->_A_right == thiz->_A_header;
+
+	len = __black_count(*_A_leftmost(thiz), *_A_root(thiz));
+	for(iter = c_rb_tree_begin(thiz); !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		_base_ptr x = iter._i;
+		_base_ptr L = *_S_left(x);
+		_base_ptr R = *_S_right(x);
+
+		if(x->_A_color == _S_c_rb_tree_red)
+			if((L && L->_A_color == _S_c_rb_tree_red) ||
+				(R && R->_A_color == _S_c_rb_tree_red))
+			return false;
+
+		if(L && thiz->_A_key_compare(_S_key(thiz, x), _S_key(thiz, L)) < 0)
+			return false;
+		if(R && thiz->_A_key_compare(_S_key(thiz, R), _S_key(thiz, x)) < 0)
+			return false;
+
+		if(!L && !R && __black_count(x, *_A_root(thiz)) != len)
+			return false;
+	}
+	
+	if(*_A_leftmost(thiz) != _S_minimum(*_A_root(thiz)))
+		return false;
+	if(*_A_rightmost(thiz) != _S_maximum(*_A_root(thiz)))
+		return false;
+
+	return true;
+}
diff --git a/src/tstl2cl/c_tree.h b/src/tstl2cl/c_tree.h
new file mode 100644
index 0000000..756b195
--- /dev/null
+++ b/src/tstl2cl/c_tree.h
@@ -0,0 +1,160 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+/* 
+NOTE: This is an internal header file, You should not attempt to use it directly.
+*/
+
+#ifndef _C_TREE_H
+#define _C_TREE_H
+
+#include "c_def.h"
+#include "c_iterator.h"
+#include "c_memory.h"
+#include "c_pair.h"
+#include "c_function.h"
+
+#define c_rb_tree 			_c_rb_tree
+#define c_prb_tree 			_c_prb_tree
+#define c_rb_tree_create		__c_rb_tree
+#define c_rb_tree_destroy		__c_eert_br
+#define c_rb_tree_assign		_c_rb_tree_assign
+#define c_rb_tree_begin			_c_rb_tree_begin
+#define c_rb_tree_end			_c_rb_tree_end
+#define c_rb_tree_rbegin		_c_rb_tree_rbegin
+#define c_rb_tree_rend			_c_rb_tree_rend
+#define c_rb_tree_empty			_c_rb_tree_empty
+#define c_rb_tree_size			_c_rb_tree_size
+#define c_rb_tree_max_size		_c_rb_tree_max_size
+#define c_rb_tree_swap			_c_rb_tree_swap
+#define c_rb_tree_insert_unique		_c_rb_tree_insert_unique
+#define c_rb_tree_insert_equal		_c_rb_tree_insert_equal
+#define c_rb_tree_insert_unique1	_c_rb_tree_insert_unique1
+#define c_rb_tree_insert_equal1		_c_rb_tree_insert_equal1
+#define c_rb_tree_insert_unique2	_c_rb_tree_insert_unique2
+#define c_rb_tree_insert_equal2		_c_rb_tree_insert_equal2
+#define c_rb_tree_erase			_c_rb_tree_erase
+#define c_rb_tree_erase1		_c_rb_tree_erase1
+#define c_rb_tree_erase2		_c_rb_tree_erase2
+#define c_rb_tree_clear			_c_rb_tree_clear
+#define c_rb_tree_find			_c_rb_tree_find
+#define c_rb_tree_count			_c_rb_tree_count
+#define c_rb_tree_lower_bound		_c_rb_tree_lower_bound
+#define c_rb_tree_upper_bound		_c_rb_tree_upper_bound
+#define c_rb_tree_equal_range		_c_rb_tree_equal_range
+#define c_rb_tree_less			_c_rb_tree_less
+#define c_rb_tree_equal			_c_rb_tree_equal
+
+
+typedef c_bool _c_rb_tree_color_type;
+typedef value_type key_type;
+typedef struct _c_rb_tree_node _c_rb_tree_node, * _c_prb_tree_node;
+typedef _c_rb_tree_color_type _color_type;
+typedef _c_rb_tree_node * _base_ptr;
+typedef _base_ptr _link_type;
+            
+struct _c_rb_tree_node
+{
+    _color_type _A_color;
+    _base_ptr _A_parent;
+    _base_ptr _A_left;
+    _base_ptr _A_right;
+    value_type _A_value_field;
+};
+
+typedef struct c_rb_tree
+{
+	_base_ptr _A_header;
+	size_type _A_node_count;
+	COMPARER _A_key_compare;
+	c_unary_function _A_keyofvalue;
+}c_rb_tree, * c_prb_tree;
+
+
+
+void __c_rb_tree(c_prb_tree thiz, COMPARER pcmp);
+void __c_eert_br(c_prb_tree thiz);
+c_prb_tree c_rb_tree_assign(c_prb_tree thiz, const c_prb_tree T);
+c_iterator c_rb_tree_begin(c_prb_tree thiz);
+c_iterator c_rb_tree_end(c_prb_tree thiz);
+c_reverse_iterator c_rb_tree_rbegin(c_prb_tree thiz);
+c_reverse_iterator c_rb_tree_rend(c_prb_tree thiz);
+c_bool c_rb_tree_empty(c_prb_tree thiz);
+size_type c_rb_tree_size(c_prb_tree thiz);
+size_type c_rb_tree_max_size(c_prb_tree thiz);
+void c_rb_tree_swap(c_prb_tree thiz, c_prb_tree T);
+c_iter_bool_pair c_rb_tree_insert_unique(c_prb_tree thiz, const value_type val);
+c_iterator c_rb_tree_insert_equal(c_prb_tree thiz, const value_type val);
+c_iterator c_rb_tree_insert_unique1(c_prb_tree thiz, c_iterator position, const value_type val);
+c_iterator c_rb_tree_insert_equal1(c_prb_tree thiz, c_iterator position, const value_type val);
+void c_rb_tree_insert_unique2(c_prb_tree thiz, c_iterator first, c_iterator last);
+void c_rb_tree_insert_equal2(c_prb_tree thiz, c_iterator first, c_iterator last);
+void c_rb_tree_erase(c_prb_tree thiz, c_iterator position);
+size_type c_rb_tree_erase1(c_prb_tree thiz, key_type key);
+void c_rb_tree_erase2(c_prb_tree thiz, c_iterator first, c_iterator last);
+void c_rb_tree_clear(c_prb_tree thiz);
+c_iterator c_rb_tree_find(c_prb_tree thiz, key_type key);
+size_type c_rb_tree_count(c_prb_tree thiz, key_type key);
+c_iterator c_rb_tree_lower_bound(c_prb_tree thiz, key_type key);
+c_iterator c_rb_tree_upper_bound(c_prb_tree thiz, key_type key);
+c_iter_iter_pair c_rb_tree_equal_range(c_prb_tree thiz, key_type key);
+c_bool c_rb_tree_less(c_prb_tree thiz, const c_prb_tree T, COMPARER cmp);
+c_bool c_rb_tree_equal(c_prb_tree thiz, const c_prb_tree T, COMPARER cmp);
+c_bool __c_rb_tree_verify(c_prb_tree thiz);
+
+
+#endif /* _C_TREE_H */
+
+
+
+
+
diff --git a/src/tstl2cl/c_vector.c b/src/tstl2cl/c_vector.c
new file mode 100644
index 0000000..ab3ffbe
--- /dev/null
+++ b/src/tstl2cl/c_vector.c
@@ -0,0 +1,661 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+*/
+
+#include "c_vector.h"
+#include "c_algo.h"
+#include "c_memory.h"
+
+typedef value_type node_t;
+typedef node_t  * pnode_t;
+
+typedef struct _c_vector_impl
+{
+	pnode_t _start;
+	pnode_t _finish;
+	pnode_t _end_of_storage;
+} _c_vector_impl;
+
+static c_iterator _A_get_iterator(pnode_t pn);
+static c_reverse_iterator _A_get_reverse_iterator(pnode_t pn);
+
+static c_iterator _c_vector_iterator_assign(c_piterator thiz, const c_piterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;
+}
+
+static value_type _c_vector_iterator_ref(c_piterator thiz)
+{
+	return *(pnode_t)thiz->_i;
+}
+
+static value_type _c_vector_iterator_ref_assign(c_piterator thiz, const value_type val)
+{
+	return *(pnode_t)thiz->_i = val;
+}
+
+static c_iterator _c_vector_iterator_inc(c_piterator thiz)
+{
+	pnode_t pn = thiz->_i;
+	++ pn;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_iterator _c_vector_iterator_inc_n(c_piterator thiz, difference_type n)
+{
+	pnode_t pn = thiz->_i;
+	pn += n;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_iterator _c_vector_iterator_dec(c_piterator thiz)
+{
+	pnode_t pn = thiz->_i;
+	-- pn;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_iterator _c_vector_iterator_dec_n(c_piterator thiz, difference_type n)
+{
+	pnode_t pn = thiz->_i;
+	pn -= n;
+	thiz->_i = pn;
+	return *thiz;   
+}
+    
+static difference_type _c_vector_iterator_diff(c_piterator thiz, const c_piterator val)
+{
+	return ((pnode_t)thiz->_i - (pnode_t)val->_i);
+}
+
+static value_type _c_vector_iterator_at(c_piterator thiz, difference_type n)
+{
+	return *((pnode_t)thiz->_i + n);
+}
+
+static c_iterator _c_vector_iterator_positive_n(c_piterator thiz, difference_type n)
+{
+	c_iterator iter;
+	pnode_t pn = thiz->_i;
+	pn += n;    
+	iter = _A_get_iterator(pn);
+	return iter;    
+}
+
+static c_iterator _c_vector_iterator_negative_n(c_piterator thiz, difference_type n)
+{
+	c_iterator iter;
+	pnode_t pn = thiz->_i;
+	pn -= n;    
+	iter = _A_get_iterator(pn);
+	return iter;
+}
+
+static c_bool _c_vector_iterator_equal(c_piterator thiz, const c_piterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_bool _c_vector_iterator_less(c_piterator thiz, const c_piterator val)
+{
+	return ((pnode_t)thiz->_i < (pnode_t)val->_i);
+}
+
+static c_iterator_ft _c_vector_iter_ft = 
+{
+	_c_vector_iterator_assign,
+	_c_vector_iterator_ref,
+	_c_vector_iterator_ref_assign,
+	_c_vector_iterator_inc,
+	_c_vector_iterator_inc_n,
+	_c_vector_iterator_dec,
+	_c_vector_iterator_dec_n,
+	_c_vector_iterator_diff,
+	_c_vector_iterator_at,
+	_c_vector_iterator_positive_n,
+	_c_vector_iterator_negative_n,
+	_c_vector_iterator_equal,
+	_c_vector_iterator_less
+};
+
+static c_reverse_iterator _c_vector_reverse_iterator_assign(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	if(thiz != val)
+		thiz->_i = val->_i;
+	return *thiz;    
+}
+
+static value_type _c_vector_reverse_iterator_ref(c_preverse_iterator thiz)
+{
+	return *(pnode_t)thiz->_i;
+}
+
+static value_type _c_vector_reverse_iterator_ref_assign(c_preverse_iterator thiz, const value_type val)
+{
+	return *(pnode_t)thiz->_i = val; 
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_inc(c_preverse_iterator thiz)
+{
+	pnode_t pn = thiz->_i;
+	-- pn;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_inc_n(c_preverse_iterator thiz, difference_type n)
+{
+	pnode_t pn = thiz->_i;
+	pn -= n;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_dec(c_preverse_iterator thiz)
+{
+	pnode_t pn = thiz->_i;
+	++ pn;
+	thiz->_i = pn;
+	return *thiz;
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_dec_n(c_preverse_iterator thiz, difference_type n)
+{    
+	pnode_t pn = thiz->_i;
+	pn += n;
+	thiz->_i = pn;
+	return *thiz; 
+}
+
+static difference_type _c_vector_reverse_iterator_diff(c_preverse_iterator thiz, const c_preverse_iterator val)
+{  
+	return ((pnode_t)val->_i - (pnode_t)thiz->_i);    
+}
+
+static value_type _c_vector_reverse_iterator_at(c_preverse_iterator thiz, difference_type n)
+{
+	return *((pnode_t)thiz->_i - n);
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_positive_n(c_preverse_iterator thiz, difference_type n)
+{
+	c_reverse_iterator iter;
+	pnode_t pn = thiz->_i;
+	pn -= n;    
+	iter = _A_get_reverse_iterator(pn);
+	return iter;  
+}
+
+static c_reverse_iterator _c_vector_reverse_iterator_negative_n(c_preverse_iterator thiz, difference_type n)
+{
+	c_reverse_iterator iter;
+	pnode_t pn = thiz->_i;
+	pn += n;    
+	iter = _A_get_reverse_iterator(pn);
+	return iter;
+}
+
+static c_bool _c_vector_reverse_iterator_equal(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return (thiz->_i == val->_i &&
+				thiz->_pft == val->_pft);
+}
+
+static c_bool _c_vector_reverse_iterator_less(c_preverse_iterator thiz, const c_preverse_iterator val)
+{
+	return ((pnode_t)thiz->_i > (pnode_t)val->_i);
+}
+
+static c_reverse_iterator_ft _c_vector_rev_iter_ft = 
+{
+	_c_vector_reverse_iterator_assign,
+	_c_vector_reverse_iterator_ref,
+	_c_vector_reverse_iterator_ref_assign,
+	_c_vector_reverse_iterator_inc,
+	_c_vector_reverse_iterator_inc_n,
+	_c_vector_reverse_iterator_dec,
+	_c_vector_reverse_iterator_dec_n,
+	_c_vector_reverse_iterator_diff,
+	_c_vector_reverse_iterator_at,
+	_c_vector_reverse_iterator_positive_n,
+	_c_vector_reverse_iterator_negative_n,
+	_c_vector_reverse_iterator_equal,
+	_c_vector_reverse_iterator_less
+};
+
+static c_iterator _A_get_iterator(pnode_t pn)
+{
+	c_iterator iter;
+	iter._pft = &_c_vector_iter_ft;
+	iter._i = pn;
+	return iter;
+}
+
+static c_reverse_iterator _A_get_reverse_iterator(pnode_t pn)
+{   
+	c_reverse_iterator iter;
+	iter._pft = &_c_vector_rev_iter_ft;
+	iter._i = pn;
+	return iter;
+}
+
+static pnode_t _A_allocate(c_pvector thiz, size_t n)
+{
+	return __c_malloc(n * sizeof(node_t));
+}
+
+static void _A_deallocate(c_pvector thiz, pnode_t p, size_t n)
+{
+	if(n > 0)
+		__c_free(p);
+}
+
+static c_iterator _A_allocate_and_copy(c_pvector thiz, size_type n, c_const_iterator first, c_const_iterator last)
+{
+	c_iterator result = _A_get_iterator(_A_allocate(thiz, n));
+	c_uninitialized_copy(first, last, result);
+	return result;
+}
+
+static void _A_insert_aux1(c_pvector thiz, c_iterator pos, node_t val)
+{
+	_c_vector_impl * pl = thiz->_l;
+	if(pl->_finish != pl->_end_of_storage)
+	{
+		node_t node;
+		*pl->_finish = *(pl->_finish - 1);
+		++ pl->_finish;
+		node = val;
+		c_copy_backward(pos,
+				_A_get_iterator(pl->_finish - 2),
+				_A_get_iterator(pl->_finish - 1));
+		ITER_REF_ASSIGN(pos, node);
+	}
+	else
+	{
+		const size_type old_size = c_vector_size(thiz);
+		const size_type len = old_size != 0 ? 2 * old_size : 1;
+		c_iterator new_start = _A_get_iterator(_A_allocate(thiz, len));
+		c_iterator new_finish = new_start;
+		new_finish = c_copy(_A_get_iterator(pl->_start), pos, new_start);
+		ITER_REF_ASSIGN(new_finish, val);
+		ITER_INC(new_finish);
+		new_finish = c_copy(pos, _A_get_iterator(pl->_finish), new_finish);
+		_A_deallocate(thiz, pl->_start, abs(pl->_end_of_storage - pl->_start));
+		pl->_start = new_start._i;
+		pl->_finish = new_finish._i;
+		pl->_end_of_storage = pl->_start + len;
+	}
+}
+
+void __c_vector(c_pvector thiz, COMPARER pcmp)
+{
+	thiz->_cmp = pcmp;
+	thiz->_l = __c_malloc(sizeof(_c_vector_impl));
+	((_c_vector_impl *)thiz->_l)->_start = NULL;
+	((_c_vector_impl *)thiz->_l)->_finish = NULL;
+	((_c_vector_impl *)thiz->_l)->_end_of_storage = NULL;
+}
+
+void __c_rotcev(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	_A_deallocate(thiz, pl->_start, abs(pl->_end_of_storage - pl->_start));
+	__c_free(thiz->_l);
+}
+
+c_iterator c_vector_begin(c_pvector thiz)
+{
+	return _A_get_iterator(((_c_vector_impl*)thiz->_l)->_start);
+}
+
+c_iterator c_vector_end(c_pvector thiz)
+{
+	return _A_get_iterator(((_c_vector_impl*)thiz->_l)->_finish);
+}
+
+c_reverse_iterator c_vector_rbegin(c_pvector thiz)
+{
+	return _A_get_reverse_iterator(((_c_vector_impl*)thiz->_l)->_finish - 1);    
+}
+
+c_reverse_iterator c_vector_rend(c_pvector thiz)
+{
+	return _A_get_reverse_iterator(((_c_vector_impl*)thiz->_l)->_start - 1);
+}
+
+size_type c_vector_size(c_pvector thiz)
+{
+	c_iterator b = c_vector_begin(thiz), e = c_vector_end(thiz);
+	return abs(ITER_DIFF(e, b));
+}
+
+size_type c_vector_max_size(c_pvector thiz)
+{
+	return (size_type)(-1) / sizeof(node_t);
+}
+
+size_type c_vector_capacity(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	return abs(pl->_end_of_storage - pl->_start);
+}
+
+c_bool c_vector_empty(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	return (pl->_start == pl->_finish);
+}
+
+value_type c_vector_at(c_pvector thiz, size_type n)
+{
+	_c_vector_impl * pl = thiz->_l;
+	return *(pl->_start + n);
+}
+
+c_pvector c_vector_assign(c_pvector thiz, const c_pvector V)
+{
+	if(V != thiz)
+	{
+		_c_vector_impl * pl = thiz->_l;
+		const size_type vlen = c_vector_size(V);
+		if(vlen > c_vector_capacity(thiz))
+		{
+			c_iterator tmp = _A_allocate_and_copy(thiz,
+								vlen,
+								c_vector_begin(V),
+								c_vector_end(V));
+			_A_deallocate(thiz, 
+					pl->_start, 
+					abs(pl->_end_of_storage - pl->_start));
+			pl->_start = tmp._i;
+			pl->_end_of_storage = pl->_start + vlen;
+		}
+		else if(c_vector_size(thiz) >= vlen)
+		{
+			c_copy(c_vector_begin(V), c_vector_end(V), c_vector_begin(thiz));
+		}
+		else
+		{
+			c_iterator bg = c_vector_begin(thiz);
+			c_copy(bg, ITER_POSITIVE_N(bg, c_vector_size(thiz)), _A_get_iterator(pl->_start));
+			c_uninitialized_copy(ITER_POSITIVE_N(bg, c_vector_size(thiz)),
+						c_vector_end(thiz),
+						_A_get_iterator(pl->_finish));
+		}
+		pl->_finish = pl->_start + vlen;
+	}
+	return thiz;
+}
+
+void c_vector_reserve(c_pvector thiz, size_t n)
+{
+	if(c_vector_capacity(thiz) < n)
+	{
+		_c_vector_impl * pl = thiz->_l;
+		const size_type old_size = c_vector_size(thiz);
+		c_iterator tmp = _A_allocate_and_copy(thiz, n, c_vector_begin(thiz), c_vector_end(thiz));
+		_A_deallocate(thiz, pl->_start, abs(pl->_end_of_storage - pl->_start));
+		pl->_start = tmp._i;
+		pl->_finish = pl->_start + old_size;
+		pl->_end_of_storage = pl->_start + n;
+	}    
+}
+
+value_type c_vector_front(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	return *pl->_start;
+}
+
+value_type c_vector_back(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	return *(pl->_finish - 1);
+}
+
+void c_vector_push_back(c_pvector thiz, const value_type val)
+{
+	_c_vector_impl * pl = thiz->_l;
+	if(pl->_finish != pl->_end_of_storage)
+	{
+		*pl->_finish = val;
+		++ pl->_finish;
+	}
+	else
+		_A_insert_aux1(thiz, c_vector_end(thiz), val);
+}
+
+void c_vector_pop_back(c_pvector thiz)
+{
+	_c_vector_impl * pl = thiz->_l;
+	-- pl->_finish;
+}
+
+void c_vector_swap(c_pvector thiz, c_pvector V)
+{
+	c_vector tmp;
+	C_SWAP(*thiz, *V, tmp);
+}
+
+c_iterator c_vector_insert(c_pvector thiz, c_iterator pos, const value_type val)
+{
+	c_iterator begin = c_vector_begin(thiz);
+	c_iterator end = c_vector_end(thiz);
+	size_type n = abs(ITER_DIFF(pos, begin));
+	_c_vector_impl * pl = thiz->_l;
+	if((pl->_finish != pl->_end_of_storage) && 
+		ITER_EQUAL(pos, end))
+	{
+		*pl->_finish = val;
+		++ pl->_finish;
+	}
+	else
+		_A_insert_aux1(thiz, pos, val);
+	return ITER_POSITIVE_N(begin, n);
+}
+
+void c_vector_insert2(c_pvector thiz, c_iterator pos, c_iterator first, c_iterator last)
+{
+	if(!ITER_EQUAL(first, last))
+	{
+		_c_vector_impl * pl = thiz->_l;
+		difference_type dn = 0;
+		size_type n = 0;
+		c_distance1(first, last, &dn);
+		n = abs(dn);
+		if(abs(pl->_end_of_storage - pl->_finish) >= n)
+		{
+			const size_type elems_after = pl->_finish - (pnode_t)pos._i;
+			c_iterator old_finish = c_vector_end(thiz);
+			if(elems_after > n)
+			{
+				c_uninitialized_copy(_A_get_iterator(pl->_finish - n),
+							_A_get_iterator(pl->_finish),
+							_A_get_iterator(pl->_finish));
+				pl->_finish += n;
+				c_copy_backward(pos, ITER_NEGATIVE_N(old_finish, n), old_finish);
+				c_copy(first, last, pos);
+			}
+			else
+			{
+				c_uninitialized_copy(ITER_POSITIVE_N(first, elems_after), 
+							last, 
+							_A_get_iterator(pl->_finish));
+				pl->_finish += n - elems_after;
+				c_uninitialized_copy(pos, old_finish, _A_get_iterator(pl->_finish));
+				pl->_finish += elems_after;
+				c_copy(first, ITER_POSITIVE_N(first, elems_after), pos);
+			}
+		}
+		else
+		{
+			const size_type old_size = c_vector_size(thiz);
+			const size_type len = old_size + C_MAX(old_size, n);
+			c_iterator new_start = _A_get_iterator(_A_allocate(thiz, len));
+			c_iterator new_finish = new_start;
+			new_finish = c_uninitialized_copy(_A_get_iterator(pl->_start), pos, new_start);
+			new_finish = c_uninitialized_copy(first, last, new_finish);
+			new_finish = c_uninitialized_copy(pos, _A_get_iterator(pl->_finish), new_finish);
+			_A_deallocate(thiz, pl->_start, abs(pl->_end_of_storage - pl->_start));
+			pl->_start = new_start._i;
+			pl->_finish = new_finish._i;
+			pl->_end_of_storage = ITER_POSITIVE_N(new_start, len)._i;
+		}
+	}
+}
+
+void c_vector_fill_insert(c_pvector thiz, c_iterator pos, size_type n, const value_type val)
+{
+	_c_vector_impl * pl = thiz->_l;
+	if(n != 0)
+	{
+		if(abs(pl->_end_of_storage - pl->_finish) >= n)
+		{
+			value_type val_copy = val;
+			const size_type elems_after = pl->_finish - (pnode_t)pos._i;
+			c_iterator old_finish = c_vector_end(thiz);
+			if(elems_after > n)
+			{
+				c_uninitialized_copy(_A_get_iterator(pl->_finish - n),
+							_A_get_iterator(pl->_finish),
+							_A_get_iterator(pl->_finish));
+				pl->_finish += n;
+				c_copy_backward(pos, 
+						ITER_NEGATIVE_N(old_finish, n),
+						old_finish);
+				c_fill(pos, ITER_POSITIVE_N(pos, n), val_copy);
+			}
+			else
+			{
+				c_uninitialized_fill_n(c_vector_end(thiz), n - elems_after, val_copy);
+				pl->_finish += n - elems_after;
+				c_uninitialized_copy(pos, old_finish, c_vector_end(thiz));
+				pl->_finish += elems_after;
+				c_fill(pos, old_finish, val_copy);
+			}
+		}
+		else
+		{
+			const size_type old_size = c_vector_size(thiz);
+			const size_type len = old_size + C_MAX(old_size, n);
+			c_iterator new_start = _A_get_iterator(_A_allocate(thiz, len));
+			c_iterator new_finish = new_start;
+			new_finish = c_uninitialized_copy(_A_get_iterator(pl->_start),
+								pos,
+								new_start);
+			new_finish = c_uninitialized_fill_n(new_finish, n, val);
+			new_finish = c_uninitialized_copy(pos, _A_get_iterator(pl->_finish), new_finish);
+			_A_deallocate(thiz, pl->_start, abs(pl->_end_of_storage - pl->_start));
+			pl->_start = new_start._i;
+			pl->_finish = new_finish._i;
+			pl->_end_of_storage = pl->_start + len;
+        	}
+	}
+}
+
+c_iterator c_vector_erase(c_pvector thiz, c_iterator pos)
+{
+	c_iterator pos_1 = ITER_POSITIVE_N(pos, 1);
+	c_iterator end = c_vector_end(thiz);
+	_c_vector_impl * pl = thiz->_l;
+	if(!ITER_EQUAL(pos_1, end))
+		c_copy(pos_1, _A_get_iterator(pl->_finish), pos);
+	-- pl->_finish;
+	return pos;
+}
+
+c_iterator c_vector_erase2(c_pvector thiz, c_iterator first, c_iterator last)
+{
+	_c_vector_impl * pl = thiz->_l;
+	c_copy(last, _A_get_iterator(pl->_finish), first);
+	pl->_finish = pl->_finish - abs(ITER_DIFF(last, first));
+	return first;
+}
+
+void c_vector_clear(c_pvector thiz)
+{
+	c_vector_erase2(thiz, c_vector_begin(thiz), c_vector_end(thiz));
+}
+
+void c_vector_resize(c_pvector thiz, size_t n)
+{
+	c_iterator begin = c_vector_begin(thiz);
+	if(n < c_vector_size(thiz))
+		c_vector_erase2(thiz, ITER_POSITIVE_N(begin, n), c_vector_end(thiz));
+	else
+		c_vector_fill_insert(thiz, c_vector_end(thiz), n, NULL);
+}
+
+c_bool c_vector_equal(c_pvector thiz, const c_pvector V)
+{
+	c_binary_predicate bp =  c_binary_negate(thiz->_cmp);
+	return (c_vector_size(thiz) == c_vector_size(V)) &&
+			c_equal2(c_vector_begin(thiz),
+					c_vector_end(thiz),
+					c_vector_begin(V),
+					bp);
+}
+
+c_bool c_vector_less(c_pvector thiz, const c_pvector V)
+{
+	return c_lexicographical_compare(c_vector_begin(thiz),
+						c_vector_end(thiz),
+						c_vector_begin(V),
+						c_vector_end(V),
+						thiz->_cmp);
+}
diff --git a/src/tstl2cl/doc/eng/Assignable.html b/src/tstl2cl/doc/eng/Assignable.html
new file mode 100644
index 0000000..a5bd334
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Assignable.html
@@ -0,0 +1,265 @@
+<HTML>
+<Head>
+<Title>Assignable</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Assignable</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: utilities</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A type is Assignable if it is possible to copy objects of that type and
+to assign values to variables.
+<h3>Refinement of</h3>
+<h3>Associated types</h3>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Assignable
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>, <tt>y</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<pre>
+X x(y);
+X x = y;
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Assignment
+</TD>
+<TD VAlign=top>
+<tt>x = y</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Swap
+</TD>
+<TD VAlign=top>
+<tt>swap(x,y)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>void</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt> is a copy of <tt>x</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt> is a copy of <tt>x</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<pre>
+X x(y);
+X x = y;
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is a copy of <tt>y</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Assignment
+</TD>
+<TD VAlign=top>
+<tt>x</tt> = <tt>y</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is a copy of <tt>y</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Swap
+</TD>
+<TD VAlign=top>
+<tt><A href="swap.html">swap</A>(x,y)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Equivalent to
+<pre>
+{
+  X tmp = x; 
+  x = y; 
+  y = tmp; 
+}
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+int
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+One implication of this requirement is that a <tt>const</tt> type is not Assignable.
+For example, <tt>const int</tt> is not Assignable: if <tt>x</tt> is declared to be
+of type <tt>const int</tt>, then <tt>x = 7</tt> is illegal.  Similarly, the type
+<tt><A href="pair.html">pair</A>&lt;const int, int&gt;</tt> is not Assignable.
+<P><A name="2">[2]</A>
+The reason this says &quot;<tt>x</tt> is a copy of <tt>y</tt>&quot;, rather than
+&quot;<tt>x == y</tt>&quot;, is that <tt>operator==</tt> is not necessarily defined: equality
+is not a requirement of Assignable.  If the type <tt>X</tt> is
+<A href="EqualityComparable.html">EqualityComparable</A> as well as Assignable, then a copy of <tt>x</tt> 
+should compare equal to <tt>x</tt>.
+<h3>See also</h3>
+<!--<A href="DefaultConstructible.html">-->DefaultConstructible<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/BidirectionalIterator.html b/src/tstl2cl/doc/eng/BidirectionalIterator.html
new file mode 100644
index 0000000..7e91dc4
--- /dev/null
+++ b/src/tstl2cl/doc/eng/BidirectionalIterator.html
@@ -0,0 +1,213 @@
+<HTML>
+<Head>
+<Title>Bidirectional Iterator</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Bidirectional Iterator</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Bidirectional Iterator is an iterator that can be both incremented
+and decremented.  The requirement that a Bidirectional Iterator
+can be decremented is the only thing that distinguishes 
+Bidirectional Iterators from <A href="ForwardIterator.html">Forward Iterators</A>.
+<h3>Refinement of</h3>
+<A href="ForwardIterator.html">Forward Iterator</A>
+<h3>Associated types</h3>
+The same as for <A href="ForwardIterator.html">Forward Iterator</A>.
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Bidirectional Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The value type of <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>i</tt>, <tt>j</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>t</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>T</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+<h3>Valid expressions</h3>
+In addition to the expressions defined in <A href="ForwardIterator.html">Forward Iterator</A>, the
+following expressions must be valid.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Predecrement
+</TD>
+<TD VAlign=top>
+<tt>--i</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postdecrement
+</TD>
+<TD VAlign=top>
+<tt>i--</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression Semantics</h3>
+Semantics of an expression is defined only where it is not defined in
+<A href="ForwardIterator.html">Forward Iterator</A>.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Predecrement
+</TD>
+<TD VAlign=top>
+<tt>--i</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end.  There exists a
+   dereferenceable iterator <tt>j</tt> such that <tt>i == ++j</tt>.
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is modified to point to the previous element.
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable.  <tt>&amp;i = &amp;--i</tt>.  If <tt>i == j</tt>, then
+   <tt>--i == --j</tt>.  If <tt>j</tt> is dereferenceable and <tt>i == ++j</tt>, 
+   then <tt>--i == j</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postdecrement
+</TD>
+<TD VAlign=top>
+<tt>i--</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end.  There exists a
+   dereferenceable iterator <tt>j</tt> such that <tt>i == ++j</tt>.
+</TD>
+<TD VAlign=top>
+Equivalent to
+<pre>
+{ 
+  X tmp = i; 
+  --i; 
+  return tmp; 
+}
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+The complexity of operations on bidirectional iterators is
+guaranteed to be amortized constant time.
+<h3>Invariants</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Symmetry of increment and decrement
+</TD>
+<TD VAlign=top>
+If <tt>i</tt> is dereferenceable, then <tt>++i; --i;</tt> is a null operation.
+   Similarly, <tt>--i; ++i;</tt> is a null operation.
+</TD>
+</tr>
+</table>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>T*</tt>
+<LI>
+<tt><A href="List.html">list</A>&lt;T&gt;::iterator</tt>
+</UL>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="ForwardIterator.html">Forward Iterator</A>,
+<A href="RandomAccessIterator.html">Random Access Iterator</A>, <A href="Iterators.html">Iterator overview</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/BinaryFunction.html b/src/tstl2cl/doc/eng/BinaryFunction.html
new file mode 100644
index 0000000..05ecc9f
--- /dev/null
+++ b/src/tstl2cl/doc/eng/BinaryFunction.html
@@ -0,0 +1,210 @@
+<HTML>
+<Head>
+<Title>Binary Function</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Binary Function</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Binary Function is a kind of <A href="functors.html">function object</A>: an object that is called
+as if it were an ordinary C++ function.  A Binary Function is called with 
+two arguments.
+<h3>Refinement of</h3>
+<A href="Assignable.html">Assignable</A>
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+First argument type
+</TD>
+<TD VAlign=top>
+The type of the Binary Function's first argument.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Second argument type
+</TD>
+<TD VAlign=top>
+The type of the Binary Function's second argument.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Result type
+</TD>
+<TD VAlign=top>
+The type returned when the Binary Function is called
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>F</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of BinaryFunction
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+The first argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Y</tt>
+</TD>
+<TD VAlign=top>
+The second argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Result</tt>
+</TD>
+<TD VAlign=top>
+The result type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>f</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>y</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>Y</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+The <i>domain</i> of a Binary Function is the set of all ordered
+pairs <tt>(x, y)</tt> that are permissible values for its arguments.
+<P>
+The <i>range</i> of a Binary Function is the set of all possible value that it
+may return.
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x,y)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>Result</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x,y)</tt>
+</TD>
+<TD VAlign=top>
+The ordered pair <tt>(x,y)</tt>  is in <tt>f</tt>'s domain
+</TD>
+<TD VAlign=top>
+Calls <tt>f</tt> with <tt>x</tt> and <tt>y</tt> as arguments, and returns a value of type <tt>Result</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+The return value is in <tt>f</tt>'s range
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>Result (*)(X,Y)</tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Two different invocations of <tt>f</tt> may return different results, even
+if <tt>f</tt> is called with the same arguments both times.
+A Binary Function may refer to local state, perform I/O,
+and so on.  The expression <tt>f(x,y)</tt> is permitted to change <tt>f</tt>'s state.
+<h3>See also</h3>
+<A href="functors.html">Function Object overview</A>, <!--<A href="Generator.html">-->Generator<!--</A>-->, <A href="UnaryFunction.html">Unary Function</A>
+<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/BinaryPredicate.html b/src/tstl2cl/doc/eng/BinaryPredicate.html
new file mode 100644
index 0000000..26d865d
--- /dev/null
+++ b/src/tstl2cl/doc/eng/BinaryPredicate.html
@@ -0,0 +1,178 @@
+<HTML>
+<Head>
+<Title>Binary Predicate</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Binary Predicate</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Binary Predicate is a <A href="BinaryFunction.html">Binary Function</A> whose result
+represents the truth or falsehood of some condition.  A Binary Predicate
+might, for example, be a function that takes two arguments and tests
+whether they are equal.
+<h3>Refinement of</h3>
+<A href="BinaryFunction.html">Binary Function</A>
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Result type
+</TD>
+<TD VAlign=top>
+The type returned when the Binary Predicate is called.  The result type
+   must be convertible to <tt>bool</tt>.  
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>F</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Binary Predicate
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+The first argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Y</tt>
+</TD>
+<TD VAlign=top>
+The second argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>f</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>y</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>Y</tt>
+</TD>
+</tr>
+</table>
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x,y)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x,y)</tt>
+</TD>
+<TD VAlign=top>
+The ordered pair <tt>(x,y)</tt> is in the domain of <tt>f</tt>.
+</TD>
+<TD VAlign=top>
+Returns <tt>true</tt> if the condition is satisfied, <tt>false</tt> if it is not.
+</TD>
+<TD VAlign=top>
+The result is either <tt>true</tt> or <tt>false</tt>.
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>bool (*)(int,int)</tt>
+<LI>
+<tt><!--<A href="equal_to.html">-->equal_to<!--</A>--></tt>
+</UL>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="Predicate.html">Predicate</A>, <!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->, <!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Container.html b/src/tstl2cl/doc/eng/Container.html
new file mode 100644
index 0000000..658eba7
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Container.html
@@ -0,0 +1,620 @@
+<HTML>
+<Head>
+<Title>Container</Title>
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Container</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: containers</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Container is an object that stores other objects (its <i>elements</i>),
+and that has methods for accessing its elements.  In particular, 
+every type that is a model of Container has an associated <A href="Iterators.html">iterator</A>
+type that can be used to iterate through the Container's elements.
+<P>
+There is no guarantee that the elements of a Container are stored
+in any definite order; the order might, in fact, be different upon
+each iteration through the Container.  Nor is there a guarantee that
+more than one iterator into a Container may be active at any one time.
+(Specific types of Containers, such as <!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->, do 
+provide such guarantees.)
+<P>
+A Container &quot;owns&quot; its elements: the lifetime of an element stored in 
+a container cannot exceed that of the Container itself. <A href="#1">[1]</A>
+<h3>Refinement of</h3>
+<A href="Assignable.html">Assignable</A>
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Value type
+</TD>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+The type of the object stored in a container.  The value type
+must be <A href="Assignable.html">Assignable</A>, but need not be <!--<A href="DefaultConstructible.html">-->DefaultConstructible<!--</A>-->. <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator type
+</TD>
+<TD VAlign=top>
+<tt>c_iterator</tt>
+</TD>
+<TD VAlign=top>
+The type of iterator used to iterate through a container's
+   elements.  The iterator's value type is expected to be the
+   container's value type.  A conversion
+   from the iterator type to the const iterator type must exist.
+   The iterator type must be an <A href="InputIterator.html">input iterator</A>. <A href="#3">[3]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Const iterator type
+</TD>
+<TD VAlign=top>
+<tt>c_const_iterator</tt>
+</TD>
+<TD VAlign=top>
+A type of iterator that may be used to examine, but not to modify,
+   a container's elements. <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+Reference type
+</TD>
+<TD VAlign=top>
+<tt>X::reference</tt>
+</TD>
+<TD VAlign=top>
+A type that behaves as a reference to the container's value type. <A href="#5">[5]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Const reference type
+</TD>
+<TD VAlign=top>
+<tt>X::const_reference</tt>
+</TD>
+<TD VAlign=top>
+A type that behaves as a const reference to the container's value
+type. <A href="#5">[5]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Pointer type
+</TD>
+<TD VAlign=top>
+<tt>X::pointer</tt>
+</TD>
+<TD VAlign=top>
+A type that behaves as a pointer to the container's value type. <A href="#6">[6]</A>
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+Distance type
+</TD>
+<TD VAlign=top>
+<tt>difference_type</tt>
+</TD>
+<TD VAlign=top>
+A signed integral type used to represent the distance between two
+   of the container's iterators.  This type must be the same as 
+   the iterator's distance type. <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Size type
+</TD>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+An unsigned integral type that can represent any nonnegative value
+   of the container's distance type. <A href="#2">[2]</A>
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Container
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>a</tt>, <tt>b</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The value type of <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+The <i>size</i> of a container is the number of elements it contains.
+The size is a nonnegative number.
+<P>
+The <i>area</i> of a container is the total number of bytes that it
+occupies.  More specifically, it is the sum of the elements' areas
+plus whatever overhead is associated with the container itself.  If a
+container's value type <tt>T</tt> is a simple type (as opposed to a container
+type), then the container's area is bounded above by a constant times
+the container's size times <tt>sizeof(T)</tt>.  That is, if <tt>a</tt> is a
+container with a simple value type, then <tt>a</tt>'s area is <tt>O(a.size())</tt>.
+<P>
+A <i>variable sized</i> container is one that provides methods for
+inserting and/or removing elements; its size may vary during a
+container's lifetime.  A <i>fixed size</i> container is one where 
+the size is constant throughout the container's lifetime.  In some
+fixed-size container types, the size is determined at compile time.
+<h3>Valid expressions</h3>
+In addition to the expressions defined in 
+<A href="Assignable.html">Assignable</A>, <A href="EqualityComparable.html">EqualityComparable</A>, and <A href="LessThanComparable.html">LessThanComparable</A>, the 
+following expressions must be valid.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Beginning of range
+</TD>
+<TD VAlign=top>
+<tt>c_X_begin(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>iterator</tt> if <tt>a</tt> is mutable, <tt>const_iterator</tt> otherwise <A href="#4">[4]</A> <A href="#7">[7]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+End of range
+</TD>
+<TD VAlign=top>
+<tt>c_X_end(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>iterator</tt> if <tt>a</tt> is mutable, <tt>const_iterator</tt> otherwise <A href="#4">[4]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Size
+</TD>
+<TD VAlign=top>
+<tt>c_X_size(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Maximum size
+</TD>
+<TD VAlign=top>
+<tt>c_X_max_size(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Empty container
+</TD>
+<TD VAlign=top>
+<tt>c_X_empty(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Swap
+</TD>
+<TD VAlign=top>
+<tt>c_X_swap(&b)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>void</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+Semantics of an expression is defined only where it differs from, or 
+is not defined in,
+<A href="Assignable.html">Assignable</A>, <A href="EqualityComparable.html">Equality Comparable</A>,
+or <A href="LessThanComparable.html">LessThan Comparable</A>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X().size() == a.size()</tt>.  <tt>X()</tt> contains a copy of each of <tt>a</tt>'s elements.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X b(a);</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>b.size() == a.size()</tt>.  <tt>b</tt> contains a copy of each of <tt>a</tt>'s elements.
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+Assignment operator
+</TD>
+<TD VAlign=top>
+<tt>c_X_assign(&b, &a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>c_X_size(&b) == c_X_size(&a)</tt>.  <tt>b</tt> contains a copy of each of <tt>a</tt>'s elements.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Destructor
+</TD>
+<TD VAlign=top>
+<tt>__c_X(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Each of <tt>a</tt>'s elements is destroyed, and memory allocated for them
+   (if any) is deallocated.
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Beginning of range
+</TD>
+<TD VAlign=top>
+<tt>c_X_begin(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Returns an iterator pointing to the first element in the container. <A href="#7">[7]</A>
+</TD>
+<TD VAlign=top>
+<tt>c_X_begin(&a)</tt> is either dereferenceable or past-the-end.  It is
+   past-the-end if and only if <tt>c_X_size(&a) == 0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+End of range
+</TD>
+<TD VAlign=top>
+<tt>c_X_end(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Returns an iterator pointing one past the last element in the
+   container.
+</TD>
+<TD VAlign=top>
+<tt>c_X_end(&a)</tt> is past-the-end.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Size
+</TD>
+<TD VAlign=top>
+<tt>c_X_size(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Returns the size of the container, that is, its number of elements. <A href="#8">[8]</A>
+</TD>
+<TD VAlign=top>
+<tt>c_X_size(&a) &gt;= 0 &amp;&amp; c_X_size(&a) &lt;= c_X_max_size()</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Maximum size
+</TD>
+<TD VAlign=top>
+<tt>c_X_max_size(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Returns the largest size that this container can ever have. <A href="#8">[8]</A>
+</TD>
+<TD VAlign=top>
+<tt>c_X_max_size(&a) &gt;= 0 &amp;&amp; c_X_max_size(&a) &gt;= c_X_size(&a)</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Empty container
+</TD>
+<TD VAlign=top>
+<tt>c_X_empty(&a)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>c_X_size(&a) == 0</tt>.  (But possibly faster.)
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Swap
+</TD>
+<TD VAlign=top>
+<tt>c_X_swap(&a,&b)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>c_swap(a,b)</tt> <A href="#9">[9]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+The copy constructor, the assignment operator, and the destructor
+   are linear in the container's size.
+<P>
+<tt>begin()</tt> and <tt>end()</tt> are amortized constant time.
+<P>
+<tt>size()</tt> is linear in the
+   container's size. <A href="#10">[10]</A>  <tt>max_size()</tt> and 
+   <tt>empty()</tt> are amortized constant time.  If you are
+   testing whether a container is empty, you should always write
+   <tt>c_X_empty(&c)</tt> instead of <tt>c_X_size(&c) == 0</tt>.  The two expressions are
+   equivalent, but the former may be much faster.
+<P>
+<tt>swap()</tt> is amortized constant time. <A href="#9">[9]</A>
+<h3>Invariants</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Valid range
+</TD>
+<TD VAlign=top>
+For any container <tt>a</tt>, <tt>[c_X_begin(&a), c_X_end(&a))</tt> is a valid
+   range. <A href="#11">[11]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Range size
+</TD>
+<TD VAlign=top>
+<tt>c_X_size(&a)</tt> is equal to the distance from <tt>c_X_begin(&a)</tt> to <tt>c_X_end(&a)</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Completeness
+</TD>
+<TD VAlign=top>
+An algorithm that iterates through the range <tt>[c_X_begin(&a), c_X_end(&a))</tt>
+   will pass through every element of <tt>a</tt>. <A href="#11">[11]</A>
+</TD>
+</tr>
+</table>
+<h3>Models</h3>
+<UL>
+<LI>
+ <A href="Vector.html">vector</A>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The fact that the lifetime of elements cannot exceed that of of
+their container may seem like a severe restriction.  In fact, though,
+it is not.  Note that pointers and iterators are objects; like any
+other objects, they may be stored in a container.  The container, in
+that case, &quot;owns&quot; the pointers themselves, but not the objects that
+they point to.
+<P><A name="2">[2]</A>
+This expression must be a <tt>typedef</tt>, that is, a synonym for
+a type that already has some other name.
+<P><A name="3">[3]</A>
+This may either be a <tt>typedef</tt> for some other type, or else
+a unique type that is defined as a nested class within the class 
+<tt>X</tt>.
+<P><A name="4">[4]</A>
+A container's iterator type and const iterator type may be the
+same: there is no guarantee that every container must have an
+associated mutable iterator type.  For example, <tt><A href="set.html">set</A></tt> and
+<tt><!--<A href="hash_set.html">-->hash_set<!--</A>--></tt> define <tt>iterator</tt> and <tt>const_iterator</tt> to be
+the same type.
+<P><A name="5">[5]</A>
+It is required that the reference type has the same semantics as
+an ordinary C++ reference, but it need not actually be an ordinary C++
+reference.  Some implementations, for example, might provide
+additional reference types to support non-standard memory models.
+Note, however, that &quot;smart references&quot; (user-defined reference types
+that provide additional functionality) are not a viable option.  It is
+impossible for a user-defined type to have the same semantics as C++
+references, because the C++ language does not support redefining the
+member access operator (<tt>operator.</tt>).
+<P><A name="6">[6]</A>
+As in the case of references <A href="#5">[5]</A>, the pointer type must have the
+same semantics as C++ pointers but need not actually be a C++ pointer.
+&quot;Smart pointers,&quot; however, unlike &quot;smart references&quot;, are possible.
+This is because it is possible for user-defined types to define the
+dereference operator and the pointer member access operator, 
+<tt>operator*</tt> and <tt>operator-&gt;</tt>.
+<P><A name="7">[7]</A>
+The iterator type need only be an <i>input iterator</i>, which
+provides a very weak set of guarantees; in particular, all algorithms
+on input iterators must be &quot;single pass&quot;.  It follows that only a single
+iterator into a container may be active at any one time.  This restriction
+is removed in <!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->.
+<P><A name="8">[8]</A>
+In the case of a fixed-size container, <tt>size() == max_size()</tt>.
+<P><A name="9">[9]</A>
+For any <A href="Assignable.html">Assignable</A> type, <A href="swap.html">swap</A> can be defined in terms of
+assignment.  This requires three assignments, each of which, for 
+a container type, is linear in the container's size.  In a sense,
+then, <tt>a.swap(b)</tt> is redundant.  It exists solely for the sake of
+efficiency: for many containers, such as <A href="Vector.html">vector</A> and <A href="List.html">list</A>,
+it is possible to implement <tt>swap</tt> such that its run-time complexity
+is constant rather than linear. <!-- If this is possible for some container
+type <tt>X</tt>, then the template specialization <tt><A href="swap.html">swap</A>(X&amp;, X&amp;)</tt> can
+simply be written in terms of <tt>X::swap(X&amp;)</tt>.  The implication of this
+is that <tt>X::swap(X&amp;)</tt> should <b>only</b> be defined if there exists such
+a constant-time implementation. --> Not every container class <tt>X</tt> need
+have such a member function, but if the member function exists at all then
+it is guaranteed to be amortized constant time.
+<P><A name="10">[10]</A>
+For many containers, such as <tt><A href="Vector.html">vector</A></tt> and <tt><A href="Deque.html">deque</A></tt>, <tt>size</tt> is
+<i>O(1</i>).  This satisfies the requirement that it be <i>O(N</i>).
+<P><A name="11">[11]</A>
+Although <tt>[c_X_begin(&a), c_X_end(&a))</tt> must be a valid range, and must
+include every element in the container, the order in which the elements
+appear in that range is unspecified.  If you iterate through a container
+twice, it is not guaranteed that the order will be the same both
+times.  This restriction is removed in <!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->.
+<h3>See also</h3>
+The <A href="Iterators.html">Iterator overview</A>, <A href="InputIterator.html">Input Iterator</A>, <A href="Sequence.html">Sequence</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<!--<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
+        ALT="[Silicon Surf]"></A>
+<A HREF="index.html"><IMG SRC="stl_home.gif" 
+        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
+<BR>
+<FONT SIZE="-2">
+<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
+1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
+<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
+</FONT>-->
+<P>
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/EqualityComparable.html b/src/tstl2cl/doc/eng/EqualityComparable.html
new file mode 100644
index 0000000..e740848
--- /dev/null
+++ b/src/tstl2cl/doc/eng/EqualityComparable.html
@@ -0,0 +1,197 @@
+<HTML>
+<Head>
+<Title>Equality Comparable</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Equality Comparable</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TD Align=left VAlign=top><b>Category</b>: utilities</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A type is EqualityComparable if objects of that type can be compared for
+equality using <tt>operator==</tt>, and if <tt>operator==</tt> is an equivalence relation.
+<h3>Refinement of</h3>
+<h3>Associated types</h3>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of EqualityComparable
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>, <tt>y</tt>, <tt>z</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Equality
+</TD>
+<TD VAlign=top>
+<tt>x == y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Inequality
+</TD>
+<TD VAlign=top>
+<tt>x != y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Equality
+</TD>
+<TD VAlign=top>
+<tt>x == y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>==</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Inequality
+</TD>
+<TD VAlign=top>
+<tt>x != y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>==</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>!(x == y)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Identity
+</TD>
+<TD VAlign=top>
+<tt>&amp;x == &amp;y</tt> implies <tt>x</tt> == <tt>y</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Reflexivity
+</TD>
+<TD VAlign=top>
+<tt>x == x</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Symmetry
+</TD>
+<TD VAlign=top>
+<tt>x == y</tt> implies <tt>y == x</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Transitivity
+</TD>
+<TD VAlign=top>
+<tt>x == y</tt> and <tt>y == z</tt> implies <tt>x == z</tt>
+</TD>
+</tr>
+</table>
+<h3>Models</h3>
+<UL>
+<LI>
+int
+<LI>
+<tt><A href="Vector.html">vector</A>&lt;int&gt;</tt>
+</UL>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="LessThanComparable.html">LessThanComparable</A>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/ForwardIterator.html b/src/tstl2cl/doc/eng/ForwardIterator.html
new file mode 100644
index 0000000..bf988c3
--- /dev/null
+++ b/src/tstl2cl/doc/eng/ForwardIterator.html
@@ -0,0 +1,207 @@
+<HTML>
+<Head>
+<Title>Forward Iterator</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Forward Iterator</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Forward Iterator is an iterator that corresponds to the usual
+intuitive notion of a linear sequence of values.  It is possible to use
+Forward Iterators (unlike <A href="InputIterator.html">Input Iterators</A> and <A href="OutputIterator.html">Output Iterators</A>)
+in multipass algorithms.  Forward Iterators do not, however, allow
+stepping backwards through a sequence, but only, as the
+name suggests, forward.
+<P>
+A type that is a model of Forward Iterator
+may be either <i>mutable</i> or <i>immutable</i>, as defined in the <!--<A href="trivial.html">-->Trivial Iterators<!--</A>-->
+requirements.
+<h3>Refinement of</h3>
+<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>
+<h3>Associated types</h3>
+The same as for <A href="InputIterator.html">Input Iterator</A>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Forward Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The value type of <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>i</tt>, <tt>j</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>t</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>T</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+<h3>Valid expressions</h3>
+Forward Iterator does not define any new expressions beyond those
+defined in <A href="InputIterator.html">Input Iterator</A>.  However, some of the restrictions
+described in <A href="InputIterator.html">Input Iterator</A> are relaxed.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++i</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>i++</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+Forward Iterator does not define any new expressions beyond those
+defined in <A href="InputIterator.html">Input Iterator</A>.  However, some of the restrictions
+described in <A href="InputIterator.html">Input Iterator</A> are relaxed.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++i</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable
+</TD>
+<TD VAlign=top>
+<tt>i</tt> points to the next value
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end.  <tt>&amp;i == &amp;++i</tt>. If <tt>i == j</tt>, then
+   <tt>++i == ++j</tt>. <A href="#1">[1]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>i++</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>{X tmp = i; ++i; return tmp;}</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end. <A href="#1">[1]</A>
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+The complexity of operations on Forward Iterators is
+guaranteed to be amortized constant time.
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>T*</tt>
+<LI>
+<tt><!--<A href="hash_set.html">-->hash_set<!--</A>-->&lt;T&gt;::iterator</tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The restrictions described in <A href="InputIterator.html">Input Iterator</A> have been
+removed.  Incrementing a forward iterator does not invalidate copies
+of the old value and it is guaranteed that, if <tt>i</tt> and <tt>j</tt> are
+dereferenceable and <tt>i == j</tt>, then <tt>++i == ++j</tt>.  As a consequence
+of these two facts, it is possible to pass through the same 
+Forward Iterator twice.
+<h3>See also</h3>
+<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="BidirectionalIterator.html">Bidirectional Iterator</A>,
+<A href="RandomAccessIterator.html">Random Access Iterator</A>, <A href="Iterators.html">Iterator overview</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/InputIterator.html b/src/tstl2cl/doc/eng/InputIterator.html
new file mode 100644
index 0000000..897b11c
--- /dev/null
+++ b/src/tstl2cl/doc/eng/InputIterator.html
@@ -0,0 +1,283 @@
+<HTML>
+<Head>
+<Title>Input Iterator</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Input Iterator</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+An Input Iterator is an iterator that may be dereferenced to refer to some
+object, and that may be incremented to obtain the next iterator in
+a sequence.  Input Iterators are not required to be mutable.
+<h3>Refinement of</h3>
+<!--<A href="trivial.html">-->Trivial iterator<!--</A>-->. 
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Value type
+</TD>
+<TD VAlign=top>
+The type of the value obtained by dereferencing an Input Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Distance type
+</TD>
+<TD VAlign=top>
+A signed integral type used to represent the distance from one
+   iterator to another, or the number of elements in a range.
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Input Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The value type of <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>i</tt>, <tt>j</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>t</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>T</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+An iterator is <i>past-the-end</i> if it points beyond the last element
+of a container.  Past-the-end values are nonsingular and nondereferenceable.
+<P>
+An iterator is <i>valid</i> if it is dereferenceable or past-the-end.
+<P>
+An iterator <tt>i</tt> is <i>incrementable</i> if there is a
+&quot;next&quot; iterator, that is, if <tt>++i</tt> is well-defined.
+Past-the-end iterators are not incrementable.
+<P>
+An Input Iterator <tt>j</tt> is <i>reachable</i> from an Input
+Iterator <tt>i</tt> if, after applying <tt>operator++</tt> to
+<tt>i</tt> a finite number of times, <tt>i == j</tt>. <A href="#1">[1]</A>
+<P>
+The notation <tt>[i,j)</tt> refers to a <i>range</i> of iterators beginning with
+<tt>i</tt> and up to but not including <tt>j</tt>.
+<P>
+The range <tt>[i,j)</tt> is a <i>valid range</i> if 
+both <tt>i</tt> and <tt>j</tt> are valid iterators, 
+and <tt>j</tt> is reachable from <tt>i</tt> <A href="#2">[2]</A>.
+<h3>Valid expressions</h3>
+In addition to the expressions defined in <!--<A href="trivial.html">-->Trivial Iterator<!--</A>-->,
+the following expressions must be valid.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++i</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>(void)i++</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement and dereference
+</TD>
+<TD VAlign=top>
+<tt>*i++</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Dereference
+</TD>
+<TD VAlign=top>
+<tt>*t</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is incrementable
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++i</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>(void)i++</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>(void)++i</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement and dereference
+</TD>
+<TD VAlign=top>
+<tt>*i++</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>{T t = *i; ++i; return t;}</tt>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+All operations are amortized constant time.
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<!--<A href="istream_iterator.html">-->istream_iterator<!--</A>-->
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+<tt>i == j</tt> does not imply <tt>++i == ++j</tt>.
+<P><A name="2">[2]</A>
+Every iterator in a valid range <tt>[i, j)</tt> is dereferenceable,
+and <tt>j</tt> is either dereferenceable or past-the-end.  The fact
+that every iterator in the range is dereferenceable follows from the fact
+that incrementable iterators must be deferenceable.
+<P><A name="3">[3]</A>
+After executing <tt>++i</tt>, it is not required that copies of the old
+     value of <tt>i</tt> be dereferenceable or that they be in the domain of 
+     <tt>operator==</tt>.
+<P><A name="4">[4]</A>
+It is not guaranteed that it is possible to pass through the same
+     input iterator twice.
+<h3>See also</h3>
+<A href="OutputIterator.html">Output Iterator</A>, <A href="Iterators.html">Iterator overview</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Iterators.html b/src/tstl2cl/doc/eng/Iterators.html
new file mode 100644
index 0000000..498e20e
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Iterators.html
@@ -0,0 +1,220 @@
+<HTML>
+<Head>
+<Title>Iterators</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Iterators</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: overview</TD>
+</TR>
+</Table>
+
+<h3>Summary</h3>
+Iterators are a generalization of pointers: they are
+objects that point to other objects.  As the name suggests, iterators
+are often used to iterate over a range of objects: if an iterator
+points to one element in a range, then it is possible to increment
+it so that it points to the next element.
+<P>
+Iterators are central to generic programming because they are an
+interface between containers and algorithms: algorithms typically
+take iterators as arguments, so a container need only provide a way to
+access its elements using iterators.  This makes it possible to write
+a generic algorithm that operates on many different kinds of
+containers, even containers as different as a <A href="Vector.html">vector</A> and a
+<A href="List.html">doubly linked list</A>.
+<P>
+The STL defines several different concepts related to iterators,
+several predefined iterators, and a collection of types and functions
+for manipulating iterators.
+<h3>Description</h3>
+Iterators are in fact not a single concept, but six concepts that
+form a hierarchy: some of them define only a very restricted set of
+operations, while others define additional functionality.  The 
+five concepts that are actually used by algorithms are
+<A href="InputIterator.html">Input Iterator</A>, <A href="OutputIterator.html">Output Iterator</A>, <A href="ForwardIterator.html">Forward Iterator</A>,
+<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, and <A href="RandomAccessIterator.html">Random Access Iterator</A>.  A sixth
+concept, <!--<A href="trivial.html">-->Trivial Iterator<!--</A>-->, is introduced only to clarify the 
+definitions of the other iterator concepts.
+<P>
+The most restricted sorts of iterators are <A href="InputIterator.html">Input Iterators</A> and
+<A href="OutputIterator.html">Output Iterators</A>, both of which permit &quot;single pass&quot; algorithms
+but do not necessarily support &quot;multi-pass&quot; algorithms.  
+<A href="InputIterator.html">Input iterators</A> only guarantee read access: it is possible to
+dereference an <A href="InputIterator.html">Input Iterator</A> to obtain the value it points to,
+but not it is not necessarily possible to assign a new value through
+an input iterator.  Similarly, <A href="OutputIterator.html">Output Iterators</A> only guarantee
+write access: it is possible to assign a value through an 
+<A href="OutputIterator.html">Output Iterator</A>, but not necessarily possible to refer to that value.
+<P>
+<A href="ForwardIterator.html">Forward Iterators</A> are a refinement of <A href="InputIterator.html">Input Iterators</A> and
+<A href="OutputIterator.html">Output Iterators</A>: they support the <A href="InputIterator.html">Input Iterator</A> and
+<A href="OutputIterator.html">Output Iterator</A> operations and also provide additional
+functionality.  In particular, it is possible to use &quot;multi-pass&quot;
+algorithms with <A href="ForwardIterator.html">Forward Iterators</A>.  A <A href="ForwardIterator.html">Forward Iterator</A> may be
+<i>constant</i>, in which case it is possible to access the object it
+points to but not to to assign a new value through it, or <i>mutable</i>,
+in which case it is possible to do both.
+<P>
+<A href="BidirectionalIterator.html">Bidirectional Iterators</A>, like <A href="ForwardIterator.html">Forward Iterators</A>, allow
+multi-pass algorithms.  As the name suggests, they are different in
+that they support motion in both directions: a 
+<A href="BidirectionalIterator.html">Bidirectional Iterator</A> may be incremented to obtain the next
+element or decremented to obtain the previous element.  A 
+<A href="ForwardIterator.html">Forward Iterator</A>, by contrast, is only required to support forward
+motion.  An iterator used to traverse a singly linked list, for
+example, would be a <A href="ForwardIterator.html">Forward Iterator</A>, while an iterator used to
+traverse a doubly linked list would be a <A href="BidirectionalIterator.html">Bidirectional Iterator</A>.
+<P>
+Finally, <A href="RandomAccessIterator.html">Random Access Iterators</A> allow the operations of
+pointer arithmetic: addition of arbitrary offsets, subscripting,
+subtraction of one iterator from another to find a distance, and
+so on.
+<P>
+Most algorithms are expressed not in terms of a single iterator but in
+terms of a <i>range</i> of iterators <A href="#1">[1]</A>; the notation <tt>[first,
+last)</tt> refers to all of the iterators from <tt>first</tt> up to, but <b>not
+including</b>, <tt>last</tt>. <A href="#2">[2]</A> Note that a range may be empty, <i>i.e.</i>
+<tt>first</tt> and <tt>last</tt> may be the same iterator.  Note also that if there
+are <tt>n</tt> iterators in a range, then the notation <tt>[first, last)</tt>
+represents <tt>n+1</tt> positions.  This is crucial: algorithms that
+operate on <tt>n</tt> things frequently require
+<tt>n+1</tt> positions.  Linear search, for example (<tt><A href="find.html">find</A></tt>) must be able
+to return some value to indicate that the search was unsuccessful.
+<P>
+<!--Sometimes it is important to be able to infer some properties of an
+iterator: the type of object that is returned when it is dereferenced,
+for example.  There are two different mechanisms to support
+this sort of inferrence: an older mechanism called
+<A href="iterator_tags.html">Iterator Tags</A>, and a newer mechanism called <tt><A href="iterator_traits.html">iterator_traits</A></tt>
+<A href="#3">[3]</A>.-->
+<h3>Concepts</h3>
+<UL>
+<LI>
+<!--<A href="trivial.html">-->Trivial Iterator<!--</A>-->
+<LI>
+ <A href="InputIterator.html">Input Iterator</A>
+<LI>
+ <A href="OutputIterator.html">Output Iterator</A>
+<LI>
+ <A href="ForwardIterator.html">Forward Iterator</A>
+<LI>
+ <A href="BidirectionalIterator.html">Bidirectional Iterator</A>
+<LI>
+ <A href="RandomAccessIterator.html">Random Access Iterator</A>
+</UL>
+<!--
+<h3>Types</h3>
+<UL>
+<LI>
+<tt><A href="istream_iterator.html">istream_iterator</A></tt>
+<LI>
+<tt><A href="ostream_iterator.html">ostream_iterator</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="ReverseIterator.html">reverse_iterator</A></tt>
+<LI>
+<tt><A href="ReverseBidirectionalIterator.html">reverse_bidirectional_iterator</A></tt>
+<LI>
+<tt><A href="insert_iterator.html">insert_iterator</A></tt>
+<LI>
+<tt><A href="front_insert_iterator.html">front_insert_iterator</A></tt>
+<LI>
+<tt><A href="back_insert_iterator.html">back_insert_iterator</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="iterator_traits.html">iterator_traits</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="input_iterator_tag.html">input_iterator_tag</A></tt>
+<LI>
+<tt><A href="output_iterator_tag.html">output_iterator_tag</A></tt>
+<LI>
+<tt><A href="forward_iterator_tag.html">forward_iterator_tag</A></tt>
+<LI>
+<tt><A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A></tt>
+<LI>
+<tt><A href="random_access_iterator_tag.html">random_access_iterator_tag</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="input_iterator.html">input_iterator</A></tt>
+<LI>
+<tt><A href="output_iterator.html">output_iterator</A></tt>
+<LI>
+<tt><A href="forward_iterator.html">forward_iterator</A></tt>
+<LI>
+<tt><A href="bidirectional_iterator.html">bidirectional_iterator</A></tt>
+<LI>
+<tt><A href="random_access_iterator.html">random_access_iterator</A></tt>
+</UL>
+-->
+<h3>Functions</h3>
+<UL>
+<LI>
+<tt><!--<A href="distance_type.html">-->distance_type<!--</A>--></tt>
+<LI>
+<tt><!--<A href="value_type.html">-->value_type<!--</A>--></tt>
+<!--<LI>
+<tt><A href="iterator_category.html">iterator_category</A></tt>-->
+</UL>
+<UL>
+<LI>
+<tt><A href="distance.html">distance</A></tt>
+<LI>
+<tt><A href="advance.html">advance</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><!--<A href="insert_iterator.html">-->inserter<!--</A>--></tt>
+<LI>
+<tt><!--<A href="front_insert_iterator.html">-->front_inserter<!--</A>--></tt>
+<LI>
+<tt><!--<A href="back_insert_iterator.html">-->back_inserter<!--</A>--></tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Ranges are not a well-defined concept for <!--<A href="trivial.html">-->Trivial Iterators<!--</A>-->,
+because a <!--<A href="trivial.html">-->Trivial Iterator<!--</A>--> cannot be incremented: there is no such  
+thing as a next element.  They are also not a well-defined concept
+for <A href="OutputIterator.html">Output Iterators</A>, because it is impossible to compare two 
+<A href="OutputIterator.html">Output Iterators</A> for equality.  Equality is crucial to the
+definition of a range, because only by comparing an iterator for
+equality with the last element is it possible to step through a range.
+<P><A name="2">[2]</A>
+Sometimes the notation <tt>[first, last)</tt> refers to the iterators
+<tt>first</tt>, <tt>first+1</tt>, ..., <tt>last-1</tt> and sometimes it refers to the
+objects pointed to by those iterators: <tt>*first</tt>, <tt>*(first+1)</tt>, ...,
+<tt>*(last-1)</tt>.  In most cases it will be obvious from context which of
+these is meant; where the distinction is important, the notation will
+be qualified explicitly as &quot;range of iterators&quot; or &quot;range of objects&quot;.
+<!--<P><A name="3">[3]</A>
+The <tt><A href="iterator_traits.html">iterator_traits</A></tt> class relies on a C++ feature known as
+<i>partial specialization</i>.  Many of today's compilers don't implement
+the complete standard; in particular, many compilers do not support
+partial specialization.  If your compiler does not support partial
+specialization, then you will not be able to use
+<tt><A href="iterator_traits.html">iterator_traits</A></tt>, and you will instead have to continue using the
+functions <tt><A href="iterator_category.html">iterator_category</A></tt>, <tt><A href="distance_type.html">distance_type</A></tt>, and
+<tt><A href="value_type.html">value_type</A></tt>.
+<h3>See also</h3>
+-->
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/LessThanComparable.html b/src/tstl2cl/doc/eng/LessThanComparable.html
new file mode 100644
index 0000000..9930be8
--- /dev/null
+++ b/src/tstl2cl/doc/eng/LessThanComparable.html
@@ -0,0 +1,270 @@
+<HTML>
+<Head>
+<Title>LessThan Comparable</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>LessThan Comparable</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: utilities</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A type is LessThanComparable if it is ordered: it must
+be possible to compare two objects of that type using <tt>operator&lt;</tt>, and
+<tt>operator&lt;</tt> must be a partial ordering.
+<h3>Refinement of</h3>
+<h3>Associated types</h3>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of LessThanComparable
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>, <tt>y</tt>, <tt>z</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+Consider the relation <tt>!(x &lt; y) &amp;&amp; !(y &lt; x)</tt>.  If this relation is
+transitive (that is, if <tt>!(x &lt; y) &amp;&amp; !(y &lt; x) &amp;&amp; !(y &lt; z) &amp;&amp; !(z &lt; y)</tt>
+implies <tt>!(x &lt; z) &amp;&amp; !(z &lt; x)</tt>), then it satisfies the mathematical
+definition of an equivalence relation.  In this case, <tt>operator&lt;</tt>
+is a <i>strict weak ordering</i>.
+<P>
+If <tt>operator&lt;</tt> is a strict weak ordering, and if each equivalence class
+has only a single element, then <tt>operator&lt;</tt> is a <i>total ordering</i>.
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Less
+</TD>
+<TD VAlign=top>
+<tt>x &lt; y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Greater
+</TD>
+<TD VAlign=top>
+<tt>x &gt; y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Less or equal
+</TD>
+<TD VAlign=top>
+<tt>x &lt;= y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Greater or equal
+</TD>
+<TD VAlign=top>
+<tt>x &gt;= y</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Less
+</TD>
+<TD VAlign=top>
+<tt>x &lt; y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>&lt;</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Greater
+</TD>
+<TD VAlign=top>
+<tt>x &gt; y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>&lt;</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>y &lt; x</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Less or equal
+</TD>
+<TD VAlign=top>
+<tt>x &lt;= y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>&lt;</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>!(y &lt; x)</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Greater or equal
+</TD>
+<TD VAlign=top>
+<tt>x &gt;= y</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> and <tt>y</tt> are in the domain of <tt>&lt;</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>!(x &lt; y)</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Irreflexivity
+</TD>
+<TD VAlign=top>
+<tt>x &lt; x</tt> must be false.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Antisymmetry
+</TD>
+<TD VAlign=top>
+<tt>x &lt; y</tt> implies !(y &lt; x) <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Transitivity
+</TD>
+<TD VAlign=top>
+<tt>x &lt; y</tt> and <tt>y &lt; z</tt> implies <tt>x &lt; z</tt> <A href="#3">[3]</A>
+</TD>
+</tr>
+</table>
+<h3>Models</h3>
+<UL>
+<LI>
+int
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Only <tt>operator&lt;</tt> is fundamental; the other inequality operators
+are essentially syntactic sugar.
+<P><A name="2">[2]</A>
+Antisymmetry is a theorem, not an axiom: it follows from
+irreflexivity and transitivity.
+<P><A name="3">[3]</A>
+Because of irreflexivity and transitivity, <tt>operator&lt;</tt> always
+satisfies the definition of a <i>partial ordering</i>.  The definition of
+a <i>strict weak ordering</i> is stricter, and the definition of a
+<i>total ordering</i> is stricter still.
+<h3>See also</h3>
+<A href="EqualityComparable.html">EqualityComparable</A>, <!--<A href="StrictWeakOrdering.html">-->StrictWeakOrdering<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/List.html b/src/tstl2cl/doc/eng/List.html
new file mode 100644
index 0000000..3241556
--- /dev/null
+++ b/src/tstl2cl/doc/eng/List.html
@@ -0,0 +1,850 @@
+<HTML>
+<Head>
+<Title>c_list</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_list</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: containers</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A <tt>list</tt> is a doubly linked list.  That is, it is a
+<!--<A href="Sequence.html">-->Sequence<!--</A>--> that supports both forward and
+backward traversal, and (amortized) constant time insertion and
+removal of elements at the beginning or the end, or in the middle.
+<tt>List</tt>s have the important property that insertion and splicing
+do not invalidate iterators to list elements, and that even removal
+invalidates only the iterators that point to the elements that are
+removed.  The ordering of iterators may be changed (that is,
+<tt>c_iterator</tt> of c_list might have a different predecessor or
+successor after a list operation than it did before), but the
+iterators themselves will not be invalidated or made to point to
+different elements unless that invalidation or mutation is
+explicit. <A href="#1">[1]</A>
+<P>
+Note that singly linked lists, which only support forward traversal,
+are also sometimes useful.  If you do not need backward traversal,
+then <tt><!--<A href="Slist.html">-->slist<!--</A>--></tt> may be more efficient
+than <tt>list</tt>.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_list.h">c_list.h</A>.
+<h3>Example</h3>
+<pre>
+struct student s[10];
+c_list L;
+c_list_create(&L, NULL);
+c_list_push_back(&L, (value_type)&s[0]);
+c_list_push_front(&L, (value_type)&s[1]);
+c_list_insert(&L, c_list_begin(&L), (value_type)&s[3]);
+c_list_destroy(&L);
+</pre>
+<h3>Model of</h3>
+<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->, <!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->, 
+<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<h3>Type requirements</h3>
+None, except for those imposed by the requirements of 
+<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->, <!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->, and
+<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The type of object, <tt>T</tt>, stored in the list.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pointer</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Pointer to <tt>T</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>difference_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+A signed integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Iterator used to iterate through a <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate through a <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Iterator used to iterate backwards through a <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate backwards through a <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_list_begin(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the beginning of the <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_list_end(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the end of the <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_list_rbegin(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
+   reversed list.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_list_rend(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the end of the
+   reversed list.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_list_size(c_plist) const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the size of the <tt>list</tt>.  Note: you should not assume that
+   this function is constant time.  It is permitted to be <i>O(N</i>), 
+   where <i>N</i> is the number of elements in the <tt>list</tt>.  If you wish to
+   test whether a <tt>list</tt> is empty, you should write <tt>c_list_empty(&L)</tt> rather
+   than <tt>c_list_size(&L) == 0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_list_max_size(&L)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the largest possible size of the <tt>list</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_list_empty(&L)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+<tt>true</tt> if the <tt>list</tt>'s size is <tt>0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>__c_list(c_plist, COMPARER) or c_list_create(c_plist, COMPARER) </tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Creates an empty list.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>__c_tsil(c_plist) or c_list_destroy(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The destructor.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_list_assign(c_plist, const c_plist)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The assignment operator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_list_front(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns the first element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_list_back(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns the last element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_push_front(c_plist, const value_type)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts a new element at the beginning.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_push_back(c_plist, const value_type)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts a new element at the end.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_pop_front(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Removes the first element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_pop_back(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Removes the last element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_swap(c_plist, c_plist)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Swaps the contents of two lists.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_list_insert(c_plist, c_iterator pos, const value_type x)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> before <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_list_insert2(c_plist, c_iterator pos, 
+            		c_iterator f, 
+            		c_iterator l)
+<A href="#2">[2]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts the range <tt>[f, l)</tt> before <tt>pos</tt>.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+void insert(iterator pos, 
+            size_type n, const T&amp; x)
+</pre>
+</TD>
+<TD VAlign=top>
+ <A href="Sequence.html">Sequence</A>
+</TD>
+<TD VAlign=top>
+Inserts <tt>n</tt> copies of <tt>x</tt> before <tt>pos</tt>.
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_list_erase(c_plist, c_iterator pos)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element at position <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_list_erase2(c_plist, c_iterator first, c_iterator last)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the range <tt>[first, last)</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_clear(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all of the elements.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<tt>void c_list_resize(c_plist, size_t n)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Sequence.html">Sequence</A>
+</TD>
+<TD VAlign=top>
+Inserts or erases elements at the end such that the size becomes <tt>n</tt>.
+</TD>
+</TR>
+-->`
+<TR>
+<TD VAlign=top>
+<tt>void c_list_splice(c_plist, c_iterator pos, c_plist L)</tt>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_list_splice1(c_plist, c_iterator pos, 
+            		c_plist L,
+            		c_iterator i)
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_list_splice2(c_plist, c_iterator pos,
+            		c_plist L, 
+            		c_iterator f, c_iterator l)
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_remove(c_plist, const value_type value)</tt>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_unique(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_merge(c_plist, c_plist L)</tt>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_sort(c_plist)</tt>
+</TD>
+<TD VAlign=top>
+<tt>list</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_list_equal(c_plist, 
+                	const c_plist L)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Tests two lists for equality.  This is a global function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_list_less(c_plist, 
+			const c_plist L)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Lexicographical comparison.  This is a global function, not
+   a member function.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->, 
+<!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->, and
+<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+requirements, but are specific to <tt>list</tt>.
+<Table border>
+<TR>
+<TH>
+Function
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_list_splice(c_plist, c_iterator position, 
+            		c_plist x);
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>position</tt> must be a valid iterator in <tt>*this</tt>, and <tt>x</tt> must be a list that
+   is distinct from <tt>*this</tt>.  (That is, it is required that
+   <tt>&amp;x != this</tt>.)  All of the elements of <tt>x</tt> are inserted before
+   <tt>position</tt> and removed from <tt>x</tt>.  All iterators remain valid, 
+   including iterators that point to elements of <tt>x</tt>. <A href="#3">[3]</A> This function is 
+   constant time.  
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre> 
+void c_list_splice1(c_plist, c_iterator position, 
+            		c_plist x,
+           	 	c_iterator i);
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>position</tt> must be a valid iterator in <tt>*this</tt>, and <tt>i</tt> must be a
+   dereferenceable iterator in <tt>x</tt>.  <tt>Splice</tt> moves the element
+   pointed to by <tt>i</tt> from <tt>x</tt> to <tt>*this</tt>, inserting it before
+   <tt>position</tt>.  All iterators remain valid, including iterators that point
+   to elements of <tt>x</tt>. <A href="#3">[3]</A>  If <tt>position == i</tt> or <tt>position == ++i</tt>,
+   this function is a null operation.  This function is constant time. 
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre> 
+void c_list_splice2(c_plist, c_iterator position,
+			c_plist x,
+			c_iterator f, c_iterator l);
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>position</tt> must be a valid iterator in <tt>*this</tt>, and <tt>[first, last)</tt>
+   must be a valid range in <tt>x</tt>.  <tt>position</tt> may not be an iterator
+   in the range <tt>[first, last)</tt>.  <tt>Splice</tt> moves the elements 
+   in <tt>[first, last)</tt> from <tt>x</tt> to <tt>*this</tt>, inserting them before
+   <tt>position</tt>.  All iterators remain valid, including iterators that
+   point to elements of <tt>x</tt>. <A href="#3">[3]</A>  This function is constant time. 
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_list_remove(c_plist, const value_type val);</tt>
+</TD>
+<TD VAlign=top>
+Removes all elements that compare equal to <tt>val</tt>.  The relative order
+   of elements that are not removed is unchanged, and iterators to 
+   elements that are not removed remain valid.  This function is 
+   linear time: it performs exactly <tt>size()</tt> comparisons for equality.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<pre>
+template&lt;class <A href="Predicate.html">Predicate</A>&gt; 
+void remove_if(<A href="Predicate.html">Predicate</A> p); 
+<A href="#4">[4]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+Removes all elements <tt>*i</tt> such that <tt>p(*i)</tt> is true.  The relative
+   order of elements that are not removed is unchanged, and iterators to
+   elements that are not removed remain valid.  This function is linear
+   time: it performs exactly <tt>size()</tt> applications of <tt>p</tt>.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>void c_list_unique(c_plist);</tt>
+</TD>
+<TD VAlign=top>
+Removes all but the first element in every consecutive group of
+   equal elements.  The relative order
+   of elements that are not removed is unchanged, and iterators to 
+   elements that are not removed remain valid.  This function is 
+   linear time: it performs exactly <tt>size() - 1</tt> comparisons for equality.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<pre>
+template&lt;class <A href="BinaryPredicate.html">BinaryPredicate</A>&gt;
+void unique(<A href="BinaryPredicate.html">BinaryPredicate</A> p); 
+<A href="#4">[4]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+Removes all but the first element in every consecutive group of
+   equivalent elements, where two elements <tt>*i</tt> and <tt>*j</tt> are considered
+   equivalent if <tt>p(*i, *j)</tt> is true.  The relative order
+   of elements that are not removed is unchanged, and iterators to 
+   elements that are not removed remain valid.  This function is 
+   linear time: it performs exactly <tt>size() - 1</tt> comparisons for
+   equality. 
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>void c_list_merge(c_plist, c_plist x);</tt>
+</TD>
+<TD VAlign=top>
+Both <tt>*this</tt> and <tt>x</tt> must be sorted according to <tt>operator&lt;</tt>, and
+   they must be distinct.
+   (That is, it is required that <tt>&amp;x != this</tt>.)  This function removes
+   all of <tt>x</tt>'s elements and inserts them in order into <tt>*this</tt>.  The merge is
+   stable; that is, if an element from <tt>*this</tt> is equivalent to one from
+   <tt>x</tt>, then the element from <tt>*this</tt> will precede the one from <tt>x</tt>.
+   All iterators to elements in <tt>*this</tt> and <tt>x</tt> remain valid.  
+   This function is linear time:  it performs at most <tt>size() + x.size()
+   - 1</tt> comparisons.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<pre>
+template&lt;class <A href="BinaryPredicate.html">BinaryPredicate</A>&gt;
+void merge(list&lt;T, Alloc&gt;&amp; x, 
+           BinaryPredicate Comp); 
+<A href="#4">[4]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>Comp</tt> must be a comparison function that induces a strict weak
+   ordering (as defined in the <A href="LessThanComparable.html">LessThan Comparable</A> requirements)
+   on objects of type <tt>T</tt>, and both <tt>*this</tt> and <tt>x</tt> must be sorted
+   according to that ordering.  The lists <tt>x</tt> and <tt>*this</tt> must be 
+   distinct.  (That is, it is required that <tt>&amp;x != this</tt>.)
+   This function removes
+   all of <tt>x</tt>'s elements and inserts them in order into <tt>*this</tt>.  The merge is
+   stable; that is, if an element from <tt>*this</tt> is equivalent to one from
+   <tt>x</tt>, then the element from <tt>*this</tt> will precede the one from <tt>x</tt>.
+   All iterators to elements in <tt>*this</tt> and <tt>x</tt> remain valid.  
+   This function is linear time:  it performs at most <tt>size() + x.size()
+   - 1</tt> applications of <tt>Comp</tt>. 
+</TD>
+</TR>
+-->
+<!--
+<TR>
+<TD VAlign=top>
+<tt>void reverse();</tt>
+</TD>
+<TD VAlign=top>
+Reverses the order of elements in the list.  All iterators remain
+   valid and continue to point to the same elements. <A href="#5">[5]</A> This function
+   is linear time.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>void c_list_sort(c_plist);</tt>
+</TD>
+<TD VAlign=top>
+Sorts <tt>*this</tt> according to <tt>operator&lt;</tt>.  The sort is stable, that is,
+   the relative order of equivalent elements is preserved.  
+   All iterators remain 
+   valid and continue to point to the same elements. <A href="#6">[6]</A>  The number
+   of comparisons is approximately <tt>N log N</tt>, where <tt>N</tt> is the <tt>list</tt>'s
+   size.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<pre>
+template&lt;class <A href="BinaryPredicate.html">BinaryPredicate</A>&gt;
+void sort(BinaryPredicate comp); 
+<A href="#4">[4]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>Comp</tt> must be a comparison function that induces a strict weak
+   ordering (as defined in the <A href="LessThanComparable.html">LessThan Comparable</A> requirements
+   on objects of type <tt>T</tt>.  This function sorts the list
+   <tt>*this</tt> according to <tt>Comp</tt>.  The sort is stable, that is,
+   the relative order of equivalent elements is preserved.  
+   All iterators remain 
+   valid and continue to point to the same elements. <A href="#6">[6]</A>  The number
+   of comparisons is approximately <tt>N log N</tt>, where <tt>N</tt> is the <tt>list</tt>'s
+   size.
+</TD>
+</tr>
+-->
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+A comparison with <tt><A href="Vector.html">vector</A></tt> is
+instructive.  Suppose that <tt>i</tt> is a valid
+<tt><A href="Vector.html">vector</A>&lt;T&gt;::iterator</tt>.  If an element
+is inserted or removed in a position that precedes <tt>i</tt>, then
+this operation will either result in <tt>i</tt> pointing to a
+different element than it did before, or else it will invalidate
+<tt>i</tt> entirely.  (A
+<tt><A href="Vector.html">vector</A>&lt;T&gt;::iterator</tt> will be
+invalidated, for example, if an insertion requires a reallocation.)
+However, suppose that <tt>i</tt> and <tt>j</tt> are both iterators
+into a <A href="Vector.html">vector</A>, and there exists some integer
+<tt>n</tt> such that <tt>i == j + n</tt>.  In that case, even if
+elements are inserted into the vector and <tt>i</tt> and <tt>j</tt>
+point to different elements, the relation between the two iterators
+will still hold.  A <tt>list</tt> is exactly the opposite: iterators
+will not be invalidated, and will not be made to point to different
+elements, but, for <tt>list</tt> iterators, the predecessor/successor
+relationship is not invariant.
+<P><A name="2">[2]</A>
+This member function relies on <i>member template</i> functions, which
+at present (early 1998) are not supported by all compilers.  If your
+compiler supports member templates, you can call this function with
+any type of <A href="InputIterator.html">input iterator</A>.  If your
+compiler does not yet support member templates, though, then the
+arguments must either be of type <tt>const value_type*</tt> or of type
+<tt>list::const_iterator</tt>.
+<P><A name="3">[3]</A>
+A similar property holds for all versions of <tt>insert()</tt> and
+<tt>erase()</tt>.  <tt>List&lt;T, Alloc&gt;::insert()</tt> never
+invalidates any iterators, and  <tt>list&lt;T, Alloc&gt;::erase()</tt>
+only invalidates iterators pointing to the elements that are actually
+being erased.
+<P><A name="4">[4]</A>
+This member function relies on <i>member template</i> functions, which
+at present (early 1998) are not supported by all compilers.
+You can only use this member function if your compiler supports
+member templates.
+<P><A name="5">[5]</A>
+If <tt>L</tt> is a list, note that <tt>L.reverse()</tt> and 
+<tt><A href="reverse.html">reverse</A>(L.begin(), L.end())</tt> are both
+correct ways of reversing the list.  They differ in that
+<tt>L.reverse()</tt> will preserve the value that each iterator into
+<tt>L</tt> points to but will not preserve the iterators'
+predecessor/successor relationships, while
+<tt><A href="reverse.html">reverse</A>(L.begin(), L.end())</tt> will not
+preserve the value that each iterator points to but will preserve the
+iterators' predecessor/successor relationships.  Note also that the
+algorithm <tt><A href="reverse.html">reverse</A>(L.begin(), L.end())</tt> 
+will use <tt>T</tt>'s assignment operator, while the 
+member function <tt>L.reverse()</tt> will not.
+<P><A name="6">[6]</A>
+The <tt><A href="sort.html">sort</A></tt> algorithm  works only for 
+<A href="RandomAccessIterator.html">random access iterators</A>.  In
+principle, however, it would be possible to write a sort algorithm
+that also accepted <A href="BidirectionalIterator.html">bidirectional iterators</A>.
+Even if there were such a version of
+<tt><A href="sort.html">sort</A></tt>, it would still be useful for
+<tt>list</tt> to have a <tt>sort</tt> member function.  That is,
+<tt>sort</tt> is provided as a member function not only for the sake
+of efficiency, but also because of the property that it preserves the
+values that list iterators point to.
+<h3>See also</h3>
+<!--<A href="BidirectionalIterator.html">Bidirectional Iterator</A>,
+<A href="ReversibleContainer.html">Reversible Container</A>,
+<A href="Sequence.html">Sequence</A>,
+<tt><A href="Slist.html">slist</A></tt>
+-->
+<tt><A href="Vector.html">vector</A></tt>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<P>
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Map.html b/src/tstl2cl/doc/eng/Map.html
new file mode 100644
index 0000000..547f9fc
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Map.html
@@ -0,0 +1,615 @@
+<HTML>
+<Head>
+<Title>c_map</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_map</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: containers</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Map</tt> is a <!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>--> that associates objects of
+type <tt>Key</tt> with objects of type <tt>Data</tt>.  <tt>Map</tt> is a 
+<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->, meaning that its value type is
+<tt><A href="pair.html">c_pair</A></tt>.  It is also a 
+<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->, meaning that no two elements have
+the same key.
+<P>
+<tt>Map</tt> has the important property that inserting a new element
+into a <tt>map</tt> does not invalidate iterators that point to existing
+elements.  Erasing an element from a <tt>map</tt> also does not invalidate
+any iterators, except, of course, for iterators that actually point 
+to the element that is being erased.
+<h3>Example</h3>
+<pre>
+
+struct key
+{
+	int k;
+};
+
+int key_comparer(value_type x, value_type y)
+{
+	return ((struct key *)(x))->k - ((struct key *)(y))->k;
+}
+
+c_pair pair_ary[] = 
+{
+	{ 0, 0 }
+};
+
+int main()
+{
+	c_map map;
+	struct key * pkey = malloc(size_of(struct key));
+	pkey->k = 0xf;
+	pair_ary[0].first = pkey;
+	c_map_create(&map, key_comparer);
+	c_map_insert(&map, &pair_ary[0]);
+	c_map_destroy(&map);
+	free(pkey);
+}
+
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_map.h">c_map.h</A>.
+<h3>Model of</h3>
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, <!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
+<h3>Type requirements</h3>
+<UL>
+<LI>
+<tt>Data</tt> is <A href="Assignable.html">Assignable</A>.
+<LI>
+<tt>Compare</tt> is a <!--<A href="StrictWeakOrdering.html">-->Strict Weak Ordering<!--</A>--> whose argument type
+   is <tt>Key</tt>.
+<LI>
+<tt>Alloc</tt> is an <!--<A href="Allocators.html">-->Allocator<!--</A>-->.
+</UL>
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>key_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+The <tt>map</tt>'s key type, <tt>Key</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>data_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of object associated with the keys.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of object, <tt>pair&lt;const key_type, data_type&gt;</tt>, stored in the map.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>key_compare</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+ <A href="functors.html">Function object</A> that compares two keys for ordering.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_compare</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+ <A href="functors.html">Function object</A> that compares two values for ordering.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pointer</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Pointer to <tt>T</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>difference_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+A signed integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Iterator used to iterate through a <tt>map</tt>. <A href="#1">[1]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate through a <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Iterator used to iterate backwards through a <tt>map</tt>. <A href="#1">[1]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate backwards through a <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_map_begin(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the beginning of the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_map_end(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the end of the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_map_rbegin(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
+   reversed map.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_map_rend(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the end of the
+   reversed map.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_map_size(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the size of the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_map_max_size(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the largest possible size of the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_map_empty(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+<tt>true</tt> if the <tt>map</tt>'s size is <tt>0</tt>.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<tt>key_compare key_comp() const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Returns the <tt>key_compare</tt> object used by the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_compare value_comp() const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Returns the <tt>value_compare</tt> object used by the <tt>map</tt>.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>__c_map(c_pmap, COMPARER) or c_map_create(c_pmap, COMPARER)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Creates an empty <tt>map</tt>, using <tt>comp</tt> as the <tt>key_compare</tt> object.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_pmap c_map_assign(c_pmap, const c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The assignment operator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_map_swap(c_pmap, c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Swaps the contents of two maps.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iter_bool_pair
+c_map_insert(c_pmap, const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> into the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iterator c_map_insert1(c_pmap, c_iterator pos,
+                		const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> into the <tt>map</tt>, using <tt>pos</tt> as a hint to where it will be
+   inserted.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_map_insert2(c_pmap, c_iterator, c_iterator)
+<A href="#2">[2]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts a range into the <tt>map</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_map_erase(c_pmap, c_iterator pos)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element pointed to by <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_map_erase1(c_pmap, const key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_map_erase2(c_pmap, c_iterator first, c_iterator last)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all elements in a range.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_map_clear(c_pmap)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all of the elements.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_map_find(c_pmap, const key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds an element whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_map_count(c_pmap, const key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Counts the number of elements whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_map_lower_bound(c_pmap, const key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds the first element whose key is not less than <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_map_upper_bound(c_pmap, const key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds the first element whose key greater than <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iter_iter_pair
+c_map_equal_range(c_pmap, const key_type k)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds a range containing all elements whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+value_type c_map_at(c_pmap, const key_type k) <A href="#3">[3]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>map</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_map_equal(c_pmap, c_pmap, COMPARER)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Tests two maps for equality.  This is a global function, not
+   a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_map_less(c_pmap, c_pmap, COMPARER)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Lexicographical comparison.  This is a global function, not
+   a member function.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>--> and <!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->
+requirements, but are unique to <tt>map</tt>:
+<Table border>
+<TR>
+<TH>
+Member function
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+value_type c_map_at(c_pmap, key_type k) <A href="#3">[3]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+Returns a reference to the object that is associated with
+   a particular key.  If the <tt>map</tt> does not already contain such
+   an object, <tt>operator[]</tt> inserts the default object <tt>data_type()</tt>. <A href="#3">[3]</A>
+</TD>
+</tr>
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+<tt>Map::iterator</tt> is not a mutable iterator, because
+<tt>map::value_type</tt> is not <A href="Assignable.html">Assignable</A>.  That is, if <tt>i</tt> is of
+type <tt>map::iterator</tt> and <tt>p</tt> is of type
+<tt>map::value_type</tt>, then <tt>*i = p</tt> is not a valid
+expression.  However, <tt>map::iterator</tt> isn't a constant iterator
+either, because it can be used to modify the object that it points to.
+Using the same notation as above, <tt>(*i).second = p</tt> is a valid
+expression.  The same point applies to <tt>map::reverse_iterator</tt>.
+<P><A name="2">[2]</A>
+This member function relies on <i>member template</i> functions, which
+at present (early 1998) are not supported by all compilers.  If your
+compiler supports member templates, you can call this function with
+any type of <A href="InputIterator.html">input iterator</A>.  If your
+compiler does not yet support member templates, though, then the
+arguments must either be of type <tt>const value_type*</tt> or of type
+<tt>map::const_iterator</tt>.
+<P><A name="3">[3]</A>
+Since <tt>operator[]</tt> might insert a new element into the <tt>map</tt>,
+it can't possibly be a <tt>const</tt> member function.  Note that the 
+definition of <tt>operator[]</tt> is extremely simple: <tt>m[k]</tt> is equivalent
+to <tt>(*((m.insert(value_type(k, data_type()))).first)).second</tt>.
+Strictly speaking, this member function is unnecessary: it exists
+only for convenience.
+<h3>See also</h3>
+<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->, <!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->, 
+<!--<A href="PairAssociativeContainer.html">-->Pair Associative Container<!--</A>-->, <!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
+<tt><A href="set.html">set</A></tt>
+<!--
+<tt><A href="multiset.html">multiset</A></tt>, <tt><A href="Multimap.html">multimap</A></tt>,
+<tt><A href="hash_set.html">hash_set</A></tt>, <tt><A href="hash_map.html">hash_map</A></tt>, 
+<tt><A href="hash_multiset.html">hash_multiset</A></tt>, <tt><A href="hash_multimap.html">hash_multimap</A></tt>,
+-->
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/OutputIterator.html b/src/tstl2cl/doc/eng/OutputIterator.html
new file mode 100644
index 0000000..11ada08
--- /dev/null
+++ b/src/tstl2cl/doc/eng/OutputIterator.html
@@ -0,0 +1,398 @@
+<HTML>
+<Head>
+<Title>Output Iterator</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Output Iterator</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+An Output Iterator is a type that provides a mechanism for storing
+(but not necessarily accessing) a sequence of values.  Output
+Iterators are in some sense the converse of <A href="InputIterator.html">Input Iterators</A>, but
+they have a far more restrictive interface: they do not necessarily support
+member access or equality, and they do not necessarily have either an
+associated distance type or even a value type <A href="#1">[1]</A>.  Intuitively, one
+picture of an Output Iterator is a tape: you can write a value to the
+current location and you can advance to the next location, but you
+cannot read values and you cannot back up or rewind.
+<h3>Refinement of</h3>
+<A href="Assignable.html">Assignable</A>, <!--<A href="DefaultConstructible.html">-->DefaultConstructible<!--</A>-->
+<h3>Associated types</h3>
+None. <A href="#1">[1]</A>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Output Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>, <tt>y</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+If <tt>x</tt> is an Output Iterator of type <tt>X</tt>, then the expression <tt>*x =
+t;</tt> stores the value <tt>t</tt> into <tt>x</tt>.  Note that <tt>operator=</tt>, like other
+C++ functions, may be overloaded; it may, in fact, even be a template
+function.  In general, then, <tt>t</tt> may be any of several different
+types.  A type <tt>T</tt> belongs to the <i>set of value types</i> of <tt>X</tt> 
+if, for an object <tt>t</tt> of type <tt>T</tt>, <tt>*x = t;</tt> is well-defined and
+does not require performing any non-trivial conversions on <tt>t</tt>. <A href="#1">[1]</A>
+<P>
+An Output Iterator may be <i>singular</i>, meaning that the results of
+most operations, including copying and dereference assignment, are
+undefined.  The only operation that is guaranteed to be supported is
+assigning a nonsingular iterator to a singular iterator.
+<P>
+An Output Iterator may be <i>dereferenceable</i>, meaning that 
+assignment through it is defined.  Dereferenceable iterators are always
+nonsingular, but nonsingular iterators are not necessarily 
+dereferenceable.
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Default constructor
+</TD>
+<TD VAlign=top>
+<pre>
+X x;
+X()
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X y(x);</tt> or <tt>X y = x;</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Dereference assignment
+</TD>
+<TD VAlign=top>
+<tt>*x = t</tt>
+</TD>
+<TD VAlign=top>
+<tt>t</tt> is convertible to a type in the set of value types of <tt>X</tt>. <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+Result is not used
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++x</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>(void) x++</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>void</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement and assign
+</TD>
+<TD VAlign=top>
+<tt>*x++ = t;</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Result is not used
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Default constructor
+</TD>
+<TD VAlign=top>
+<pre>
+X x;
+X()
+</pre>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>x</tt> may be singular
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X(x)</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is nonsingular
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>*X(x) = t</tt> is equivalent to <tt>*x = t</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Copy constructor
+</TD>
+<TD VAlign=top>
+<tt>X x(y);</tt> or <tt>X x = y;</tt>
+</TD>
+<TD VAlign=top>
+<tt>y</tt> is nonsingular
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>*y = t</tt> is equivalent to <tt>*x = t</tt> <A href="#2">[2]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Dereference assignment
+</TD>
+<TD VAlign=top>
+<tt>*x = t</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is dereferenceable.  If there has been a previous assignment through
+   <tt>x</tt>, then there has been an intervening increment. <A href="#3">[3]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Preincrement
+</TD>
+<TD VAlign=top>
+<tt>++x</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is dereferenceable.  <tt>x</tt> has previously been assigned through.
+   If <tt>x</tt> has previously been incremented, then there has been an
+   intervening assignment through <tt>x</tt> <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>x</tt> points to the next location into which a value may be stored
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement
+</TD>
+<TD VAlign=top>
+<tt>(void) x++</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is dereferenceable.  <tt>x</tt> has previously been assigned through.
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>(void) ++x</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> points to the next location into which a value may be stored
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Postincrement and assign
+</TD>
+<TD VAlign=top>
+<tt>*x++ = t;</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is dereferenceable.  If there has been a previous assignment through
+   <tt>x</tt>, then there has been an intervening increment.  <A href="#3">[3]</A> <A href="#4">[4]</A>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>{*x = t; ++x; }</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> points to the next location into which a value may be stored
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+The complexity of operations on output iterators is
+guaranteed to be amortized constant time.
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<!--<A href="ostream_iterator.html">-->ostream_iterator<!--</A>-->
+<LI>
+<!--<A href="insert_iterator.html">-->insert_iterator<!--</A>-->
+<LI>
+<!--<A href="front_insert_iterator.html">-->front_insert_iterator<!--</A>-->
+<LI>
+<!--<A href="back_insert_iterator.html">-->back_insert_iterator<!--</A>-->
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Other iterator types, including <!--<A href="trivial.html">-->Trivial Iterator<!--</A>--> and
+<A href="InputIterator.html">Input Iterator</A>, define the notion of a <i>value type</i>, the type returned
+when an iterator is dereferenced.  This notion does not apply to
+Output Iterators, however, since the dereference operator (unary
+<tt>operator*</tt>) does not return a usable value for Output Iterators.  The
+only context in which the dereference operator may be used is
+assignment through an output iterator: <tt>*x = t</tt>.  Although 
+<A href="InputIterator.html">Input Iterators</A> and output iterators are roughly symmetrical concepts,
+there is an important sense in which accessing and storing values are
+not symmetrical: for an <A href="InputIterator.html">Input Iterator</A> <tt>operator*</tt> must return a
+unique type, but, for an Output Iterator, in the expression <tt>*x = t</tt>,
+there is no reason why <tt>operator=</tt> must take a unique type.  <A href="#5">[5]</A>
+Consequently, there need not be any unique &quot;value type&quot; for Output Iterators.
+<P><A name="2">[2]</A>
+There should be only one active copy of a single Output Iterator at
+any one time.  That is: after creating and using a copy <tt>x</tt> of 
+an Output Iterator <tt>y</tt>, the original output iterator <tt>y</tt> should no
+longer be used.
+<P><A name="3">[3]</A>
+Assignment through an Output Iterator <tt>x</tt> is expected to alternate with
+incrementing <tt>x</tt>, and there must be an assignment through <tt>x</tt> before
+<tt>x</tt> is ever incremented.  Any other order of operations results in
+undefined behavior.  That is: <tt>{*x = t</tt>; ++x; *x = t2; ++x}<tt> is 
+acceptable, but </tt>{*x = t<tt>; ++x; ++x; *x = t2;}</tt> is not.
+<P><A name="4">[4]</A>
+Note that an Output Iterator need not define comparison for equality.
+Even if an <tt>operator==</tt> is defined, <tt>x == y</tt> need not imply
+<tt>++x == ++y</tt>.
+<P><A name="5">[5]</A>
+If you are implementing an Output Iterator class <tt>X</tt>, one
+sensible way to define <tt>*x = t</tt> is to define <tt>X::operator*()</tt> to
+return an object of some private class <tt>X_proxy</tt>, and then to define
+<tt>X_proxy::operator=</tt>.  Note that you may overload
+<tt>X_proxy::operator=</tt>, or even define it as a member template; this
+allows assignment of more than one type through Output Iterators of
+class <tt>X</tt>.
+<h3>See also</h3>
+<!--<A href="trivial.html">-->Trivial Iterator<!--</A>-->, <A href="InputIterator.html">Input Iterator</A>, <A href="Iterators.html">Iterator overview</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Predicate.html b/src/tstl2cl/doc/eng/Predicate.html
new file mode 100644
index 0000000..104268c
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Predicate.html
@@ -0,0 +1,161 @@
+<HTML>
+<Head>
+<Title>Predicate</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Predicate</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Predicate is a <A href="UnaryFunction.html">Unary Function</A> whose result represents the truth or
+falsehood of some condition.  A Predicate might, for example, be a
+function that takes an argument of type <tt>int</tt> and returns <tt>true</tt> if the
+argument is positive.
+<h3>Refinement of</h3>
+<A href="UnaryFunction.html">Unary Function</A>
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Result type
+</TD>
+<TD VAlign=top>
+The type returned when the Predicate is called.  The result type
+   must be convertible to <tt>bool</tt>.  
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>F</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Predicate
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+The argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>f</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>bool</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x)</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is in the domain of <tt>f</tt>.
+</TD>
+<TD VAlign=top>
+Returns <tt>true</tt> if the condition is satisfied, <tt>false</tt> if it is not.
+</TD>
+<TD VAlign=top>
+The result is either <tt>true</tt> or <tt>false</tt>.
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>c_bool (*)(value_type)</tt>
+</UL>
+<h3>Notes</h3>
+<h3>See also</h3>
+<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->, <A href="BinaryPredicate.html">Binary Predicate</A>, <!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Queue.html b/src/tstl2cl/doc/eng/Queue.html
new file mode 100644
index 0000000..3a0929a
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Queue.html
@@ -0,0 +1,355 @@
+<HTML>
+<Head>
+<Title>c_queue</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_queue</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: containers, adaptors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A <tt>queue</tt> is an adaptor that provides a restricted subset of
+<A href="Container.html">Container</A> functionality
+A <tt>queue</tt> is a &quot;first in first out&quot; (FIFO) data structure.  <A href="#1">[1]</A> That is,
+elements are added to the back of the <tt>queue</tt> and may be removed
+from the front;
+<tt>Q.front()</tt> is the element that was added to the <tt>queue</tt> least recently.
+<tt>Queue</tt> does not allow iteration through its elements.  <A href="#2">[2]</A>
+<P>
+<tt>Queue</tt> is a container adaptor, meaning that it is implemented on
+top of some underlying container type.  By default that underlying
+type is <tt><!--<A href="Deque.html">-->deque<!--</A>--></tt>, but a different type may be selected explicitly.
+<h3>Example</h3>
+<pre>
+int main() {
+	c_queue Q;
+	c_queue_create(&Q, NULL);
+	c_queue_push(&Q, 0);
+	c_queue_destroy(&Q);
+}
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_queue.h">c_queue.h</A>.
+<h3>Model of</h3>
+<A href="Assignable.html">Assignable</A>, <!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+<h3>Type requirements</h3>
+<UL>
+<LI>
+<tt>T</tt> is a model of <A href="Assignable.html">Assignable</A>.
+<LI>
+<tt>Sequence</tt> is a model of <!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>-->.
+<LI>
+<tt>Sequence</tt> is a model of <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<LI>
+<tt>Sequence::value_type</tt> is the same type as <tt>T</tt>.
+<LI>
+If <tt>operator==</tt> is used, then <tt>T</tt> is a model of
+<!--<A href="EqualityComparable.html">-->Equality Comparable<!--</A>-->
+<LI>
+If <tt>operator&lt;</tt> is used, then <tt>T</tt> is a model of <!--<A href="LessThanComparable.html">-->LessThan Comparable<!--</A>-->.
+</UL>
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>__c_queue(c_pqueue, COMPARER) or c_queue_create(c_pqueue, COMPARER)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+</TD>
+<TD VAlign=top>
+The default constructor.  Creates an empty <tt>queue</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_pqueue c_queue_assign(c_pqueue, const c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Assignable.html">Assignable</A>
+</TD>
+<TD VAlign=top>
+The assignment operator.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_empty(c_pqueue) </tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_queue_size(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_queue_front(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_queue_back(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_queue_push(c_pqueue, const value_type)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_queue_pop(c_pqueue)</tt> <A href="#3">[3]</A>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_equal(c_pqueue, const c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_less(c_pqueue, const c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+<tt>queue</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<A href="Assignable.html">Assignable</A> and <!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+requirements, but are specific to 
+<tt>queue</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+The type of object stored in the <tt>queue</tt>.  This is the same as
+   <tt>T</tt> and <tt>Sequence::value_type</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.  This is the same as <tt>Sequence::size_type</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_empty(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Returns <tt>true</tt> if the <tt>queue</tt> contains no elements, and <tt>false</tt>
+   otherwise.  <tt>Q.empty()</tt> is equivalent to <tt>Q.size() == 0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_queue_size(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Returns the number of elements contained in the <tt>queue</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_queue_front(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Returns a mutable reference to the element at the front of the
+   queue, that is, the element least recently inserted.
+   Precondition: <tt>empty()</tt> is <tt>false</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_queue_back(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Returns a mutable reference to the element at the back of the
+   queue, that is, the element most recently inserted.
+   Precondition: <tt>empty()</tt> is <tt>false</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_queue_push(c_pqueue, const value_type x)</tt>
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> at the back of the queue.  Postconditions: <tt>size()</tt> will
+   be incremented by <tt>1</tt>, and <tt>back()</tt> will be equal to <tt>x</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_queue_pop(c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Removes the element at the front of the queue. <A href="#3">[3]</A>  Precondition:
+   <tt>empty()</tt> is <tt>false</tt>.  Postcondition: <tt>size()</tt> will be decremented
+   by <tt>1</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_equal(c_pqueue, const c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Compares two queues for equality.  Two queues are equal if they
+   contain the same number of elements and if they are equal
+   element-by-element.  This is a global function, not a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_queue_less(c_pqueue, const c_pqueue)</tt>
+</TD>
+<TD VAlign=top>
+Lexicographical ordering of two queues.
+  This is a global function, not a member function.
+</TD>
+</tr>
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Queues are a standard data structure, and are discussed in all
+algorithm books.  See, for example, section 2.2.1 of Knuth.
+(D. E. Knuth, <i>The Art of Computer
+Programming.  Volume 1: Fundamental Algorithms</i>, second edition.  
+Addison-Wesley, 1973.)
+<P><A name="2">[2]</A>
+This restriction is the only reason for <tt>queue</tt> to exist at all.
+Any container that is both a <!--<A href="FrontInsertionSequence.html">-->front insertion sequence<!--</A>--> and a
+<!--<A href="BackInsertionSequence.html">-->back insertion sequence<!--</A>--> can be used as a queue; <tt><!--<A href="Deque.html">-->deque<!--</A>--></tt>, for
+example, has member functions <tt>front</tt>, <tt>back</tt>, <tt>push_front</tt>,
+<tt>push_back</tt>, <tt>pop_front</tt>, and <tt>pop_back</tt> The only reason to use the
+container adaptor <tt>queue</tt> instead of the container <tt><!--<A href="Deque.html">-->deque<!--</A>--></tt> is to
+make it clear that you are performing only queue operations, and no
+other operations.
+<P><A name="3">[3]</A>
+One might wonder why <tt>pop()</tt> returns <tt>void</tt>, instead of
+<tt>value_type</tt>.  That is, why must one use <tt>front()</tt> and <tt>pop()</tt> to
+examine and remove the element at the front of the <tt>queue</tt>, instead of
+combining the two in a single member function?  In fact, there is a
+good reason for this design.  If <tt>pop()</tt> returned the front element, it
+would have to return by value rather than by reference: return by
+reference would create a dangling pointer.  Return by value, however,
+is inefficient: it involves at least one redundant copy constructor
+call.  Since it is impossible for <tt>pop()</tt> to return a value in such a
+way as to be both efficient and correct, it is more sensible for it to
+return no value at all and to require clients to use <tt>front()</tt> to
+inspect the value at the front of the <tt>queue</tt>.
+<h3>See also</h3>
+<tt><A href="stack.html">stack</A></tt>, <!--<tt><A href="priority_queue.html">priority_queue</A></tt>, <tt><A href="Deque.html">deque</A></tt>,--> <A href="Container.html">Container</A><!--, <A href="Sequence.html">Sequence</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/RandomAccessIterator.html b/src/tstl2cl/doc/eng/RandomAccessIterator.html
new file mode 100644
index 0000000..7bba763
--- /dev/null
+++ b/src/tstl2cl/doc/eng/RandomAccessIterator.html
@@ -0,0 +1,465 @@
+<HTML>
+<Head>
+<Title>Random Access Iterator</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Random Access Iterator</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Random Access Iterator is an iterator that provides both
+increment and decrement (just like a <A href="BidirectionalIterator.html">Bidirectional Iterator</A>),
+and that also provides constant-time methods for moving forward
+and backward in arbitrary-sized steps.  Random Access Iterators
+provide essentially all of the operations of ordinary
+C pointer arithmetic.
+<h3>Refinement of</h3>
+<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, <A href="LessThanComparable.html">LessThan Comparable</A>
+<h3>Associated types</h3>
+The same as for <A href="BidirectionalIterator.html">Bidirectional Iterator</A>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Random Access Iterator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The value type of <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Distance</tt>
+</TD>
+<TD VAlign=top>
+The distance type of <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>i</tt>, <tt>j</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>t</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>T</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>n</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>Distance</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+<h3>Valid expressions</h3>
+In addition to the expressions defined in <A href="BidirectionalIterator.html">Bidirectional Iterator</A>,
+the following expressions must be valid.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator addition
+</TD>
+<TD VAlign=top>
+<tt>i += n</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator addition
+</TD>
+<TD VAlign=top>
+<tt>i + n</tt> or <tt>n + i</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator subtraction
+</TD>
+<TD VAlign=top>
+<tt>i -= n</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X&amp;</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator subtraction
+</TD>
+<TD VAlign=top>
+<tt>i - n</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Difference
+</TD>
+<TD VAlign=top>
+<tt>i - j</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>Distance</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Element operator
+</TD>
+<TD VAlign=top>
+<tt>i[n]</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+Convertible to <tt>T</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Element assignment
+</TD>
+<TD VAlign=top>
+<tt>i[n] = t</tt>
+</TD>
+<TD VAlign=top>
+<tt>X</tt> is mutable
+</TD>
+<TD VAlign=top>
+Convertible to <tt>T</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+Semantics of an expression is defined only where it differs from,
+or is not defined in, <A href="BidirectionalIterator.html">Bidirectional Iterator</A> or 
+<A href="LessThanComparable.html">LessThan Comparable</A>.
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Forward motion
+</TD>
+<TD VAlign=top>
+<tt>i += n</tt>
+</TD>
+<TD VAlign=top>
+Including <tt>i</tt> itself, there must be <tt>n</tt> dereferenceable or
+   past-the-end iterators following or preceding <tt>i</tt>, depending
+   on whether <tt>n</tt> is positive or negative.
+</TD>
+<TD VAlign=top>
+If <tt>n &gt; 0</tt>, equivalent to executing <tt>++i</tt> <tt>n</tt> times.  If <tt>n &lt; 0</tt>,
+   equivalent to executing <tt>--i</tt> <tt>n</tt> times.  If <tt>n == 0</tt>, this is
+   a null operation. <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator addition
+</TD>
+<TD VAlign=top>
+<tt>i + n</tt> or <tt>n + i</tt>
+</TD>
+<TD VAlign=top>
+Same as for <tt>i += n</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>{ X tmp = i; return tmp += n; }</tt>.  The two forms
+   <tt>i + n</tt> and <tt>n + i</tt> are identical.
+</TD>
+<TD VAlign=top>
+Result is dereferenceable or past-the-end
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator subtraction
+</TD>
+<TD VAlign=top>
+<tt>i -= n</tt>
+</TD>
+<TD VAlign=top>
+Including <tt>i</tt> itself, there must be <tt>n</tt> dereferenceable or
+   past-the-end iterators preceding  or following <tt>i</tt>, depending
+   on whether <tt>n</tt> is positive or negative.
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>i += (-n)</tt>.
+</TD>
+<TD VAlign=top>
+<tt>i</tt> is dereferenceable or past-the-end.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Iterator subtraction
+</TD>
+<TD VAlign=top>
+<tt>i - n</tt>
+</TD>
+<TD VAlign=top>
+Same as for <tt>i -= n</tt>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>{ X tmp = i; return tmp -= n; }</tt>.
+</TD>
+<TD VAlign=top>
+Result is dereferenceable or past-the-end
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Difference
+</TD>
+<TD VAlign=top>
+<tt>i - j</tt>
+</TD>
+<TD VAlign=top>
+Either <tt>i</tt> is reachable from <tt>j</tt> or <tt>j</tt> is reachable from <tt>i</tt>, or both.
+</TD>
+<TD VAlign=top>
+Returns a number <tt>n</tt> such that <tt>i == j + n</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Element operator
+</TD>
+<TD VAlign=top>
+<tt>i[n]</tt>
+</TD>
+<TD VAlign=top>
+<tt>i + n</tt> exists and is dereferenceable.
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>*(i + n)</tt> <A href="#2">[2]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Element assignment
+</TD>
+<TD VAlign=top>
+<tt>i[n] = t</tt>
+</TD>
+<TD VAlign=top>
+<tt>i + n</tt> exists and is dereferenceable.
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>*(i + n) = t</tt> <A href="#2">[2]</A>
+</TD>
+<TD VAlign=top>
+<tt>i[n]</tt> is a copy of <tt>t</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Less
+</TD>
+<TD VAlign=top>
+<tt>i &lt; j</tt>
+</TD>
+<TD VAlign=top>
+Either <tt>i</tt> is reachable from <tt>j</tt> or <tt>j</tt> is reachable from <tt>i</tt>, or both. <A href="#3">[3]</A>
+</TD>
+<TD VAlign=top>
+As described in <A href="LessThanComparable.html">LessThan Comparable</A> <A href="#4">[4]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+All operations on Random Access Iterators are amortized constant
+time. <A href="#5">[5]</A>
+<h3>Invariants</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Symmetry of addition and subtraction
+</TD>
+<TD VAlign=top>
+If <tt>i + n</tt> is well-defined, then <tt>i += n; i -= n;</tt> and <tt>(i + n) - n</tt>
+   are null operations.  Similarly, if <tt>i - n</tt> is well-defined, 
+   then <tt>i -= n; i += n;</tt> and <tt>(i - n) + n</tt> are null operations.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Relation between distance and addition
+</TD>
+<TD VAlign=top>
+If <tt>i - j</tt> is well-defined, then <tt>i == j + (i - j)</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Reachability and distance
+</TD>
+<TD VAlign=top>
+If <tt>i</tt> is reachable from <tt>j</tt>, then <tt>i - j &gt;= 0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Ordering
+</TD>
+<TD VAlign=top>
+<tt>operator &lt;</tt> is a strict weak ordering, as defined in
+   <A href="LessThanComparable.html">LessThan Comparable</A>.
+</TD>
+</tr>
+</table>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>T*</tt>
+<LI>
+<tt><A href="Vector.html">vector</A>&lt;T&gt;::iterator</tt>
+<LI>
+<tt><A href="Vector.html">vector</A>&lt;T&gt;::const_iterator</tt>
+<LI>
+<tt><!--<A href="Deque.html">-->deque<!--</A>-->&lt;T&gt;::iterator</tt>
+<LI>
+<tt><!--<A href="Deque.html">-->deque<!--</A>-->&lt;T&gt;::const_iterator</tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+&quot;Equivalent to&quot; merely means that <tt>i += n</tt> yields the same iterator
+as if <tt>i</tt> had been incremented (decremented) <tt>n</tt> times.  It does
+not mean that this is how <tt>operator+=</tt> should be implemented; in fact,
+this is not a permissible implementation.  It is guaranteed that <tt>i += n</tt>
+is amortized constant time, regardless of the magnitude of <tt>n</tt>. <A href="#5">[5]</A>
+<P><A name="2">[2]</A>
+One minor syntactic oddity: in C, if <tt>p</tt> is a pointer and
+<tt>n</tt> is an int, then <tt>p[n]</tt> and <tt>n[p]</tt> are equivalent.  This equivalence
+is not guaranteed, however, for Random Access Iterators:  only 
+<tt>i[n]</tt> need be supported.  This isn't a terribly important restriction,
+though, since the equivalence of <tt>p[n]</tt> and <tt>n[p]</tt> has essentially
+no application except for obfuscated C contests.
+<P><A name="3">[3]</A>
+The precondition defined in <A href="LessThanComparable.html">LessThan Comparable</A> is that <tt>i</tt>
+and <tt>j</tt> be in the domain of <tt>operator &lt;</tt>.  Essentially, then, this
+is a definition of that domain: it is the set of pairs of iterators such
+that one iterator is reachable from the other.  
+<P><A name="4">[4]</A>
+All of the other comparison operators have the same domain and
+are defined in terms of <tt>operator &lt;</tt>, so they have exactly the same
+semantics as described in <A href="LessThanComparable.html">LessThan Comparable</A>.
+<P><A name="5">[5]</A>
+This complexity guarantee is in fact the only reason why
+Random Access Iterator exists as a distinct concept.  Every
+operation in iterator arithmetic can be defined for 
+<A href="BidirectionalIterator.html">Bidirectional Iterators</A>; in fact, that is exactly what the 
+algorithms <tt><A href="advance.html">advance</A></tt> and <tt><A href="distance.html">distance</A></tt> do.  The distinction is
+simply that the <A href="BidirectionalIterator.html">Bidirectional Iterator</A> implementations are
+linear time, while Random Access Iterators are required to support
+random access to elements in amortized constant time.  This has
+major implications for the sorts of algorithms that can sensibly
+be written using the two types of iterators.
+<h3>See also</h3>
+<A href="LessThanComparable.html">LessThan Comparable</A>, <!--<A href="trivial.html">-->Trivial Iterator<!--</A>-->, 
+<A href="BidirectionalIterator.html">Bidirectional Iterator</A>, <A href="Iterators.html">Iterator overview</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Set.html b/src/tstl2cl/doc/eng/Set.html
new file mode 100644
index 0000000..ee53378
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Set.html
@@ -0,0 +1,623 @@
+<HTML>
+<Head>
+<Title>c_set</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_set</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: containers</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Set</tt> is a
+<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>--> that stores objects of type <tt>Key</tt>.
+<tt>Set</tt> is a
+<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->, 
+meaning that its value type, as well as its 
+key type, is <tt>Key</tt>.  It is also a
+<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->,
+meaning that no two elements are the same.
+<P>
+<tt>Set</tt> and <tt><!--<A href="multiset.html">-->multiset<!--</A>--></tt> are
+particularly well suited to the set algorithms
+<tt><!--<A href="includes.html">-->includes<!--</A>--></tt>,
+<tt><!--<A href="set_union.html">-->set_union<!--</A>--></tt>,
+<tt><!--<A href="set_intersection.html">-->set_intersection<!--</A>--></tt>,
+<tt><!--<A href="set_difference.html">-->set_difference<!--</A>--></tt>, and
+<tt><!--<A href="set_symmetric_difference.html">-->set_symmetric_difference<!--</A>--></tt>.
+The reason for this is twofold.  First, the set algorithms require
+their arguments to be sorted ranges, and, since
+<tt><A href="set.html">set</A></tt> and 
+<tt><!--<A href="multiset.html">-->multiset<!--</A>--></tt> are 
+<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Containers<!--</A>-->, 
+their elements are always sorted in ascending order. 
+Second, the output range of these algorithms is always sorted, and
+inserting a sorted range into a <tt>set</tt> or <tt>multiset</tt> is a
+fast operation: the
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>--> 
+and <!--<A href="MultipleSortedAssociativeContainer.html">-->Multiple Sorted Associative Container<!--</A>-->
+requirements guarantee that inserting a
+range takes only linear time if the range is already sorted.
+<P>
+<tt>Set</tt> has the important property that inserting a new element
+into a <tt>set</tt> does not invalidate iterators that point to existing
+elements.  Erasing an element from a set also does not invalidate
+any iterators, except, of course, for iterators that actually point 
+to the element that is being erased.
+<h3>Example</h3>
+<pre>
+
+int main()
+{
+	c_set S;
+	c_set_create(&S, NULL);
+	c_set_insert(&S, 0);
+	c_set_destroy(&S);
+}
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_set.h">c_set.h</A>.
+<h3>Model of</h3>
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
+<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->
+<h3>Type requirements</h3>
+<UL>
+<LI>
+<tt>Key</tt> is <!--<A href="Assignable.html">-->Assignable<!--</A>-->.
+<LI>
+<tt>Compare</tt> is a <!--<A href="StrictWeakOrdering.html">-->Strict Weak Ordering<!--</A>--> whose argument type
+   is <tt>Key</tt>.
+<LI>
+<tt>Alloc</tt> is an <!--<A href="Allocators.html">-->Allocator<!--</A>-->.
+</UL>
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The type of object, <tt>T</tt>, stored in the set.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>key_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+The key type associated with <tt>value_type</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>key_compare</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+ <A href="functors.html">Function object</A> that compares two keys for ordering.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_compare</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+ <A href="functors.html">Function object</A> that compares two values for ordering.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pointer</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Pointer to <tt>T</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>difference_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+A signed integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Iterator used to iterate through a <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate through a <tt>set</tt>.  (<tt>Iterator</tt> and
+   <tt>const_iterator</tt> are the same type.)
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Iterator used to iterate backwards through a <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate backwards through a <tt>set</tt>.
+  (<tt>Reverse_iterator</tt> and <tt>const_reverse_iterator</tt> are the same type.)
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_set_begin(c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the beginning of the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_set_end(c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the end of the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_set_rbegin(cpset)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the beginning of the
+   reversed set.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_set_rend(cpset)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>reverse_iterator</tt> pointing to the end of the
+   reversed set.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_set_size(c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the size of the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_set_max_size(c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the largest possible size of the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_set_empty(c_pset) const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+<tt>true</tt> if the <tt>set</tt>'s size is <tt>0</tt>.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<tt>key_compare key_comp() const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Returns the <tt>key_compare</tt> object used by the <tt>set</tt>.
+</TD>
+</TR>
+-->
+<!--
+<TR>
+<TD VAlign=top>
+<tt>value_compare value_comp() const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Returns the <tt>value_compare</tt> object used by the <tt>set</tt>.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>__c_set(c_pset, COMPARER) or c_set_create(c_pset, COMPARER)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Creates an empty <tt>set</tt>.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<tt>set(const key_compare&amp; comp)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Creates an empty <tt>set</tt>, using <tt>comp</tt> as the <tt>key_compare</tt> object.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
+set(InputIterator f, InputIterator l)
+<A href="#1">[1]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+ <A href="UniqueSortedAssociativeContainer.html">Unique Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Creates a set with a copy of a range.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
+set(InputIterator f, InputIterator l,
+    const key_compare&amp; comp)
+<A href="#1">[1]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+ <A href="UniqueSortedAssociativeContainer.html">Unique Sorted Associative Container</A>
+</TD>
+<TD VAlign=top>
+Creates a set with a copy of a range, using <tt>comp</tt> as the <tt>key_compare</tt>
+   object.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>set(const set&amp;)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The copy constructor.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>c_set_assign(c_pset, const c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The assignment operator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_set_swap(c_pset, c_pset)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Swaps the contents of two sets.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iter_bool_pair
+c_set_insert(c_pset, const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> into the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iterator c_set_insert1(c_pset, c_iterator pos, 
+   	         	    const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> into the <tt>set</tt>, using <tt>pos</tt> as a hint to where it will be
+   inserted.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_set_insert2(c_pset, c_iterator, c_iterator)
+<A href="#1">[1]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts a range into the <tt>set</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_set_erase(c_pset, c_iterator pos)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element pointed to by <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_set_erase1(c_pset,  key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_set_erase2(c_pset, c_iterator first, c_iterator last)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all elements in a range.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_set_clear(c_pset)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all of the elements.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_set_find(c_pset, key_type k) </tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds an element whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_set_count(c_pset, key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="UniqueAssociativeContainer.html">-->Unique Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Counts the number of elements whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_set_lower_bound(c_pset, key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds the first element whose key is not less than <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_set_upper_bound(c_pset, key_type k)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds the first element whose key greater than <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iter_iter_pair
+c_set_equal_range(c_pset, const key_type k)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Finds a range containing all elements whose key is <tt>k</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_set_equal(c_pset, const c_pset)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Tests two sets for equality.  This is a global function, not
+   a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_set_less(c_pset, const c_pset)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Lexicographical comparison.  This is a global function, not
+   a member function.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+All of <tt>set</tt>'s members are defined in the 
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->
+and <!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->
+requirements.  <tt>Set</tt> does not introduce any new members.
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+This member function relies on <i>member template</i> functions, which
+at present (early 1998) are not supported by all compilers.  If your
+compiler supports member templates, you can call this function with
+any type of <A href="InputIterator.html">input iterator</A>.  If your
+compiler does not yet support member templates, though, then the
+arguments must either be of type <tt>const value_type*</tt> or of type
+<tt>set::const_iterator</tt>.
+<h3>See also</h3>
+<!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>-->, 
+<!--<A href="SortedAssociativeContainer.html">-->Sorted Associative Container<!--</A>-->, 
+<!--<A href="SimpleAssociativeContainer.html">-->Simple Associative Container<!--</A>-->,
+<!--<A href="UniqueSortedAssociativeContainer.html">-->Unique Sorted Associative Container<!--</A>-->, 
+<tt><A href="Map.html">map</A></tt>,
+<!--<tt><A href="multiset.html">multiset</A></tt>,
+<tt><A href="Multimap.html">multimap</A></tt>,
+<tt><A href="hash_set.html">hash_set</A></tt>, 
+<tt><A href="hash_map.html">hash_map</A></tt>, 
+<tt><A href="hash_multiset.html">hash_multiset</A></tt>, 
+<tt><A href="hash_multimap.html">hash_multimap</A></tt>
+-->
+<!--start footer--> 
+<HR SIZE="6">
+<P>
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Stack.html b/src/tstl2cl/doc/eng/Stack.html
new file mode 100644
index 0000000..0818cb3
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Stack.html
@@ -0,0 +1,328 @@
+<HTML>
+<Head>
+<Title>c_stack</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_stack</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: containers, adaptors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A <tt>stack</tt> is an adaptor that provides a restricted subset of
+<A href="Container.html">Container</A> functionality: it provides insertion, removal, and
+inspection of the element at the top of the stack.  <tt>Stack</tt> is a
+&quot;last in first out&quot; (LIFO) data structure: the element at the 
+top of a <tt>stack</tt> is the one that was most recently added. <A href="#1">[1]</A>
+<tt>Stack</tt> does not allow iteration through its elements.  <A href="#2">[2]</A>
+<P>
+<tt>Stack</tt> is a container adaptor, meaning that it is implemented on
+top of some underlying container type.  By default that underlying
+type is <tt><!--<A href="Deque.html">-->deque<!--</A>--></tt>, but a different type may be selected explicitly.
+<h3>Example</h3>
+<pre>
+int main() {
+	c_stack S;
+	c_stack_create(&S, NULL);
+	c_stack_push(&S,0);
+	c_stack_destroy(&S);
+}
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_stack.h">c_stack.h</A>.
+<h3>Model of</h3>
+<A href="Assignable.html">Assignable</A>, <!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+<h3>Type requirements</h3>
+<UL>
+<LI>
+<tt>T</tt> is a model of <A href="Assignable.html">Assignable</A>.
+<LI>
+<tt>Sequence</tt> is a model of <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<LI>
+<tt>Sequence::value_type</tt> is the same type as <tt>T</tt>.
+<LI>
+If <tt>operator==</tt> is used, then <tt>T</tt> is a model of
+<!--<A href="EqualityComparable.html">-->Equality Comparable<!--</A>-->
+<LI>
+If <tt>operator&lt;</tt> is used, then <tt>T</tt> is a model of <!--<A href="LessThanComparable.html">-->LessThan Comparable<!--</A>-->.
+</UL>
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_stack(c_pstack, COMPARER) or c_stack_create(c_pstack, COMPARER)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+</TD>
+<TD VAlign=top>
+The default constructor.  Creates an empty <tt>stack</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_pstack c_stack_assign(c_pstack, const c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Assignable.html">Assignable</A>
+</TD>
+<TD VAlign=top>
+The assignment operator.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_empty(c_pstack) </tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_stack_size(c_pstack) </tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_stack_top(c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_stack_push(c_pstack, const value_type)</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_stack_pop(c_pstack)</tt> <A href="#3">[3]</A>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_equal(c_pstack, const c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_less(c_pstack, const c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+<tt>stack</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<A href="Assignable.html">Assignable</A> and <!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->
+requirements, but are specific to <tt>stack</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+The type of object stored in the <tt>stack</tt>.  This is the same as
+   <tt>T</tt> and <tt>Sequence::value_type</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.  This is the same as <tt>Sequence::size_type</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_empty(c_pstack) </tt>
+</TD>
+<TD VAlign=top>
+Returns <tt>true</tt> if the <tt>stack</tt> contains no elements, and <tt>false</tt>
+   otherwise.  <tt>S.empty()</tt> is equivalent to <tt>S.size() == 0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_stack_size(c_pstack) </tt>
+</TD>
+<TD VAlign=top>
+Returns the number of elements contained in the <tt>stack</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_stack_top(c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+Returns a mutable reference to the element at the top of the stack.
+   Precondition: <tt>empty()</tt> is <tt>false</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_stack_push(c_pstack, const value_type x)</tt>
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> at the top of the stack.  Postconditions: <tt>size()</tt> will
+   be incremented by <tt>1</tt>, and <tt>top()</tt> will be equal to <tt>x</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_stack_pop(c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+Removes the element at the top of the stack. <A href="#3">[3]</A>  Precondition:
+   <tt>empty()</tt> is <tt>false</tt>.  Postcondition: <tt>size()</tt> will be decremented
+   by <tt>1</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_equal(c_pstack, const c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+Compares two stacks for equality.  Two stacks are equal if they
+   contain the same number of elements and if they are equal
+   element-by-element.  This is a global function, not a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_stack_less(c_pstack, const c_pstack)</tt>
+</TD>
+<TD VAlign=top>
+Lexicographical ordering of two stacks.
+  This is a global function, not a member function.
+</TD>
+</tr>
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Stacks are a standard data structure, and are discussed in all
+algorithm books.  See, for example, section 2.2.1 of Knuth.
+(D. E. Knuth, <i>The Art of Computer
+Programming.  Volume 1: Fundamental Algorithms</i>, second edition.  
+Addison-Wesley, 1973.)
+<P><A name="2">[2]</A>
+This restriction is the only reason for <tt>stack</tt> to exist at all.
+Note that any <!--<A href="FrontInsertionSequence.html">-->Front Insertion Sequence<!--</A>--> or <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>--> 
+can be used as a stack; in the case of <A href="Vector.html">vector</A>, for
+example, the stack operations are the member functions <tt>back</tt>,
+<tt>push_back</tt>, and <tt>pop_back</tt>.  The only reason to use the container
+adaptor <tt>stack</tt> instead is to make it clear that you are performing
+only stack operations, and no other operations.
+<P><A name="3">[3]</A>
+One might wonder why <tt>pop()</tt> returns <tt>void</tt>, instead of <tt>value_type</tt>.
+That is, why must one use <tt>top()</tt> and <tt>pop()</tt> to examine and remove
+the top element, instead of combining the two in a single member
+function?  In fact, there is a good reason for this design.  
+If <tt>pop()</tt> returned the top element, it would have to return by value
+rather than by reference: return by reference would create a dangling
+pointer.  Return by value, however, is inefficient: it involves at
+least one redundant copy constructor call.  Since it is impossible for
+<tt>pop()</tt> to return a value in such a way as to be both efficient
+and correct, it is more sensible for it to return no value at all and
+to require clients to use <tt>top()</tt> to inspect the value at the top of
+the stack.
+<h3>See also</h3>
+<tt><A href="queue.html">queue</A></tt>, <!--<tt><A href="priority_queue.html">priority_queue</A></tt>,--> <A href="Container.html">Container</A><!--, <A href="Sequence.html">Sequence</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/UnaryFunction.html b/src/tstl2cl/doc/eng/UnaryFunction.html
new file mode 100644
index 0000000..f1be14d
--- /dev/null
+++ b/src/tstl2cl/doc/eng/UnaryFunction.html
@@ -0,0 +1,186 @@
+<HTML>
+<Head>
+<Title>Unary Function</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Unary Function</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: concept</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A Unary Function is a kind of <A href="functors.html">function object</A>: an object that is called
+as if it were an ordinary C++ function.  A Unary Function is called with a
+single argument.
+<h3>Refinement of</h3>
+<A href="Assignable.html">Assignable</A>
+<h3>Associated types</h3>
+<Table border>
+<TR>
+<TD VAlign=top>
+Argument type
+</TD>
+<TD VAlign=top>
+The type of the Unary Function's argument.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+Result type
+</TD>
+<TD VAlign=top>
+The type returned when the Unary Function is called
+</TD>
+</tr>
+</table>
+<h3>Notation</h3>
+<Table>
+<TR>
+<TD VAlign=top>
+<tt>F</tt>
+</TD>
+<TD VAlign=top>
+A type that is a model of Unary Function
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>X</tt>
+</TD>
+<TD VAlign=top>
+The argument type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Result</tt>
+</TD>
+<TD VAlign=top>
+The result type of <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>f</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>F</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>x</tt>
+</TD>
+<TD VAlign=top>
+Object of type <tt>X</tt>
+</TD>
+</tr>
+</table>
+<h3>Definitions</h3>
+The <i>domain</i> of a Unary Function is the set of all permissible
+values for its argument.
+<P>
+The <i>range</i> of a Unary Function is the set of all possible values
+that it may return.
+<h3>Valid expressions</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Type requirements
+</TH>
+<TH>
+Return type
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x)</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+<TD VAlign=top>
+<tt>Result</tt>
+</TD>
+</tr>
+</table>
+<h3>Expression semantics</h3>
+<Table border>
+<TR>
+<TH>
+Name
+</TH>
+<TH>
+Expression
+</TH>
+<TH>
+Precondition
+</TH>
+<TH>
+Semantics
+</TH>
+<TH>
+Postcondition
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+Function call
+</TD>
+<TD VAlign=top>
+<tt>f(x)</tt>
+</TD>
+<TD VAlign=top>
+<tt>x</tt> is in <tt>f</tt>'s domain
+</TD>
+<TD VAlign=top>
+Calls <tt>f</tt> with <tt>x</tt> as an argument, and returns a value of type <tt>Result</tt> <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+The return value is in <tt>f</tt>'s range
+</TD>
+</tr>
+</table>
+<h3>Complexity guarantees</h3>
+<h3>Invariants</h3>
+<h3>Models</h3>
+<UL>
+<LI>
+<tt>Result (*)(X)</tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Two different invocations of <tt>f</tt> may return different results, even
+if <tt>f</tt> is called with the same arguments both times.
+A Unary Function may refer to local state, perform I/O,
+and so on.  The expression <tt>f(x)</tt> is permitted to change <tt>f</tt>'s state.
+<h3>See also</h3>
+<A href="functors.html">Function Object overview</A>, <!--<A href="Generator.html">-->Generator<!--</A>-->, <A href="BinaryFunction.html">Binary Function</A>
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/Vector.html b/src/tstl2cl/doc/eng/Vector.html
new file mode 100644
index 0000000..a1be889
--- /dev/null
+++ b/src/tstl2cl/doc/eng/Vector.html
@@ -0,0 +1,585 @@
+<HTML>
+<Head>
+<Title>c_vector</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_vector</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: containers</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+A <tt>vector</tt> is a <!--<A href="Sequence.html">-->Sequence<!--</A>--> that
+supports random access to elements, constant time insertion and
+removal of elements at the end, and linear time insertion and removal
+of elements at the beginning or in the middle.  The number of elements
+in a <tt>vector</tt> may vary dynamically; memory management is
+automatic.  <tt>Vector</tt> is the simplest of the STL container
+classes, and in many cases the most efficient.
+<h3>Example</h3>
+<pre>
+c_vector V;
+c_vector_create(&V, NULL);
+c_vector_insert(&V, V.begin(), malloc(sizeof(int)));
+assert(c_vector_size(&V) == 1 &amp;&amp; c_vector_capacity(&V) &gt;= 1);
+c_vector_destroy(&V);
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_vector.h">c_vector.h</A>.
+<h3>Model of</h3>
+<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>-->, 
+<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<h3>Type requirements</h3>
+None, except for those imposed by the requirements of 
+<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>--> 
+and <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->.
+<h3>Public base classes</h3>
+None.  
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The type of object, <tt>T</tt>, stored in the vector.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pointer</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Pointer to <tt>T</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+An unsigned integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>difference_type</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+A signed integral type.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Iterator used to iterate through a <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_iterator</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate through a <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Iterator used to iterate backwards through a <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>const_reverse_iterator</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Const iterator used to iterate backwards through a <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_vector_begin(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the beginning of the <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_vector_end(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns an <tt>iterator</tt> pointing to the end of the <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_vector_rbegin(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>c_reverse_iterator</tt> pointing to the beginning of the
+   reversed vector.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_reverse_iterator c_vector_rend(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ReversibleContainer.html">-->Reversible Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns a <tt>c_reverse_iterator</tt> pointing to the end of the
+   reversed vector.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_vector_size(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the size of the <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type max_size(c_pvector ) </tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Returns the largest possible size of the <tt>vector</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_vector_capacity(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+<tt>vector</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool c_vector_empty(c_pvector ) const</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+<tt>true</tt> if the <tt>vector</tt>'s size is <tt>0</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_vector_at(c_pvector , size_type )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns the <tt>n</tt>'th element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>__c_vector(c_pvector , COMPARER) or c_vector_create(c_pvector, COMPARER)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Creates an empty vector.
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="InputIterator.html">InputIterator</A>&gt;
+vector(InputIterator, InputIterator)
+<A href="#1">[1]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+ <A href="Sequence.html">Sequence</A>
+</TD>
+<TD VAlign=top>
+Creates a vector with a copy of a range.
+</TD>
+</TR>
+-->
+<TR>
+<TD VAlign=top>
+<tt>__rotcev(c_pvector ) or c_vector_destroy(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The destructor.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_pvector c_vector_assign(c_pvector, c_pvector)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+The assignment operator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_reserve(size_t)</tt>
+</TD>
+<TD VAlign=top>
+<tt>vector</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_vector_front(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns the first element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type c_vector_back(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Returns the last element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_push_back(const value_type)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts a new element at the end.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_pop_back(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Removes the last element.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_swap(c_pvector, c_pvector)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Container.html">Container</A>
+</TD>
+<TD VAlign=top>
+Swaps the contents of two vectors.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_iterator c_vector_insert(c_iterator pos,
+                const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>x</tt> before <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_vector_insert2(c_pvector, c_iterator pos, c_iterator first, c_iterator last);
+<A href="#1">[1]</A>
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts the range <tt>[first, last)</tt> before <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+void c_vector_fill_insert(c_pvector, c_iterator pos, 
+            			size_type n, const value_type x)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts <tt>n</tt> copies of <tt>x</tt> before <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_vector_erase(c_pvector, c_iterator pos)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the element at position <tt>pos</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_iterator c_vector_erase(c_pvector, c_iterator first, c_iterator last)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases the range <tt>[first, last)</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_clear(c_pvector )</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Erases all of the elements.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>void c_vector_resize(c_pvector, size_t n)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="Sequence.html">-->Sequence<!--</A>-->
+</TD>
+<TD VAlign=top>
+Inserts or erases elements at the end such that the size becomes <tt>n</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_vector_equal(c_pvector, 
+                	const c_pvector)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Tests two vectors for equality.  This is a global function, not
+   a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+c_bool c_vector_less(c_pvector,  
+               		const c_pvector)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="ForwardContainer.html">-->Forward Container<!--</A>-->
+</TD>
+<TD VAlign=top>
+Lexicographical comparison.  This is a global function, not
+   a member function.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<!--<A href="RandomAccessContainer.html">-->Random Access Container<!--</A>--> 
+and <!--<A href="BackInsertionSequence.html">-->Back Insertion Sequence<!--</A>-->
+requirements, but are specific to <tt>vector</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>size_type c_vector_capacity(c_pvector)</tt>
+</TD>
+<TD VAlign=top>
+Number of elements for which memory has been allocated.
+   <tt>capacity()</tt> is always greater than or equal to <tt>size()</tt>.
+   <A href="#2">[2]</A> <A href="#3">[3]</A>
+</TD>
+</TR>
+<!--
+<TR>
+<TD VAlign=top>
+<tt>void reserve(size_type n)</tt>
+</TD>
+<TD VAlign=top>
+If <tt>n</tt> is less than or equal to <tt>capacity()</tt>, this call has no effect.
+    Otherwise, it is a request for allocation of additional 
+    memory.  If the request is successful, then <tt>capacity()</tt> is
+    greater than or equal to <tt>n</tt>; otherwise, <tt>capacity()</tt> is unchanged.
+    In either case, <tt>size()</tt> is unchanged.  
+    <A href="#2">[2]</A> <A href="#4">[4]</A>
+</TD>
+</tr>
+-->
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+This member function relies on <i>member template</i> functions, which
+at present (early 1998) are not supported by all compilers.  If your
+compiler supports member templates, you can call this function with
+any type of <A href="InputIterator.html">input iterator</A>.  If your
+compiler does not yet support member templates, though, then the
+arguments must be of type <tt>const value_type*</tt>.
+<P><A name="2">[2]</A>
+Memory will be reallocated automatically if more than <tt>capacity() -
+size()</tt> elements are inserted into the vector.  Reallocation does
+not change <tt>size()</tt>, nor does it change the values of any
+elements of the vector.  It does, however, increase
+<tt>capacity()</tt>, and it invalidates <A href="#5">[5]</A> any
+iterators that point into the vector.
+<P><A name="3">[3]</A>
+When it is necessary to increase <tt>capacity()</tt>, <tt>vector</tt>
+usually increases it by a factor of two.  It is crucial that the
+amount of growth is proportional to the current <tt>capacity()</tt>,
+rather than a fixed constant: in the former case inserting a series of
+elements into a vector is a linear time operation, and in the latter
+case it is quadratic.
+<P><A name="4">[4]</A>
+<tt>Reserve()</tt> causes a reallocation manually.  The main reason
+for using <tt>reserve()</tt> is efficiency: if you know the capacity
+to which your <tt>vector</tt> must eventually grow, then it is usually
+more efficient to allocate that memory all at once rather than relying
+on the automatic reallocation scheme.  The other reason for using
+<tt>reserve()</tt> is so that you can control the invalidation of
+iterators. <A href="#5">[5]</A>
+<P><A name="5">[5]</A>
+A vector's iterators are invalidated when its memory is reallocated.
+Additionally, inserting or deleting an element in the middle of a
+vector invalidates all iterators that point to elements following the
+insertion or deletion point.  It follows that you can prevent a
+vector's iterators from being invalidated if you use
+<tt>reserve()</tt> to preallocate as much memory as the vector will
+ever use, and if all insertions and deletions are at the vector's end.
+<h3>See also</h3>
+<!--<A href="Deque.html">deque</A>,--> 
+<A href="List.html">list</A>
+<!--, <A href="Slist.html">slist</A>-->
+
+<!--start footer--> 
+<HR SIZE="6">
+<!--
+<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
+        ALT="[Silicon Surf]"></A>
+<A HREF="index.html"><IMG SRC="stl_home.gif" 
+        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
+<BR>
+<FONT SIZE="-2">
+<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
+1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
+<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
+</FONT>
+-->
+<P>
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/adjacent_find.html b/src/tstl2cl/doc/eng/adjacent_find.html
new file mode 100644
index 0000000..c87b73c
--- /dev/null
+++ b/src/tstl2cl/doc/eng/adjacent_find.html
@@ -0,0 +1,116 @@
+<HTML>
+<Head>
+<Title>adjacent_find</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+	<!--end header-->
+	<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_adjacent_find</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Adjacent_find</tt> is an overloaded name; there are actually two <tt>adjacent_find</tt>
+functions.
+<pre>
+
+c_iterator c_adjacent_find(c_iterator first, c_iterator last,
+                              BINARY_PREDICATE binary_pred);
+</pre>                   
+<h3>Description</h3>
+The first version of <tt>adjacent_find</tt>
+returns the first iterator <tt>i</tt> such that <tt>i</tt> and <tt>i+1</tt>
+are both valid iterators in <tt>[first, last)</tt>, and such that 
+<tt>*i == *(i+1)</tt>.  It returns <tt>last</tt> if no such iterator exists.
+<P>
+The second version of <tt>adjacent_find</tt>
+returns the first iterator <tt>i</tt> such that <tt>i</tt> and <tt>i+1</tt>
+are both valid iterators in <tt>[first, last)</tt>, and such that 
+<tt>binary_pred(*i, *(i+1))</tt> is <tt>true</tt>.  
+It returns <tt>last</tt> if no such iterator exists.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+For the first version:
+<UL>
+<LI>
+<tt>ForwardIterator</tt> is a model of <A href="ForwardIterator.html">Forward Iterator</A>.
+<LI>
+<tt>ForwardIterator</tt>'s value type is <A href="EqualityComparable.html">Equality Comparable</A>.
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>ForwardIterator</tt> is a model of <A href="ForwardIterator.html">Forward Iterator</A>.
+<LI>
+<tt>ForwardIterator</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
+   first argument type and to its second argument type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear.  If <tt>first == last</tt> then no comparison are performed;
+otherwise, at most <tt>(last - first) - 1</tt> comparisons.
+<h3>Example</h3>
+Find the first element that is greater than its successor.
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+static c_bool multi_equal_30(value_type x, value_type y)
+{
+	return  *(int*)(x) * *(int*)(y) == 30;
+}
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	printf("adjacent_find multi_equal_30 by array:\n");
+
+	iter = c_adjacent_find(first, last, multi_equal_30);
+	if(!ITER_EQUAL(iter, last))
+	{
+		printf("find : ");
+		first = ITER_POSITIVE_N(iter, 1);
+		printf("%d %d\n", *(int*)ITER_REF(iter), *(int*)ITER_REF(first));
+	}
+	else
+		printf("not find!\n");
+
+	return 0;	
+}
+
+
+
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<tt><A href="find.html">find</A></tt>, <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><A href="equal.html">equal</A></tt>, <tt><!--<A href="search.html">-->search<!--</A>--></tt>
+
+<!--start footer--> 
+<p>
+<hr size="6">
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/advance.html b/src/tstl2cl/doc/eng/advance.html
new file mode 100644
index 0000000..881b003
--- /dev/null
+++ b/src/tstl2cl/doc/eng/advance.html
@@ -0,0 +1,83 @@
+<HTML>
+<Head>
+<Title>advance</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_advance</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: algorithms, iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+void c_advance(c_piterator i, difference_type n);
+</pre>                   
+<h3>Description</h3>
+<tt>Advance(i, n)</tt> increments the iterator <tt>i</tt> by the distance <tt>n</tt>.  If <tt>n &gt; 0</tt> it is equivalent
+to executing <tt>++i</tt> <tt>n</tt> times, and if <tt>n &lt; 0</tt> it is equivalent to
+executing <tt>--i</tt> <tt>n</tt> times.  If <tt>n == 0</tt>, the call has no effect.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_iterator.h">c_iterator.h</A><!--, and in the
+nonstandard backward-compatibility header <A href="iterator.h">iterator.h</A>-->.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>Distance</tt> is an integral type that is convertible to <tt>InputIterator</tt>'s
+   distance type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>i</tt> is nonsingular.
+<LI>
+Every iterator between <tt>i</tt> and <tt>i+n</tt> (inclusive) is nonsingular.
+<LI>
+If <tt>InputIterator</tt> is a model of <A href="InputIterator.html">input iterator</A> or <A href="ForwardIterator.html">forward iterator</A>,
+   then <tt>n</tt> must be nonnegative.  If <tt>InputIterator</tt> is a model of
+   <A href="BidirectionalIterator.html">bidirectional iterator</A> or <A href="RandomAccessIterator.html">random access iterator</A>, then
+   this precondition does not apply.
+</UL>
+<h3>Complexity</h3>
+Constant time if <tt>InputIterator</tt> is a model of 
+<A href="RandomAccessIterator.html">random access iterator</A>, otherwise linear time.
+<h3>Example</h3>
+<pre>
+int main()
+{
+	<A href="List.html">c_list</A> L;
+	c_iterator i;
+
+	c_list_create(&L, NULL);
+	c_list_push_back(&L, (value_type)0);
+	c_list_push_back(&L, (value_type)0);
+
+	i = c_list_begin(&L);
+	c_advance(&i, 2);
+	assert(c_iter_equal(i, c_list_end(&L));
+	c_list_destroy(&L);
+}
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<tt><A href="distance.html">distance</A></tt>, <A href="InputIterator.html">Input iterator</A>, <A href="BidirectionalIterator.html">Bidirectional Iterator</A>,
+<A href="RandomAccessIterator.html">Random access iterator</A>, <tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt>, <A href="Iterators.html">Iterator overview</A>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/binary_negate.html b/src/tstl2cl/doc/eng/binary_negate.html
new file mode 100644
index 0000000..e9267c4
--- /dev/null
+++ b/src/tstl2cl/doc/eng/binary_negate.html
@@ -0,0 +1,198 @@
+<HTML>
+<Head>
+<Title>binary_negate</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_binary_negate</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: functors, adaptors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Binary_negate</tt> is a <A href="functors.html">function object</A> adaptor: it is an
+<!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>--> that represents the logical negation
+of some other <!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->.  That is: if <tt>f</tt> is an
+object of class <tt>binary_negate&lt;AdaptableBinaryPredicate&gt;</tt>, then
+there exists an object <tt>pred</tt> of class <tt>AdaptableBinaryPredicate</tt>
+such that <tt>f(x,y)</tt> always returns the same value as <tt>!pred(x,y)</tt>. 
+There is rarely any reason to construct a <tt>binary_negate</tt>
+directly; it is almost always easier to use the helper function <tt>not2</tt>.
+<h3>Example</h3>
+Finds the first character in a string that is neither
+<tt>' '</tt> nor <tt>'\n'</tt>.
+<pre>
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_functional.h">c_functional.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_function.h">c_function.h</A>.
+<h3>Template parameters</h3>
+<Table border>
+<TR>
+<TH>
+Parameter
+</TH>
+<TH>
+Description
+</TH>
+<TH>
+Default
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>AdaptableBinaryPredicate</tt>
+</TD>
+<TD VAlign=top>
+The type of the function object that this <tt>binary_negate</tt> is the logical
+   negation of.
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Model of</h3>
+<!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
+<h3>Type requirements</h3>
+<tt>AdaptableBinaryPredicate</tt> must be a model of <!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->.
+<h3>Public base classes</h3>
+<pre>
+<A href="binary_function.html">binary_function</A>
+</pre>
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>first_argument_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+	The type of the first argument: <tt><!--<A href="AdaptableBinaryPredicate.html">-->AdaptableBinaryPredicate<!--</A>-->::first_argument_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>second_argument_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+	The type of the second argument: <tt><!--<A href="AdaptableBinaryPredicate.html">-->AdaptableBinaryPredicate<!--</A>-->::second_argument_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>result_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of the result: <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+binary_negate(const AdaptableBinaryPredicate&amp; pred)
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>binary_negate</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="AdaptableBinaryPredicate.html">AdaptableBinaryPredicate</A>&gt;
+binary_negate&lt;AdaptableBinaryPredicate&gt;
+not2(const AdaptableBinaryPredicate&amp; pred);
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>binary_negate</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</tr>-->
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
+requirements, but are specific to 
+<tt>binary_negate</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+binary_negate(const AdaptableBinaryPredicate&amp; pred)
+</pre>
+</TD>
+<TD VAlign=top>
+The constructor.  Creates a <tt>binary_negate&lt;AdaptableBinaryPredicate&gt;</tt>
+whose underlying predicate is <tt>pred</tt>.  
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="AdaptableBinaryPredicate.html">AdaptableBinaryPredicate</A>&gt;
+binary_negate&lt;AdaptableBinaryPredicate&gt;
+not2(const AdaptableBinaryPredicate&amp; pred);
+</pre>
+</TD>
+<TD VAlign=top>
+If <tt>p</tt> is of type <tt>AdaptableBinaryPredicate</tt> then
+<tt>not2(p)</tt> is equivalent to <tt>binary_negate&lt;AdaptableBinaryPredicate&gt;(p)</tt>,
+but more convenient.  This is a global function, not a member function.
+</TD>
+</tr>-->
+</table>
+<h3>Notes</h3>
+<h3>See also</h3>
+The <A href="functors.html">function object overview</A>, <!--<A href="AdaptablePredicate.html">-->AdaptablePredicate<!--</A>-->, <A href="Predicate.html">Predicate</A>, 
+<tt><A href="unary_negate.html">unary_negate</A></tt>, <tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt>, <tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/copy.html b/src/tstl2cl/doc/eng/copy.html
new file mode 100644
index 0000000..ff884a7
--- /dev/null
+++ b/src/tstl2cl/doc/eng/copy.html
@@ -0,0 +1,115 @@
+<HTML>
+<Head>
+<Title>copy</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_copy</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+c_iterator c_copy(c_iterator first, c_iterator last,
+             	       c_iterator result);
+</pre>                   
+<h3>Description</h3>
+<tt>Copy</tt> copies elements from the range <tt>[first, last)</tt> to the range
+<tt>[result, result + (last - first))</tt>.  That is, it performs the 
+assignments <tt>*result = *first</tt>, <tt>*(result + 1) = *(first + 1)</tt>,
+and so on.  <A href="#1">[1]</A> Generally, for every integer <tt>n</tt> from <tt>0</tt> to <tt>last - first</tt>,
+<tt>copy</tt> performs the assignment <tt>*(result + n) = *(first + n)</tt>.
+Assignments are performed in forward order, <i>i.e.</i> in order of 
+increasing <tt>n</tt>. <A href="#2">[2]</A>
+<P>
+The return value is <tt>result + (last - first)</tt>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+InputIterator is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+OutputIterator is a model of <A href="OutputIterator.html">Output Iterator</A>.
+<LI>
+InputIterator's value type is convertible to a type in
+   OutputIterator's set of value types.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+<LI>
+<tt>result</tt> is not an iterator within the range <tt>[first, last)</tt>.
+<LI>
+There is enough space to hold all of the elements being copied.
+   More formally, the requirement is that 
+   <tt>[result, result + (last - first))</tt> is a valid range. <A href="#1">[1]</A>
+</UL>
+<h3>Complexity</h3>
+Linear.  Exactly <tt>last - first</tt> assignments are performed.
+<h3>Example</h3>
+<pre>
+
+
+static int arx[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * parx[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+static int ary[] = { 9,9,9,9,9,9,9,9,9,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&parx[0]);
+	c_iterator last = c_get_array_iterator((void**)&parx[10]);
+	c_iterator first2 = c_get_array_iterator((void**)&pary[0]);
+
+	
+	c_copy(first, last, first2);
+}
+
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Note the implications of this.  <tt>Copy</tt> cannot be used to insert
+elements into an empty <A href="Container.html">Container</A>: it overwrites elements, rather
+than inserting elements.  If you want to insert elements into a
+<!--<A href="Sequence.html">-->Sequence<!--</A>-->, you can either use its <tt>insert</tt> member function explicitly,
+or else you can use <tt>copy</tt> along with an <tt><!--<A href="insert_iterator.html">-->insert_iterator<!--</A>--></tt> adaptor.
+<P><A name="2">[2]</A>
+The order of assignments matters in the case where the input and
+output ranges overlap: <tt>copy</tt> may not be used if <tt>result</tt> is in the
+range <tt>[first, last)</tt>.  That is, it may not be used if
+the beginning of the output range overlaps with the input range, but
+it may be used if the end of the output range overlaps with the input
+range; <tt><A href="copy_backward.html">copy_backward</A></tt> has opposite restrictions.
+If the two ranges are completely nonoverlapping, of course, then
+either algorithm may be used.
+The order of assignments also matters if <tt>result</tt> is an <tt><!--<A href="ostream_iterator.html">-->ostream_iterator<!--</A>--></tt>,
+or some other iterator whose semantics depends on the order or assignments.
+<h3>See also</h3>
+<tt><A href="copy_backward.html">copy_backward</A></tt>, <tt><!--<A href="copy_n.html">-->copy_n<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/copy_backward.html b/src/tstl2cl/doc/eng/copy_backward.html
new file mode 100644
index 0000000..4d5779a
--- /dev/null
+++ b/src/tstl2cl/doc/eng/copy_backward.html
@@ -0,0 +1,89 @@
+<HTML>
+<Head>
+<Title>copy_backward</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_copy_backward</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+c_iterator c_copy_backward(c_iterator first, 
+                           	c_iterator last, 
+                           	c_iterator result);
+</pre>                   
+<h3>Description</h3>
+<tt>Copy_backward</tt> copies elements from the range <tt>[first, last)</tt> to the range
+<tt>[result - (last - first), result)</tt> <A href="#1">[1]</A>.  That is, it performs the 
+assignments <tt>*(result - 1) = *(last - 1)</tt>, <tt>*(result - 2) = *(last - 2)</tt>, 
+and so on.   Generally, for every integer <tt>n</tt> from <tt>0</tt> to <tt>last - first</tt>,
+<tt>copy_backward</tt> performs the assignment <tt>*(result - n - 1) = *(last - n - 1)</tt>.
+Assignments are performed from the end of the input sequence to the 
+beginning, <i>i.e.</i> in order of increasing <tt>n</tt>. <A href="#2">[2]</A>
+<P>
+The return value is <tt>result - (last - first)</tt>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+BidirectionalIterator1 and BidirectionalIterator2 are
+   models of <A href="BidirectionalIterator.html">BidirectionalIterator</A>.
+<LI>
+BidirectionalIterator1's value type is convertible to
+   BidirectionalIterator2's value type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+<LI>
+<tt>result</tt> is not an iterator within the range <tt>[first, last)</tt>.
+<LI>
+There is enough space to hold all of the elements being copied.
+   More formally, the requirement is that 
+   <tt>[result - (last - first), result)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear.  Exactly <tt>last - first</tt> assignments are performed.
+<h3>Example</h3>
+<pre>
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+<tt>Result</tt> is an iterator that points to the <i>end</i> of the output
+range.  This is highly unusual: in all other STL algorithms that
+denote an output range by a single iterator, that iterator points to
+the beginning of the range.
+<P><A name="2">[2]</A>
+The order of assignments matters in the case where the input and
+output ranges overlap:  <tt>copy_backward</tt> may not be used if <tt>result</tt> is
+in the range <tt>[first, last)</tt>.  That is, it may not be used if the
+end of the output range overlaps with the input range, but it may be
+used if the beginning of the output range overlaps with the input
+range; <tt><A href="copy.html">copy</A></tt> has opposite restrictions.
+If the two ranges are completely nonoverlapping, of course, then
+either algorithm may be used.
+<h3>See also</h3>
+<tt><A href="copy.html">copy</A></tt>, <tt><!--<A href="copy_n.html">-->copy_n<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/count.html b/src/tstl2cl/doc/eng/count.html
new file mode 100644
index 0000000..69675ed
--- /dev/null
+++ b/src/tstl2cl/doc/eng/count.html
@@ -0,0 +1,141 @@
+<HTML>
+<Head>
+<Title>count</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_count</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Count</tt> is an overloaded name: there are two <tt>count</tt> functions.
+<pre>
+size_type c_count(c_iterator first, c_iterator last, 
+      const value_type value);
+
+void c_count1(c_iterator first, c_iterator last, 
+           	const value_type value,
+           	size_type * pn);
+</pre>                   
+<h3>Description</h3>
+<tt>Count</tt> finds the number of elements in <tt>[first, last)</tt> that are 
+equal to <tt>value</tt>.  More precisely, the first version of <tt>count</tt>
+returns the number of iterators <tt>i</tt> in <tt>[first, last)</tt> such that 
+<tt>*i == value</tt>.  The second version of <tt>count</tt> adds to <tt>n</tt> the number of 
+iterators <tt>i</tt> in <tt>[first, last)</tt> such that <tt>*i == value</tt>. 
+<P>
+The second version of <tt>count</tt> was the one defined in the original
+STL, and the first version is the one defined in the 
+draft C++ standard; the definition was changed because the
+older interface was clumsy and error-prone.  The older interface
+required the use of a temporary variable, which had to be
+initialized to 0 before the call to <tt>count</tt>.
+<P>
+Both interfaces are currently supported <A href="#1">[1]</A>, for
+reasons of backward compatibility, but eventually the older
+version will be removed.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+For the first version, which takes three arguments:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>EqualityComparable</tt> is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+<tt>InputIterator</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+An object of <tt>InputIterator</tt>'s value type can be compared for equality with
+   an object of type <tt>EqualityComparable</tt>.
+</UL>
+For the second version, which takes four arguments:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>EqualityComparable</tt> is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+<tt>Size</tt> is an integral type that can hold values of
+   <tt>InputIterator</tt>'s distance type.
+<LI>
+<tt>InputIterator</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+An object of <tt>InputIterator</tt>'s value type can be compared for equality with
+   an object of type <tt>EqualityComparable</tt>.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+<LI>
+<tt>n</tt> plus the number of elements equal to <tt>value</tt> does not exceed
+   the maximum value of type <tt>Size</tt>.
+</UL>
+<h3>Complexity</h3>
+Linear.  Exactly <tt>last - first</tt> comparisons.
+<h3>Example</h3>
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	int i;
+
+	printf("test count by c array:\n");
+
+	for(i = 0; i < sizeof(pary) / sizeof(int *); ++ i)
+	{
+		printf("there are %d of %d in this array\n", c_count(first, last, pary[i]), *pary[i]);
+
+	}
+
+	return 0;
+}
+
+
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The new <tt>count</tt> interface uses the <tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt> class, which
+relies on a C++ feature known as <i>partial specialization</i>.  Many of
+today's compilers don't implement the complete standard; in
+particular, many compilers do not support partial specialization.  If
+your compiler does not support partial specialization, then you will
+not be able to use the newer version of <tt>count</tt>, or any other STL
+components that involve <tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt>.
+<h3>See also</h3>
+<tt><A href="count_if.html">count_if</A></tt>, <tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/count_if.html b/src/tstl2cl/doc/eng/count_if.html
new file mode 100644
index 0000000..d725011
--- /dev/null
+++ b/src/tstl2cl/doc/eng/count_if.html
@@ -0,0 +1,139 @@
+<HTML>
+<Head>
+<Title>count_if</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_count_if</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Count_if</tt> is an overloaded name: there are two <tt>count_if</tt> functions.
+<pre>
+size_type c_count_if(c_iterator first, c_iterator last, UNARY_PREDICATE pred);
+
+void c_count_if1(c_iterator first, c_iterator last, 
+			UNARY_PREDICATE pred,
+			size_type * pn);
+</pre> 
+<h3>Description</h3>
+<tt>Count_if</tt> finds the number of elements in <tt>[first, last)</tt> that satisfy
+the predicate <tt>pred</tt>.  More precisely, the first version of <tt>count_if</tt>
+returns the number of iterators <tt>i</tt> in <tt>[first, last)</tt> such that 
+<tt>pred(*i)</tt> is <tt>true</tt>.  The second version of <tt>count</tt> adds to <tt>n</tt> 
+the number of iterators <tt>i</tt> in <tt>[first, last)</tt> such that 
+<tt>pred(*i)</tt> is <tt>true</tt>. 
+<P>
+The second version of <tt>count_if</tt> was the one defined in the original
+STL, and the first version is the one defined in the 
+draft C++ standard; the definition was changed because the
+older interface was clumsy and error-prone.  The older interface
+required the use of a temporary variable, which had to be
+initialized to 0 before the call to <tt>count_if</tt>.
+<P>
+Both interfaces are currently supported <A href="#1">[1]</A>, for
+reasons of backward compatibility, but eventually the older
+version will be removed.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+For the first version, which takes three arguments:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>Predicate</tt> is a model of <A href="Predicate.html">Predicate</A>.
+<LI>
+<tt>InputIterator</tt>'s value type is convertible to <tt>Predicate</tt>'s argument
+   type.
+</UL>
+For the second version, which takes four arguments:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>Predicate</tt> is a model of <A href="Predicate.html">Predicate</A>.
+<LI>
+<tt>Size</tt> is an integral type that can hold values of
+   <tt>InputIterator</tt>'s distance type.
+<LI>
+<tt>InputIterator</tt>'s value type is convertible to <tt>Predicate</tt>'s argument
+   type.
+</UL>
+<h3>Preconditions</h3>
+For the first version:
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+<LI>
+<tt>n</tt> plus the number of elements that satisfy <tt>pred</tt> does not exceed
+   the maximum value of type <tt>Size</tt>.
+</UL>
+<h3>Complexity</h3>
+Linear.  Exactly <tt>last - first</tt> applications of <tt>pred</tt>.
+<h3>Example</h3>
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+static c_bool is_even(value_type val)
+{
+	return !((*((int*)val)) % 2);
+}
+
+
+int main() 
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	
+	printf("test count by c vector\n");
+
+	printf("there are %d of even in this array\n", c_count_if(first, 
+									last,
+									is_even));
+
+
+} 
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The new <tt>count</tt> interface uses the <tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt> class, which
+relies on a C++ feature known as <i>partial specialization</i>.  Many of
+today's compilers don't implement the complete standard; in
+particular, many compilers do not support partial specialization.  If
+your compiler does not support partial specialization, then you will
+not be able to use the newer version of <tt>count</tt>, or any other STL
+components that involve <tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt>.
+<h3>See also</h3>
+<tt><A href="count.html">count</A></tt>, <tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/distance.html b/src/tstl2cl/doc/eng/distance.html
new file mode 100644
index 0000000..267190e
--- /dev/null
+++ b/src/tstl2cl/doc/eng/distance.html
@@ -0,0 +1,124 @@
+<HTML>
+<Head>
+<Title>distance</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_distance, c_distance1</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: algorithms, iterators</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Distance</tt> is an overloaded name; there are actually two <tt>distance</tt>
+functions.
+<pre>
+difference_type c_distance(c_iterator first, c_iterator last);
+
+void c_distance1(c_iterator first, c_iterator last, difference_type * pn);
+</pre>                   
+<h3>Description</h3>
+Finds the distance between <tt>first</tt> and <tt>last</tt>, <i>i.e.</i> the number of
+times that <tt>first</tt> must be incremented until it is equal to
+<tt>last</tt>.  <A href="#1">[1]</A> The first version of <tt>distance</tt>, which takes two arguments,
+simply returns that distance; the second version, which takes
+three arguments and which has a return type of <tt>void</tt>, increments
+<tt>n</tt> by that distance.
+<P>
+The second version of <tt>distance</tt> was the one defined in the original
+STL, and the first version is the one defined in the 
+draft C++ standard; the definition was changed because the
+older interface was clumsy and error-prone.  The older interface
+required the use of a temporary variable, and it has semantics
+that are somewhat nonintuitive: it increments <tt>n</tt> by the distance
+from <tt>first</tt> to <tt>last</tt>, rather than storing that distance in <tt>n</tt>. <A href="#2">[2]</A>
+<P>
+Both interfaces are currently supported <A href="#3">[3]</A>, for
+reasons of backward compatibility, but eventually the older
+version will be removed.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_iterator.h">c_iterator.h</A>.
+<h3>Requirements on types</h3>
+For the first version:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>Distance</tt> is an integral type that is able to represent a distance
+   between iterators of type <tt>InputIterator</tt>.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a <i>valid range</i>, as defined in the
+   <A href="InputIterator.html">Input Iterator</A> requirements.
+</UL>
+<h3>Complexity</h3>
+Constant time if <tt>InputIterator</tt> is a model of 
+<A href="RandomAccessIterator.html">random access iterator</A>, otherwise linear time.
+<h3>Example</h3>
+<pre>
+int main() {
+	<A href="List.html">c_list</A> L;
+	c_list_create(&L, NULL);
+	c_list_push_back(&L, (value_type)NULL);
+	c_list_push_back(&L, (value_type)NULL);
+
+	assert(c_distance(c_list_begin(&L), c_list_end(&L)) == c_list_size(&L));
+	c_list_destroy(&L);
+}
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+This is the reason that <tt>distance</tt> is not defined for
+<A href="OutputIterator.html">output iterators</A>: it is impossible to compare two <A href="OutputIterator.html">output iterators</A>
+for equality.
+<P><A name="2">[2]</A>
+Forgetting to initialize <tt>n</tt> to 0 is a common mistake.
+<!--<P><A name="3">[3]</A>
+The new <tt>distance</tt> interface uses the <tt><A href="iterator_traits.html">iterator_traits</A></tt> class, which
+relies on a C++ feature known as <i>partial specialization</i>.  Many of
+today's compilers don't implement the complete standard; in
+particular, many compilers do not support partial specialization.  If
+your compiler does not support partial specialization, then you will
+not be able to use the newer version of <tt>distance</tt>, or any other STL
+components that involve <tt><A href="iterator_traits.html">iterator_traits</A></tt>.-->
+<h3>See also</h3>
+<tt><!--<A href="distance_type.html">-->distance_type<!--</A>--></tt>, <tt><A href="advance.html">advance</A></tt>, 
+<A href="InputIterator.html">Input iterator</A>, <A href="RandomAccessIterator.html">Random access iterator</A>, <!--<A href="iterator_tags.html">-->Iterator tags<!--</A>-->,
+<tt><!--<A href="iterator_traits.html">-->iterator_traits<!--</A>--></tt>, <A href="Iterators.html">Iterator overview</A>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<!--
+<A href="http://www.sgi.com/"><IMG SRC="surf.gif" HEIGHT="54" WIDTH="54" 
+        ALT="[Silicon Surf]"></A>
+<A HREF="index.html"><IMG SRC="stl_home.gif" 
+        HEIGHT="54" WIDTH="54" ALT="[STL Home]"></A>
+<BR>
+<FONT SIZE="-2">
+<A href="http://www.sgi.com/Misc/sgi_info.html" TARGET="_top">Copyright &copy; 
+1999 Silicon Graphics, Inc.</A> All Rights Reserved.</FONT>
+<FONT SIZE="-3"><a href="http://www.sgi.com/Misc/external.list.html" TARGET="_top">TrademarkInformation</A>
+</FONT>
+<P>
+-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/equal.html b/src/tstl2cl/doc/eng/equal.html
new file mode 100644
index 0000000..72250c9
--- /dev/null
+++ b/src/tstl2cl/doc/eng/equal.html
@@ -0,0 +1,129 @@
+<HTML>
+<Head>
+<Title>equal</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_equal</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Equal</tt> is an overloaded name; there are actually two <tt>equal</tt>
+functions.
+<pre>
+
+c_bool c_equal(c_iterator first1, c_iterator last1,
+         	  c_iterator first2, c_binary_predicate binary_pred);
+</pre>                   
+<h3>Description</h3>
+<tt>Equal</tt> returns <tt>true</tt> if the two ranges <tt>[first1, last1)</tt> and
+<tt>[first2, first2 + (last1 - first1))</tt> are identical when compared
+element-by-element, and otherwise returns <tt>false</tt>. <A href="#1">[1]</A>  
+<P>
+The first version of <tt>equal</tt> returns <tt>true</tt> if and only if
+for every iterator <tt>i</tt> in <tt>[first1, last1)</tt>, 
+<tt>*i == *(first2 + (i - first1))</tt>.  
+The second version of <tt>equal</tt> returns <tt>true</tt> if and only if
+for every iterator <tt>i</tt> in <tt>[first1, last1)</tt>, 
+<tt>binary_pred(*i, *(first2 + (i - first1))</tt> is <tt>true</tt>.  
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+For the first version:
+<UL>
+<LI>
+<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator1</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+<tt>InputIterator2</tt>'s value type is a model of <A href="EqualityComparable.html">Equality Comparable</A>.
+<LI>
+<tt>InputIterator1</tt>'s value type can be compared for equality with
+   <tt>InputIterator2</tt>'s value type. 
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary Predicate</A>.
+<LI>
+<tt>InputIterator1</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
+   first argument type.
+<LI>
+<tt>InputIterator2</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
+   second argument type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first1, last1)</tt> is a valid range.
+<LI>
+<tt>[first2, first2 + (last2 - last1))</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear.  At most <tt>last1 - first1</tt> comparisons.
+<h3>Example</h3>
+<pre>
+static int arx[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * parx[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+static int int_comparer(value_type x, value_type y)
+{
+	return *(int *)x - *(int *)y;
+}
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&parx[0]);
+	c_iterator last = c_get_array_iterator((void**)&parx[10]);
+	c_iterator first2 = c_get_array_iterator((void**)&pary[0]);
+
+	c_binary_predicate bp =  c_binary_negate(int_comparer);
+	
+	assert(c_equal(first, last, first2, bp));
+}
+
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Note that this is very similar to the behavior of <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>:  The
+only real difference is that while <tt>equal</tt> will simply return <tt>false</tt>
+if the two ranges differ, <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt> returns the first location where
+they do differ.  The expression <tt>equal(f1, l1, f2)</tt> is precisely equivalent
+to the expression <tt>mismatch(f1, l1, f2).first == l1</tt>, and this is in
+fact how <tt>equal</tt> could be implemented.
+<h3>See also</h3>
+<tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><!--<A href="search.html">-->search<!--</A>--></tt>, <tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/fill.html b/src/tstl2cl/doc/eng/fill.html
new file mode 100644
index 0000000..f828963
--- /dev/null
+++ b/src/tstl2cl/doc/eng/fill.html
@@ -0,0 +1,78 @@
+<HTML>
+<Head>
+<Title>fill</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_fill</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+void c_fill(c_iterator first, c_iterator last, value_type value); 
+</pre>                   
+<h3>Description</h3>
+<tt>Fill</tt> assigns the value <tt>value</tt> to every element in the range
+<tt>[first, last)</tt>.  That is, for every iterator <tt>i</tt> in <tt>[first, last)</tt>,
+it performs the assignment <tt>*i = value</tt>.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+<tt>ForwardIterator</tt> is a model of <A href="ForwardIterator.html">Forward Iterator</A>. <A href="#1">[1]</A>
+<LI>
+<tt>ForwardIterator</tt> is mutable.
+<LI>
+<tt>T</tt> is a model of <A href="Assignable.html">Assignable</A>.
+<LI>
+<tt>T</tt> is convertible to <A href="ForwardIterator.html">Forward Iterator</A>'s value type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear. <tt>Fill</tt> performs exactly <tt>last - first</tt> assignments.
+<h3>Example</h3>
+<pre>
+<A href="Vector.html">c_vector</A> V;
+c_vector_create(&V, NULL);
+c_vector_reserve(&V, 5);
+c_fill(V.begin(), V.end(), 0);
+c_vector_destroy(&V);
+
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The reason that <tt>fill</tt> requires its argument to be a mutable
+<A href="ForwardIterator.html">forward iterator</A>, rather than merely an <A href="OutputIterator.html">output iterator</A>, is that 
+it uses a range <tt>[first, last)</tt> of iterators.  There is no sensible
+way to describe a range of <A href="OutputIterator.html">output iterators</A>, because it is
+impossible to compare two <A href="OutputIterator.html">output iterators</A> for equality.
+The <tt><A href="fill_n.html">fill_n</A></tt> algorithm does have an interface that permits use of
+an <A href="OutputIterator.html">output iterator</A>.
+<h3>See also</h3>
+<tt><A href="copy.html">copy</A></tt>, <tt><A href="fill_n.html">fill_n</A></tt>, <tt><!--<A href="generate.html">-->generate<!--</A>--></tt>, <tt><!--<A href="generate_n.html">-->generate_n<!--</A>--></tt>, <tt><!--<A href="iota.html">-->iota<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/fill_n.html b/src/tstl2cl/doc/eng/fill_n.html
new file mode 100644
index 0000000..c7a353a
--- /dev/null
+++ b/src/tstl2cl/doc/eng/fill_n.html
@@ -0,0 +1,73 @@
+<HTML>
+<Head>
+<Title>fill_n</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>fill_n</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+c_iterator c_fill_n(c_iterator first, size_t n, const value_type value);
+</pre>                   
+<h3>Description</h3>
+<tt>Fill_n</tt> assigns the value <tt>value</tt> to every element in the range
+<tt>[first, first+n)</tt>.  That is, for every iterator <tt>i</tt> in <tt>[first, first+n)</tt>,
+it performs the assignment <tt>*i = value</tt>.  The return value is <tt>first +
+n</tt>.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+<tt>OutputIterator</tt> is a model of <A href="OutputIterator.html">Output Iterator</A>.
+<LI>
+<tt>Size</tt> is an integral type (either signed or unsigned).
+<LI>
+<tt>T</tt> is a model of <A href="Assignable.html">Assignable</A>.
+<LI>
+<tt>T</tt> is convertible to a type in <tt>OutputIterator</tt>'s set of value types.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>n &gt;= 0</tt>.
+<LI>
+There is enough space to hold <tt>n</tt> values.  That is,
+   <tt>[first, first+n)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear. <tt>Fill_n</tt> performs exactly <tt>n</tt> assignments.
+<h3>Example</h3>
+<pre>
+<A href="Vector.html">c_vector</A> V;
+c_vector_create(&V);
+c_vector_reserve(&V, 7);
+c_fill_n(c_begin_vector(&V), 4, 0);
+c_vector_destroy(&V);
+
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<tt><A href="copy.html">copy</A></tt>, <tt><A href="fill.html">fill</A></tt>, <tt><!--<A href="generate.html">-->generate<!--</A>--></tt>, <tt><!--<A href="generate_n.html">-->generate_n<!--</A>--></tt>, <tt><!--<A href="iota.html">-->iota<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/find.html b/src/tstl2cl/doc/eng/find.html
new file mode 100644
index 0000000..3962e66
--- /dev/null
+++ b/src/tstl2cl/doc/eng/find.html
@@ -0,0 +1,80 @@
+<HTML>
+<Head>
+<Title>find</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_find</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+c_iterator c_find(c_iterator first, c_iterator last,
+                   const value_type value);
+</pre>                   
+<h3>Description</h3>
+Returns the first iterator <tt>i</tt> in the range <tt>[first, last)</tt> such that
+<tt>*i == value</tt>.  Returns <tt>last</tt> if no such iterator exists.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+EqualityComparable is a model of <A href="EqualityComparable.html">EqualityComparable</A>.
+<LI>
+InputIterator is a model of <A href="InputIterator.html">InputIterator</A>.
+<LI>
+Equality is defined between objects of type EqualityComparable and
+   objects of InputIterator's value type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear: at most <tt>last - first</tt> comparisons for equality.
+<h3>Example</h3>
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	iter = c_find(first, last, pary[5]);
+	assert(!ITER_EQUAL(iter, last));
+	
+}
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="find_if.html">find_if</A>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/find_if.html b/src/tstl2cl/doc/eng/find_if.html
new file mode 100644
index 0000000..1b20fd8
--- /dev/null
+++ b/src/tstl2cl/doc/eng/find_if.html
@@ -0,0 +1,92 @@
+<HTML>
+<Head>
+<Title>find_if</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_find_if</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+c_iterator c_find_if(c_iterator first, c_iterator last,
+                      UNARY_PREDICATE pred);
+</pre>                   
+<h3>Description</h3>
+Returns the first iterator <tt>i</tt> in the range <tt>[first, last)</tt> such that
+<tt>pred(*i)</tt> is true.  Returns <tt>last</tt> if no such iterator exists.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+Predicate is a model of <A href="Predicate.html">Predicate</A>.
+<LI>
+InputIterator is a model of <A href="InputIterator.html">InputIterator</A>.
+<LI>
+The value type of InputIterator is convertible to the argument type
+   of Predicate.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+<LI>
+For each iterator <tt>i</tt> in the range <tt>[first, last)</tt>, *i is in the
+   domain of Predicate. 
+</UL>
+<h3>Complexity</h3>
+Linear: at most <tt>last - first</tt> applications of <tt>Pred</tt>.
+<h3>Example</h3>
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+static c_bool is_even(value_type val)
+{
+	return !((*((int*)val)) % 2);
+}
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	printf("find_if is_even by array:\n");
+	while(!ITER_EQUAL(first, last))
+	{
+		first = c_find_if(first, last, is_even);
+		if(ITER_EQUAL(first, last))
+			break;
+		printf("find a even : %d\n", *(int *)ITER_REF(first));
+		ITER_INC(first);
+	}
+}
+
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="find.html">find</A>.
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/for_each.html b/src/tstl2cl/doc/eng/for_each.html
new file mode 100644
index 0000000..7e27cf7
--- /dev/null
+++ b/src/tstl2cl/doc/eng/for_each.html
@@ -0,0 +1,93 @@
+<HTML>
+<Head>
+<Title>for_each</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_for_each</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+UNARY_FUNCTION c_for_each(c_iterator first, c_iterator last, UNARY_FUNCTION pf)
+</pre>                   
+<h3>Description</h3>
+<tt>For_each</tt> applies the <A href="functors.html">function object</A> <tt>f</tt> to each element in the
+range <tt>[first, last)</tt>; <tt>f</tt>'s return value, if any, is ignored.
+Applications are performed in forward order, <i>i.e.</i> from <tt>first</tt> to
+<tt>last</tt>.  <tt>For_each</tt> returns the function object after it has been 
+applied to each element. <A href="#1">[1]</A>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+<tt>InputIterator</tt> is a model of <A href="InputIterator.html">Input Iterator</A>
+<LI>
+<tt>UnaryFunction</tt> is a model of <A href="UnaryFunction.html">Unary Function</A>
+<LI>
+<tt>UnaryFunction</tt> does not apply any non-constant operation through
+   its argument.
+<LI>
+<tt>InputIterator</tt>'s value type is convertible to <tt>UnaryFunction</tt>'s
+   argument type.       
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear.  Exactly <tt>last - first</tt> applications of <tt>UnaryFunction</tt>.
+<h3>Example</h3>
+<pre>
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+static value_type plus_one(value_type val)
+{
+	*(int*)val += 1;
+	return val;
+}
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	c_for_each(first, last, plus_one);
+}
+
+</pre>  
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+This return value is sometimes useful, since a function object
+may have local state.  It might, for example, count the number of
+times that it is called, or it might have a status flag to indicate
+whether or not a call succeeded.
+<h3>See also</h3>
+The <A href="functors.html">function object overview</A>, <tt><A href="count.html">count</A></tt>, <tt><A href="copy.html">copy</A></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/functors.html b/src/tstl2cl/doc/eng/functors.html
new file mode 100644
index 0000000..654cfe9
--- /dev/null
+++ b/src/tstl2cl/doc/eng/functors.html
@@ -0,0 +1,222 @@
+<HTML>
+<Head>
+<Title>Function Objects</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>Function Objects</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: overview</TD>
+</TR>
+</Table>
+
+<h3>Summary</h3>
+A <i>Function Object</i>, or <i>Functor</i> (the two terms are synonymous)
+is simply any object that can be called as if it is a function.
+An ordinary function is a function object, and so is a function pointer;
+more generally, so is an object of a class that defines
+<tt>operator()</tt>.
+<h3>Description</h3>
+The basic function object concepts are <!--<A href="Generator.html">-->Generator<!--</A>-->,
+<A href="UnaryFunction.html">Unary Function</A>, and <A href="BinaryFunction.html">Binary Function</A>: these describe,
+respectively, objects that can be called as <tt>f()</tt>, <tt>f(x)</tt>, and
+<tt>f(x,y)</tt>.  (This list could obviously be extended to <i>ternary function</i>
+and beyond, but, in practice, no STL algorithms require function
+objects of more than two arguments.)  All other function object
+concepts defined by the STL are refinements of these three.
+<P>
+Function objects that return <tt>bool</tt> are
+an important special case.
+A <A href="UnaryFunction.html">Unary Function</A> whose return type is <tt>bool</tt> is called a
+<A href="Predicate.html">Predicate</A>, and a <A href="BinaryFunction.html">Binary Function</A> whose return type is 
+<tt>bool</tt> is called a <A href="BinaryPredicate.html">Binary Predicate</A>.
+<P>
+There is an important distinction, but a somewhat subtle one, between
+function objects and <i>adaptable function objects</i>. <A href="#1">[1]</A>  In general, a
+function object has restrictions on the type of its argument.  The
+type restrictions need not be simple, though: <tt>operator()</tt> may be
+overloaded, or may be a member template, or both.  Similarly, there
+need be no way for a program to determine what those restrictions are.
+An adaptable function object, however, does specify what the argument
+and return types are, and provides nested <tt>typedef</tt>s so that those
+types can be named and used in programs.  If a type <tt>F0</tt> is a model of
+<!--<A href="AdaptableGenerator.html">-->Adaptable Generator<!--</A>-->, then it must define
+<tt>F0::result_type</tt>.  Similarly, if <tt>F1</tt> is a model of 
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>--> then it must define 
+<tt>F1::argument_type</tt> and <tt>F1::result_type</tt>, and if <tt>F2</tt> is a model
+of <!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>--> then it must define 
+<tt>F2::first_argument_type</tt>, <tt>F2::second_argument_type</tt>, and
+<tt>F2::result_type</tt>.
+The STL provides base classes <tt><A href="unary_function.html">unary_function</A></tt> and
+<tt><A href="binary_function.html">binary_function</A></tt> to simplify the definition of
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Functions<!--</A>--> and <!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Functions<!--</A>-->. <A href="#2">[2]</A>
+<P>
+Adaptable function objects are important because they can be used by
+<i>function object adaptors</i>: function objects that transform or
+manipulate other function objects.  The STL provides many different
+function object adaptors, including <tt><!--<A href="unary_negate.html">-->unary_negate<!--</A>--></tt> (which returns
+the logical complement of the value returned by a particular
+<!--<A href="AdaptablePredicate.html">-->AdaptablePredicate<!--</A>-->), and <tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt> and
+<tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>, which perform composition of function object.
+<P>
+<!--
+Finally, the STL includes many different predefined function 
+objects, including arithmetic operations
+(<tt><A href="plus.html">plus</A></tt>, <tt><A href="minus.html">minus</A></tt>, <tt><A href="times.html">multiplies</A></tt>, <tt><A href="divides.html">divides</A></tt>, <tt><A href="modulus.html">modulus</A></tt>,
+and <tt><A href="negate.html">negate</A></tt>), comparisons (<tt><A href="equal_to.html">equal_to</A></tt>, <tt><A href="not_equal_to.html">not_equal_to</A></tt>
+<tt><A href="greater.html">greater</A></tt>, <tt><A href="less.html">less</A></tt>, <tt><A href="greater_equal.html">greater_equal</A></tt>, and <tt><A href="less_equal.html">less_equal</A></tt>),
+and logical operations (<tt><A href="logical_and.html">logical_and</A></tt>, <tt><A href="logical_or.html">logical_or</A></tt>, and
+<tt><A href="logical_not.html">logical_not</A></tt>).  It is possible to perform very sophisticated
+operations without actually writing a new function object, simply
+by combining predefined function objects and function object
+adaptors.-->
+<h3>Examples</h3>
+<pre>
+
+</pre>
+<h3>Concepts</h3>
+<UL>
+<LI>
+<!--<A href="Generator.html">-->Generator<!--</A>-->
+<LI>
+ <A href="UnaryFunction.html">Unary Function</A>
+<LI>
+ <A href="BinaryFunction.html">Binary Function</A>
+</UL>
+<UL>
+<LI>
+ <A href="Predicate.html">Predicate</A>
+<LI>
+ <A href="BinaryPredicate.html">Binary Predicate</A>
+</UL>
+<UL>
+<LI>
+<!--<A href="AdaptableGenerator.html">-->Adaptable Generator<!--</A>-->
+<LI>
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+<LI>
+<!--<A href="AdaptableBinaryFunction.html">-->Adaptable Binary Function<!--</A>-->
+<LI>
+<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->
+<LI>
+<!--<A href="AdaptableBinaryPredicate.html">-->Adaptable Binary Predicate<!--</A>-->
+</UL>
+<h3>Types</h3>
+<UL>
+<LI>
+<tt><!--<A href="plus.html">-->plus<!--</A>--></tt>
+<LI>
+<tt><!--<A href="minus.html">-->minus<!--</A>--></tt>
+<LI>
+<tt><!--<A href="times.html">-->multiplies<!--</A>--></tt> (formerly called <tt>times</tt>)
+<LI>
+<tt><!--<A href="divides.html">-->divides<!--</A>--></tt>
+<LI>
+<tt><!--<A href="modulus.html">-->modulus<!--</A>--></tt>,
+<LI>
+<tt><!--<A href="negate.html">-->negate<!--</A>--></tt>
+<LI>
+<tt><!--<A href="equal_to.html">-->equal_to<!--</A>--></tt>
+<LI>
+<tt><!--<A href="not_equal_to.html">-->not_equal_to<!--</A>--></tt>
+<LI>
+<tt><!--<A href="greater.html">-->greater<!--</A>--></tt>
+<LI>
+<tt><!--<A href="less.html">-->less<!--</A>--></tt>
+<LI>
+<tt><!--<A href="greater_equal.html">-->greater_equal<!--</A>--></tt>
+<LI>
+<tt><!--<A href="less_equal.html">-->less_equal<!--</A>--></tt>,
+<LI>
+<tt><!--<A href="logical_and.html">-->logical_and<!--</A>--></tt>
+<LI>
+<tt><!--<A href="logical_or.html">-->logical_or<!--</A>--></tt>
+<LI>
+<tt><!--<A href="logical_not.html">-->logical_not<!--</A>--></tt>
+<LI>
+<tt><!--<A href="subtractive_rng.html">-->subtractive_rng<!--</A>--></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="identity.html">identity</A></tt>
+<LI>
+<tt><!--<A href="project1st.html">-->project1st<!--</A>--></tt>
+<LI>
+<tt><!--<A href="project2nd.html">-->project2nd<!--</A>--></tt>
+<LI>
+<tt><A href="select1st.html">select1st</A></tt>
+<LI>
+<tt><!--<A href="select2nd.html">-->select2nd<!--</A>--></tt>
+</UL>
+<UL>
+<LI>
+<tt><A href="unary_function.html">unary_function</A></tt>
+<LI>
+<tt><A href="binary_function.html">binary_function</A></tt>
+</UL>
+<UL>
+<LI>
+<tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt>
+<LI>
+<tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>
+<LI>
+<tt><A href="unary_negate.html">unary_negate</A></tt>
+<LI>
+<tt><A href="binary_negate.html">binary_negate</A></tt>
+<LI>
+<tt><!--<A href="binder1st.html">-->binder1st<!--</A>--></tt>
+<LI>
+<tt><!--<A href="binder2nd.html">-->binder2nd<!--</A>--></tt>
+<LI>
+<tt><!--<A href="pointer_to_unary_function.html">-->pointer_to_unary_function<!--</A>--></tt>
+<LI>
+<tt><!--<A href="pointer_to_binary_function.html">-->pointer_to_binary_function<!--</A>--></tt>
+</UL>
+<h3>Functions</h3>
+<UL>
+<LI>
+<tt><!--<A href="unary_compose.html">-->compose1<!--</A>--></tt>
+<LI>
+<tt><!--<A href="binary_compose.html">-->compose2<!--</A>--></tt>
+<LI>
+<tt><A href="unary_negate.html">not1</A></tt>
+<LI>
+<tt><A href="binary_negate.html">not2</A></tt>
+<LI>
+<tt><!--<A href="binder1st.html">-->bind1st<!--</A>--></tt>
+<LI>
+<tt><!--<A href="binder2nd.html">-->bind2nd<!--</A>--></tt>
+<LI>
+<tt><!--<A href="ptr_fun.html">-->ptr_fun<!--</A>--></tt>
+</UL>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The reason for the name &quot;adaptable function object&quot; is that
+adaptable function objects may be used by function object adaptors.
+<P><A name="2">[2]</A>
+The <tt><A href="unary_function.html">unary_function</A></tt> and <tt><A href="binary_function.html">binary_function</A></tt> bases are
+similar to the <tt><!--<A href="input_iterator.html">-->input_iterator<!--</A>--></tt>, <tt><!--<A href="output_iterator.html">-->output_iterator<!--</A>--></tt>,
+<tt><!--<A href="forward_iterator.html">-->forward_iterator<!--</A>--></tt>, <tt><!--<A href="bidirectional_iterator.html">-->bidirectional_iterator<!--</A>--></tt>, and
+<tt><!--<A href="random_access_iterator.html">-->random_access_iterator<!--</A>--></tt> bases: they are completely empty,
+and serve only to provide type information.
+<P><A name="3">[3]</A>
+This is an example of how to use function objects; it is not
+the recommended way of calculating the sum of elements in a vector.
+The <tt><!--<A href="accumulate.html">-->accumulate<!--</A>--></tt> algorithm is a better way of calculating a sum.
+<h3>See also</h3>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/identity.html b/src/tstl2cl/doc/eng/identity.html
new file mode 100644
index 0000000..3f92f21
--- /dev/null
+++ b/src/tstl2cl/doc/eng/identity.html
@@ -0,0 +1,135 @@
+<HTML>
+<Head>
+<Title>identity</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_identity</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Identity</tt> is a <A href="UnaryFunction.html">Unary Function</A> that represents the identity
+function: it takes a single argument <tt>x</tt>, and returns <tt>x</tt>.
+<h3>Example</h3>
+<pre>
+int main()
+{
+	value_type x;
+	assert(x == c_identity().O(x));   
+}           
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_functional.h">c_functional.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_function.h">c_function.h</A>.  This class is an SGI
+extension; it is not part of the C++ standard.
+<h3>Template parameters</h3>
+<Table border>
+<TR>
+<TH>
+Parameter
+</TH>
+<TH>
+Description
+</TH>
+<TH>
+Default
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T</tt>
+</TD>
+<TD VAlign=top>
+The function object's argument type, and return type. <A href="#1">[1]</A>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Model of</h3>
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+<h3>Type requirements</h3>
+None.
+<h3>Public base classes</h3>
+<tt><A href="unary_function.html">unary_function</A></tt>
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>argument_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of <tt>identity</tt>'s argument: <tt>T</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>result_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of the result: <tt>T</tt>. <A href="#1">[1]</A>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>value_type (*O)(c_unary_function *, value_type)</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+Function call.  The return value is simply the argument.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+All of <tt>identity</tt>'s members are defined in the 
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+requirements.  <tt>Identity</tt> does not introduce any new members.
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+It is essential that the return type and the argument type are
+the same: generalizing <tt>identity</tt> to allow them to differ would not
+work.  The reason is that <tt>identity</tt> returns a const reference to
+its argument, rather than a copy of its argument.  If <tt>identity</tt> were
+allowed to perform a conversion, then this would be a dangling reference.
+<h3>See also</h3>
+The <A href="functors.html">function object overview</A>, 
+<tt><A href="select1st.html">select1st</A></tt>, <tt><!--<A href="select2nd.html">-->select2nd<!--</A>--></tt>, <tt><!--<A href="project1st.html">-->project1st<!--</A>--></tt>, <tt><!--<A href="project2nd.html">-->project2nd<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/index.html b/src/tstl2cl/doc/eng/index.html
new file mode 100644
index 0000000..3ce1475
--- /dev/null
+++ b/src/tstl2cl/doc/eng/index.html
@@ -0,0 +1,393 @@
+<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
+<html>
+  <head>
+    <title>Table of Contents: Translate STL 2 CL library</title>
+ </HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+        ALINK="#ff0000"> 
+<!--end header-->
+
+
+      <h1> Table of Contents: Translate STL 2 CL library</h1>
+
+      <OL>
+	<LI><A Href="introduction.html">Introduction to the tstl2cl</A>
+	<LI>Containers
+	  <OL>
+	    <LI>Concepts
+	      <OL>
+		<LI>General concepts
+		  <OL>
+		    <LI><A href="Container.html">Container</A>
+		    <!--<LI><A href="ForwardContainer.html">Forward Container</A>
+		    <LI><A href="ReversibleContainer.html">Reversible Container</A>
+		    <LI><A href="RandomAccessContainer.html">Random Access Container</A>-->
+		  </OL>
+		<LI>Sequences
+		  <OL>
+		    <!--<LI><A href="Sequence.html">Sequence</A>
+		    <LI><A href="FrontInsertionSequence.html">Front Insertion Sequence</A>
+		    <LI><A href="BackInsertionSequence.html">Back Insertion Sequence</A>-->
+		  </OL>
+		<LI>Associative Containers
+		  <OL>
+		    <!--<LI><A href="AssociativeContainer.html">Associative Container</A>
+		    <LI><A href="SimpleAssociativeContainer.html">Simple Associative Container</A>
+		    <LI><A href="PairAssociativeContainer.html">Pair Associative Container</A>
+		    <LI><A href="SortedAssociativeContainer.html">Sorted Associative Container</A>
+		    <LI><A href="HashedAssociativeContainer.html">Hashed Associative Container</A>
+		    <LI><A href="HashFunction.html">HashFunction</A>
+		    <LI><A href="UniqueAssociativeContainer.html">Unique Associative Container</A>
+		    <LI><A href="MultipleAssociativeContainer.html">Multiple Associative Container</A>
+		    <LI><A href="UniqueSortedAssociativeContainer.html">Unique Sorted Associative Container</A>
+		    <LI><A href="MultipleSortedAssociativeContainer.html">Multiple Sorted Associative Container</A>
+		    <LI><A href="UniqueHashedAssociativeContainer.html">Unique Hashed Associative Container</A>
+		    <LI><A href="MultipleHashedAssociativeContainer.html">Multiple Hashed Associative Container</A>-->
+		  </OL>
+	      </OL>
+	    <LI>Container classes
+	      <OL>
+		<LI>Sequences
+		  <OL>
+		    <LI><A href="Vector.html">vector</A>
+		    <!--<LI><A href="Deque.html">deque</A>-->
+		    <LI><A href="List.html">list</A>
+                    <!--<LI><A href="Slist.html">slist</A>
+		    <LI><A href="bit_vector.html">bit_vector</A>-->
+		  </OL>
+		<LI>Associative Containers
+		  <OL>
+		    <LI><A href="Set.html">set</A>
+		    <LI><A href="Map.html">map</A>
+		    <!--<LI><A href="multiset.html">multiset</A>
+		    <LI><A href="Multimap.html">multimap</A>
+		    <LI><A href="hash_set.html">hash_set</A>
+		    <LI><A href="hash_map.html">hash_map</A>
+		    <LI><A href="hash_multiset.html">hash_multiset</A>
+		    <LI><A href="hash_multimap.html">hash_multimap</A>
+		    <LI><A href="hash.html">hash</A>-->
+		  </OL>
+                <LI> String package
+                  <OL>
+                    <!--<LI><A href="character_traits.html">Character Traits</A>
+                    <LI><A href="char_traits.html">char_traits</A>
+		    <LI><A href="basic_string.html">basic_string</A>-->
+                  </OL>
+		  <!--<LI> <A href="Rope.html">rope</A>-->
+		<LI>Container adaptors
+		  <OL>
+		    <LI><A href="stack.html">stack</A>
+		    <LI><A href="queue.html">queue</A>
+		    <!--<LI><A href="priority_queue.html">priority_queue</A>-->
+		  </OL>
+		  <!--<LI> <A href="bitset.html">bitset</A>-->
+	      </OL>
+	  </OL>
+	      
+	<LI>Iterators
+	  <OL>
+	    <LI><A href="Iterators.html">Introduction</A>
+	    <LI>Concepts
+	      <OL>
+		      <!--<LI><A href="trivial.html">Trivial Iterator</A>-->
+		<LI><A href="InputIterator.html">Input Iterator</A>
+		<LI><A href="OutputIterator.html">Output Iterator</A>
+		<LI><A href="ForwardIterator.html">Forward Iterator</A>
+		<LI><A href="BidirectionalIterator.html">Bidirectional Iterator</A>
+		<LI><A href="RandomAccessIterator.html">Random Access Iterator</A>
+	</OL>
+	<!--
+	    <LI>Iterator Tags
+	      <OL>
+		<LI><A href="iterator_tags.html">Introduction</A>
+		<LI><A href="iterator_traits.html">iterator_traits</A>
+		<LI><A href="iterator_category.html">iterator_category</A>
+		<LI><A href="distance_type.html">distance_type</A>
+		<LI><A href="value_type.html">value_type</A>
+		<LI>Iterator tag classes
+		  <OL>
+		    <LI><A href="input_iterator_tag.html">input_iterator_tag</A>
+		    <LI><A href="output_iterator_tag.html">output_iterator_tag</A>
+		    <LI><A href="forward_iterator_tag.html">forward_iterator_tag</A>
+		    <LI><A href="bidirectional_iterator_tag.html">bidirectional_iterator_tag</A>
+		    <LI><A href="random_access_iterator_tag.html">random_access_iterator_tag</A>
+		  </OL>
+		<LI>Iterator base classes
+		  <OL>
+		    <LI><A href="input_iterator.html">input_iterator</A>
+		    <LI><A href="output_iterator.html">output_iterator</A>
+		    <LI><A href="forward_iterator.html">forward_iterator</A>
+		    <LI><A href="bidirectional_iterator.html">bidirectional_iterator</A>
+		    <LI><A href="random_access_iterator.html">random_access_iterator</A>
+		  </OL>
+	  </OL>
+	  -->
+	    <LI>Iterator functions
+	      <OL>
+		<LI><A href="distance.html">distance</A>
+		<LI><A href="advance.html">advance</A>
+	</OL>
+	<!--
+	    <LI>Iterator classes
+	      <OL>
+		<LI><A href="istream_iterator.html">istream_iterator</A>
+		<LI><A href="ostream_iterator.html">ostream_iterator</A>
+		<LI><A href="front_insert_iterator.html">front_insert_iterator</A>
+		<LI><A href="back_insert_iterator.html">back_insert_iterator</A>
+		<LI><A href="insert_iterator.html">insert_iterator</A>
+		<LI><A href="ReverseIterator.html">reverse_iterator</A>
+		<LI><A href="ReverseBidirectionalIterator.html">reverse_bidirectional_iterator</A>
+		<LI><A href="raw_storage_iterator.html">raw_storage_iterator</A>
+		<LI><A href="sequence_buffer.html">sequence_buffer</A>
+	</OL>
+	-->
+	  </OL>
+	<LI>Algorithms
+	  <OL>
+	    <LI>Non-mutating algorithms
+	      <OL>
+		<LI><A href="for_each.html">for_each</A>
+		<LI><A href="find.html">find</A>
+		<LI><A href="find_if.html">find_if</A>
+		<LI><A href="adjacent_find.html">adjacent_find</A>
+		<!--<LI><A href="find_first_of.html">find_first_of</A>-->
+		<LI><A href="count.html">count</A>
+		<LI><A href="count_if.html">count_if</A>
+		<!--<LI><A href="mismatch.html">mismatch</A>-->
+		<LI><A href="equal.html">equal</A>
+		<LI><A href="search.html">search</A>
+		<!--<LI><A href="search_n.html">search_n</A>
+		<LI><A href="find_end.html">find_end</A>-->
+	      </OL>
+	    <LI>Mutating algorithms
+	      <OL>
+		<LI><A href="copy.html">copy</A>
+		<!--<LI><A href="copy_n.html">copy_n</A>-->
+		<LI><A href="copy_backward.html">copy_backward</A>
+		<LI>Swap
+		  <OL>
+		    <LI><A href="swap.html">swap</A>
+		    <LI><A href="iter_swap.html">iter_swap</A>
+		    <!--<LI><A href="swap_ranges.html">swap_ranges</A>-->
+		  </OL>
+		  <!--<LI><A href="transform.html">transform</A>-->
+		<!--<LI>Replace
+		  <OL>
+		    <LI><A href="replace.html">replace</A>
+		    <LI><A href="replace_if.html">replace_if</A>
+		    <LI><A href="replace_copy.html">replace_copy</A>
+		    <LI><A href="replace_copy_if.html">replace_copy_if</A>
+	    </OL>-->
+		<LI><A href="fill.html">fill</A>
+		<LI><A href="fill_n.html">fill_n</A>
+		<!--<LI><A href="generate.html">generate</A>
+		<LI><A href="generate_n.html">generate_n</A>-->
+		<!--<LI>Remove
+		  <OL>
+		    <LI><A href="remove.html">remove</A>
+		    <LI><A href="remove_if.html">remove_if</A>
+		    <LI><A href="remove_copy.html">remove_copy</A>
+		    <LI><A href="remove_copy_if.html">remove_copy_if</A>
+	    	</OL>-->
+		<!--<LI><A href="unique.html">unique</A>
+		<LI><A href="unique_copy.html">unique_copy</A>-->
+		<LI><A href="reverse.html">reverse</A>
+		<!--<LI><A href="reverse_copy.html">reverse_copy</A>
+		<LI><A href="rotate.html">rotate</A>
+		<LI><A href="rotate_copy.html">rotate_copy</A>
+		<LI><A href="random_shuffle.html">random_shuffle</A>
+		<LI><A href="random_sample.html">random_sample</A>
+		<LI><A href="random_sample_n.html">random_sample_n</A>
+		<LI><A href="partition.html">partition</A>
+		<LI><A href="stable_partition.html">stable_partition</A>-->
+	      </OL>
+	    <LI>Sorting 
+	      <OL>
+		<!--<LI>Sort
+		  <OL>
+		    <LI><A href="sort.html">sort</A>
+		    <LI><A href="stable_sort.html">stable_sort</A>
+		    <LI><A href="partial_sort.html">partial_sort</A>
+		    <LI><A href="partial_sort_copy.html">partial_sort_copy</A>
+		    <LI><A href="is_sorted.html">is_sorted</A>
+		  </OL>
+		<LI><A href="nth_element.html">nth_element</A>
+		<LI>Binary search
+		  <OL>
+		    <LI><A href="lower_bound.html">lower_bound</A>
+		    <LI><A href="upper_bound.html">upper_bound</A>
+		    <LI><A href="equal_range.html">equal_range</A>
+		    <LI><A href="binary_search.html">binary_search</A>
+		  </OL>
+		<LI><A href="merge.html">merge</A>
+		<LI><A href="inplace_merge.html">inplace_merge</A>
+		<LI>Set operations on sorted ranges
+		  <OL>
+		    <LI><A href="includes.html">includes</A>
+		    <LI><A href="set_union.html">set_union</A>
+		    <LI><A href="set_intersection.html">set_intersection</A>
+		    <LI><A href="set_difference.html">set_difference</A>
+		    <LI><A href="set_symmetric_difference.html">set_symmetric_difference</A>
+		  </OL>
+		<LI>Heap operations
+		  <OL>
+		    <LI><A href="push_heap.html">push_heap</A>
+		    <LI><A href="pop_heap.html">pop_heap</A>
+		    <LI><A href="make_heap.html">make_heap</A>
+		    <LI><A href="sort_heap.html">sort_heap</A>
+		    <LI><A href="is_heap.html">is_heap</A>
+		  </OL>
+		<LI>Minimum and maximum
+		  <OL>
+		    <LI><A href="min.html">min</A>
+		    <LI><A href="max.html">max</A>
+		    <LI><A href="min_element.html">min_element</A>
+		    <LI><A href="max_element.html">max_element</A>
+	    </OL>-->
+		<LI><A href="lexicographical_compare.html">lexicographical_compare</A>
+		<!--<LI><A href="lexicographical_compare_3way.html">lexicographical_compare_3way</A>
+		<LI><A href="next_permutation.html">next_permutation</A>
+		<LI><A href="prev_permutation.html">prev_permutation</A>-->
+	      </OL>
+	    <!--<LI>Generalized numeric algorithms
+	      <OL>
+		<LI><A href="iota.html">iota</A>
+		<LI><A href="accumulate.html">accumulate</A>
+		<LI><A href="inner_product.html">inner_product</A>
+		<LI><A href="partial_sum.html">partial_sum</A>
+		<LI><A href="adjacent_difference.html">adjacent_difference</A>
+		<LI><A href="power.html">power</A>
+	</OL>-->
+	  </OL>
+	<LI>Function Objects
+	  <OL>
+	    <LI><A Href="functors.html">Introduction</A>
+	    <LI>Concepts
+	      <OL>
+		      <!--<LI><A href="Generator.html">Generator</A>-->
+		<LI><A href="UnaryFunction.html">Unary Function</A>
+		<LI><A href="BinaryFunction.html">Binary Function</A>
+		<!--<LI><A href="AdaptableGenerator.html">Adaptable Generator</A>
+		<LI><A href="AdaptableUnaryFunction.html">Adaptable Unary Function</A>
+		<LI><A href="AdaptableBinaryFunction.html">Adaptable Binary Function</A>-->
+		<LI>Predicates
+		  <OL>
+		    <LI><A href="Predicate.html">Predicate</A>
+		    <LI><A href="BinaryPredicate.html">Binary Predicate</A>
+		    <!--<LI><A href="AdaptablePredicate.html">Adaptable Predicate</A>
+		    <LI><A href="AdaptableBinaryPredicate.html">Adaptable Binary Predicate</A>
+		    <LI><A href="StrictWeakOrdering.html">StrictWeakOrdering</A>-->
+		  </OL>
+		<!--<LI><A href="MonoidOperation.html">Monoid Operation</A>
+		<LI><A href="RandomNumberGenerator.html">Random Number Generator</A>-->
+	      </OL>
+	    <LI>Predefined function objects
+	      <OL>
+		<!--<LI>Arithmetic operations
+		  <OL>
+		    <LI><A href="plus.html">plus</A>
+		    <LI><A href="minus.html">minus</A>
+		    <LI><A href="times.html">multiplies</A> (formerly called "times")
+		    <LI><A href="divides.html">divides</A>
+		    <LI><A href="modulus.html">modulus</A>
+		    <LI><A href="negate.html">negate</A>
+	    </OL>-->
+		<!--<LI>Comparisons
+		  <OL>
+		    <LI><A href="equal_to.html">equal_to</A>
+		    <LI><A href="not_equal_to.html">not_equal_to</A>
+		    <LI><A href="less.html">less</A>
+		    <LI><A href="greater.html">greater</A>
+		    <LI><A href="less_equal.html">less_equal</A>
+		    <LI><A href="greater_equal.html">greater_equal</A>e
+	    </OL>-->
+		<!--<LI>Logical operations
+		  <OL>
+		    <LI><A href="logical_and.html">logical_and</A>
+		    <LI><A href="logical_or.html">logical_or</A>
+		    <LI><A href="logical_not.html">logical_not</A>
+	    </OL>-->
+		<LI>Generalized identity operations
+		  <OL>
+		    <LI><A href="identity.html">identity</A>
+		    <!--<LI><A href="project1st.html">project1st</A>
+		    <LI><A href="project2nd.html">project2nd</A>-->
+		    <LI><A href="select1st.html">select1st</A>
+		    <!--<LI><A href="select2nd.html">select2nd</A>-->
+		  </OL>
+		  <!--<LI><A href="subtractive_rng.html">subtractive_rng</A>-->
+	      </OL>
+	    <LI>Function object adaptors
+	      <OL>
+		<!--<LI><A href="binder1st.html">binder1st</A>
+		<LI><A href="binder2nd.html">binder2nd</A>
+		<LI><A href="ptr_fun.html">ptr_fun</A>
+		<LI><A href="pointer_to_unary_function.html">pointer_to_unary_function</A>
+		<LI><A href="pointer_to_binary_function.html">pointer_to_binary_function</A>-->
+		<LI><A href="unary_negate.html">unary_negate</A>
+		<LI><A href="binary_negate.html">binary_negate</A>
+		<!--<LI><A href="unary_compose.html">unary_compose</A>
+		<LI><A href="binary_compose.html">binary_compose</A>-->
+                <!--<LI>Member function adaptors
+                  <OL>
+                    <LI><A href="mem_fun_t.html">mem_fun</A>
+                    <LI><A href="mem_fun_ref_t.html">mem_fun_ref</A>
+                    <LI><A href="mem_fun1_t.html">mem_fun1</A>
+                    <LI><A href="mem_fun1_ref_t.html">mem_fun1_ref</A>
+	    </OL>-->
+	  </OL>
+	  </OL>
+	<LI>Utilities
+	  <OL>
+	    <LI>Concepts
+	      <OL>
+		<LI><A href="Assignable.html">Assignable</A>
+		<!--<LI><A href="DefaultConstructible.html">Default Constructible</A>-->
+		<LI><A href="EqualityComparable.html">Equality Comparable</A>
+		<LI><A href="LessThanComparable.html">LessThan Comparable</A>
+	</OL>
+	    <!--<LI>Functions
+	      <OL>
+		<LI><A href="operators.html">Relational Operators</A>
+	</OL>-->
+	    <LI>Classes
+	      <OL>
+		<LI><A href="pair.html">pair</A>
+	      </OL>
+	  </OL>
+	<!--<LI>Memory Allocation
+	  <OL>
+	    <LI>Classes
+	      <OL>
+		<LI><A href="Allocators.html">Allocators</A>
+		<LI><A href="raw_storage_iterator.html">raw_storage_iterator</A>
+	      </OL>
+	    <LI>Functions
+	      <OL>
+		<LI><A href="construct.html">construct</A>
+		<LI><A href="destroy.html">destroy</A>
+		<LI><A href="uninitialized_copy.html">uninitialized_copy</A>
+		<LI><A href="uninitialized_copy_n.html">uninitialized_copy_n</A>
+		<LI><A href="uninitialized_fill.html">uninitialized_fill</A>
+		<LI><A href="uninitialized_fill_n.html">uninitialized_fill_n</A>
+		<LI><A href="temporary_buffer.html">temporary_buffer</A>
+		<LI><A href="get_temporary_buffer.html">get_temporary_buffer</A>
+		<LI><A href="return_temporary_buffer.html">return_temporary_buffer</A>
+	      </OL>
+      </OL>-->
+        <!--<LI>Design documents
+          <OL>
+            <LI><A href="thread_safety.html">Thread safety</A>
+            <LI><A href="complexity.html">The meaning of complexity specifications</A>
+            <LI><A href="string_discussion.html">Representations of strings</A>
+          </OL>
+	<LI><A Href="stl_index_cat.html">Categorized Index</A>
+	<LI><A Href="stl_index.html">Full Index</A>-->
+      </OL>
+      
+
+<!--start footer--> 
+<HR SIZE="6">
+<P>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/introduction.html b/src/tstl2cl/doc/eng/introduction.html
new file mode 100644
index 0000000..1b20259
--- /dev/null
+++ b/src/tstl2cl/doc/eng/introduction.html
@@ -0,0 +1,215 @@
+<HTML VERSION="2.0">
+<HEAD>
+<TITLE>tstl2cl: Introduction</TITLE>
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+
+<CENTER><H1 ALIGN="CENTER">
+Introduction to the tstl2cl</H1>
+</CENTER><P>
+The Translate tstl2cl 2 CL library, or <I>tstl2cl</I>, is a C library of 
+container classes, algorithms, and iterators; it provides many of the 
+basic algorithms and data structures of computer science. The tstl2cl is a <I>generic</I>
+library, but different from template in C++, the <I>generic</I> occurs at runtime rather than 
+interpret time like instantiation. Its components are all instances of 'Container&lt;void*&gt;' of C++</P>
+<H2>
+Containers and algorithms</H2>
+<P>
+Like many class libraries, the tstl2cl includes <I>container</I> classes: 
+classes whose purpose is to contain other objects. The tstl2cl includes the 
+classes <TT><A href="Vector.html">vector</A></TT>, <TT><A href="List.html">list</A></TT>, <!--<TT><A href="Deque.html">deque</A></TT>,--> <TT><A href="set.html">set</A></TT>, <!--<TT><A href="multiset.html">multiset</A></TT>,--> <TT><A href="Map.html">map</A></TT>, <!--<TT><A href="Multimap.html">multimap</A></TT>,--> <!--<TT><A href="hash_set.html">hash_set</A></TT>,--> <!--<TT><A href="hash_multiset.html">hash_multiset</A></TT>,--> <!--<TT><A href="hash_map.html">hash_map</A></TT>,--> 
+<!--and <TT><A href="hash_multimap.html">hash_multimap</A></TT>-->. Each of these classes can contain any type of object's pointer. </P>
+
+<P>
+The tstl2cl also includes a large collection of <I>algorithms</I> that 
+manipulate the data stored in containers. You can reverse the order of 
+elements in a <TT>vector</TT>, for example, by using the <TT><A href="reverse.html">reverse</A></TT>
+ algorithm. </P>
+<PRE>
+      c_reverse(c_vector_begin(&v), c_vector_end(&v)); 
+</PRE>
+<P>
+There are two important points to notice about this call to <TT>reverse</TT>. 
+First, it is a global function. Second, it takes 
+two arguments rather than one: it operates on a <I>range</I> of 
+elements, rather than on a container. In this particular case the range 
+happens to be the entire container <TT>v.</TT></P>
+<P>
+The reason for both of these facts is the same: <TT>reverse</TT>, like 
+other algorithms, is decoupled from the tstl2cl container classes. This 
+means that <TT>reverse</TT> can be used not only to reverse elements in 
+vectors, but also to reverse elements in lists, and even elements in C 
+arrays. But tstl2cl assumes that the size of a C array's element must be 
+same as sizeof(void**). That means you will probably have to arrange your 
+data into a point array before you use this feature.
+The following program is a simple example. 
+</P>
+<PRE>
+      double A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };
+      double * B[6] = { &A[0], &A[1], &A[2], &A[3], &A[4], &A[5] };
+      c_reverse(c_get_array_iterator(&B[0]), c_get_array_iterator(&B[6]));
+      for (int i = 0; i &lt; 6; ++i)
+        printf("%f\t", *B[i]);
+</PRE>
+<P>
+This example uses a <I>range</I>, just like the example of reversing a <TT>vector</TT>: 
+the first argument to reverse is a pointer to the beginning of the 
+range, and the second argument points one element past the end of the 
+range. This range is denoted <TT>[A, A + 6)</TT>; the asymmetrical 
+notation is a reminder that the two endpoints are different, that the 
+first is the beginning of the range and the second is <I>one past</I>
+ the end of the range. </P>
+<H2>
+Iterators</H2>
+
+<P>
+Iterators are the mechanism that makes it possible to decouple 
+algorithms from containers: algorithms are templates, and are 
+parameterized by the type of iterator, so they are not restricted to a 
+single type of container. Consider, for example, how to write an 
+algorithm that performs linear search through a range. This is the 
+tstl2cl's <TT><A href="find.html">find</A></TT> algorithm. </P>
+<PRE>
+      c_iterator c_find(c_iterator first, c_iterator last, const value_type val) {
+		while(!ITER_EQUAL(first, last) && !(ITER_REF(first) == val))
+			ITER_INC(first);
+		return first;
+	}
+</PRE>
+<P>
+<TT>Find</TT> takes three arguments: two iterators that define a range, 
+and a value to search for in that range. It examines each iterator in 
+the range <TT>[first, last)</TT>, proceeding from the beginning 
+to the end, and stops either when it finds an iterator that points to <TT>value</TT>
+ or when it reaches the end of the range. </P>
+<P>
+<TT>First</TT> and <TT>last</TT> are declared to be of type <TT>c_iterator</TT>, 
+and <TT>c_iterator</TT> is a generic iterator applied to any containers. If 
+the container is a int* [] c array, the first two arguments to <TT>find</TT> are of type <TT>int**</TT> and 
+the third is of type <TT>int*</TT>, then it is as if you had called the 
+following function.</P>
+<PRE>
+      int** find(int** first, int** last, const int * value) {
+          while (first != last &amp;&amp; *first != value) ++first;
+          return first;
+      }
+</PRE>
+<H2>
+Concepts and Modeling</H2>
+<TT>Find</TT> isn't the only tstl2cl algorithm that has such a set of 
+requirements; the arguments to <TT><A href="for_each.html">for_each</A></TT> and <TT><A href="count.html">count</A></TT>, 
+and other algorithms, must satisfy the same requirements. These requirements are 
+sufficiently important that we give them a name: we call such a set of 
+type requirements a <I>concept</I>, and we call this particular 
+concept <B><A href="InputIterator.html">Input Iterator</A></B>. We say that a type <I>conforms to a concept</I>, or that 
+it <I>is a model of a concept</I>, if it satisfies all of those 
+requirements.  We say that <TT>int**</TT> is a model of <B>Input 
+Iterator</B> because <TT>int**</TT> provides all of the operations that 
+are specified by the <B>Input Iterator</B> requirements. </P>
+<P>
+Concepts are not a part of the C language; there is no way to declare 
+a concept in a program, or to declare that a particular type is a model 
+of a concept. Nevertheless, concepts are an extremely important part of 
+the tstl2cl. Using concepts makes it possible to write programs that 
+cleanly separate interface from implementation: the author of <TT>find</TT>
+ only has to consider the interface specified by the concept <B>Input 
+Iterator</B>, rather than the implementation of every possible type 
+that conforms to that concept. Similarly, if you want to use <TT>find</TT>, 
+you need only to ensure that the arguments you pass to it are models 
+of <B>Input Iterator. </B>This is the reason why <TT>find</TT> and <TT>reverse</TT>
+ can be used with <TT>list</TT>s, <TT>vector</TT>s, C arrays, and many 
+other types: programming in terms of concepts, rather than in terms of 
+specific types, makes it possible to reuse software components and to 
+combine components together. </P>
+<H2>
+Refinement</H2>
+<P>
+<B>Input Iterator</B> is, in fact, a rather weak concept: that is, it 
+imposes very few requirements. An <B>Input Iterator</B> must support a 
+subset of pointer arithmetic (it must be possible to increment an <B>Input 
+Iterator</B> using the standard iterator operator macro <TT>ITER_INC</TT>), but need 
+not support all operations of pointer arithmetic. This is sufficient 
+for <TT><A href="find.html">find</A></TT>, but some other algorithms require that their 
+arguments satisfy additional requirements. <TT><A href="reverse.html">Reverse</A></TT>, for 
+example, must be able to decrement its arguments as well as increment 
+them; it uses the expression <TT>ITER_DEC</TT>. In terms of concepts, we 
+say that <TT>reverse</TT>'s arguments must be models of <B><A href="BidirectionalIterator.html">Bidirectional Iterator</A></B> 
+rather than <B>Input Iterator</B>. </P>
+<P>
+The <B>Bidirectional Iterator</B> concept is very similar to the <B>Input
+ Iterator</B> concept: it simply imposes some additional requirements. 
+The types that are models of <B>Bidirectional Iterator</B> are a subset 
+of the types that are models of<B> Input Iterator</B>: every type that 
+is a model of <B>Bidirectional Iterator</B> is also a model of <B>Input 
+Iterator</B>. <TT>Int*</TT>, for example, is both a model of <B>Bidirectional 
+Iterator</B> and a model of <B>Input Iterator</B></P>
+<P>
+We describe the relationship between <B>Input Iterator</B> and <B>Bidirectional 
+Iterator</B> by saying that <B>Bidirectional Iterator</B> is a <I>refinement</I>
+ of <B>Input Iterator</B>. Refinement of concepts is very much like 
+inheritance of C++ classes; the main reason we use a different word, 
+instead of just calling it &quot;inheritance&quot;, is to emphasize 
+that refinement applies to concepts rather than to actual types.</P>
+<P>
+There are actually three more iterator concepts in addition to the two 
+that we have already discussed:  the five iterator concepts are 
+<B><A href="OutputIterator.html">Output Iterator</A></B>, <B><A href="InputIterator.html">Input Iterator</A></B>, 
+<B><A href="ForwardIterator.html">Forward Iterator</A></B>, <B><A href="BidirectionalIterator.html">Bidirectional Iterator</A></B>, and 
+<B><A href="RandomAccessIterator.html">Random Access Iterator</A>;</B> <B>Forward Iterator</B> is a 
+refinement of <B>Input Iterator</B>, <B>Bidirectional Iterator</B> 
+is a refinement of <B>Forward Iterator</B>, and <B>Random Access Iterator</B>
+is a refinement of <B>Bidirectional Iterator</B>.   (<B><A href="OutputIterator.html">Output Iterator</A></B>
+is related to the other four concepts, but it is not part of the hierarchy
+of refinement: it is not a refinement of any of the other iterator concepts,
+and none of the other iterator concepts are refinements of it.)
+
+The <I><A href="Iterators.html">Iterator Overview</A></I> has more information about iterators 
+in general. </P>
+<P>
+Container classes, like iterators, are organized into a hierarchy of 
+concepts. All containers are models of the concept <B><A href="Container.html">Container</A></B>; 
+more refined concepts, such as <B><!--<A href="Sequence.html">-->Sequence<!--</A>--></B> and 
+<B><!--<A href="AssociativeContainer.html">-->Associative Container<!--</A>--></B>, describe specific types of containers. 
+</P>
+<H2>
+Other parts of the tstl2cl</H2>
+<P>
+If you understand algorithms, iterators, and containers, then you 
+understand almost everything there is to know about the tstl2cl. The tstl2cl 
+does, however, include several other types of components. </P>
+<P>
+First, the tstl2cl includes several  <I>utilities</I>: very basic concepts 
+and functions that are used in many different parts of the library. The 
+concept<B> <A href="Assignable.html">Assignable</A></B>, for example, describes types that have 
+assignment operators and copy constructors; almost all tstl2cl classes are 
+models of <B>Assignable</B>, and almost all tstl2cl algorithms require 
+their arguments to be models of <B>Assignable</B>. </P>
+<P>
+Second, the tstl2cl includes some low-level mechanisms for allocating and 
+deallocating memory. <I><!--<A href="Allocators.html">-->Allocators<!--</A>--></I> are very specialized, and 
+you can safely ignore them for almost all purposes. </P>
+<P>
+Finally, the tstl2cl includes a few collection of <I><A href="functors.html">function objects</A></I>, 
+also known as <I>functors</I>. Just as iterators are a generalization 
+of pointers, function objects are a generalization of functions: a 
+function object is anything that you can call using the ordinary 
+function call syntax. There are several different concepts relating to 
+function objects, including <B><A href="UnaryFunction.html">Unary Function</A></B> (a function 
+object that takes a single argument, <I>i.e.</I> one that is called as <TT>f(x)</TT>) 
+and <B><A href="BinaryFunction.html">Binary Function</A></B> (a function object that takes two 
+arguments, <I>i.e.</I> one that is called as <TT>f(x, y)</TT>). Function 
+objects are an important part of generic programming because they allow 
+abstraction not only over the types of objects, but also over the 
+operations that are being performed. </P>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/iter_swap.html b/src/tstl2cl/doc/eng/iter_swap.html
new file mode 100644
index 0000000..4265371
--- /dev/null
+++ b/src/tstl2cl/doc/eng/iter_swap.html
@@ -0,0 +1,64 @@
+<HTML>
+<Head>
+<Title>iter_swap</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_iter_swap</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+void c_iter_swap(c_iterator a, c_iterator b);
+</pre>                   
+<h3>Description</h3>
+Equivalent to <tt><A href="swap.html">C_SWAP</A>(*a, *b, tmp)</tt>. <A href="#1">[1]</A>
+<h3>Definition</h3>
+Declared in <A href="../../c_algo.h">c_algo.h</A>.  
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+<tt>ForwardIterator1</tt> and <tt>ForwardIterator2</tt> are models of
+   <A href="ForwardIterator.html">Forward Iterator</A>.
+<LI>
+<tt>ForwardIterator1</tt> and <tt>ForwardIterator2</tt> are mutable.
+<LI>
+<tt>ForwardIterator1</tt> and <tt>ForwardIterator2</tt> have the same value type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>ForwardIterator1</tt> and <tt>ForwardIterator2</tt> are dereferenceable.
+</UL>
+<h3>Complexity</h3>
+See <tt><A href="swap.html">swap</A></tt> for a discussion.
+<h3>Example</h3>
+<pre>
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Strictly speaking, <tt>iter_swap</tt> is redundant.  It exists only for
+technical reasons: in some circumstances, some compilers have
+difficulty performing the type deduction required to interpret
+<tt>swap(*a, *b)</tt>.
+<h3>See also</h3>
+<tt><A href="swap.html">swap</A></tt>, <tt><!--<A href="swap_ranges.html">-->swap_ranges<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/lexicographical_compare.html b/src/tstl2cl/doc/eng/lexicographical_compare.html
new file mode 100644
index 0000000..77d1912
--- /dev/null
+++ b/src/tstl2cl/doc/eng/lexicographical_compare.html
@@ -0,0 +1,109 @@
+<HTML>
+<Head>
+<Title>lexicographical_compare</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_lexicographical_compare</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<tt>Lexicographical_compare</tt> is an overloaded name; there are actually
+two <tt>lexicographical_compare</tt> functions.
+<pre>
+
+c_bool c_lexicographical_compare(c_iterator first1, c_iterator last1,
+         	                    c_iterator first2, c_iterator last2,
+                	             COMPARER cmp);
+</pre>                   
+<h3>Description</h3>
+<tt>Lexicographical_compare</tt> returns <tt>true</tt> if the range of elements
+<tt>[first1, last1)</tt> is lexicographically less than the range of
+elements <tt>[first2, last2)</tt>, and <tt>false</tt> otherwise.  Lexicographical
+comparison means &quot;dictionary&quot; (element-by-element) ordering.  That is, 
+<tt>[first1, last1)</tt> is less than <tt>[first2, last2)</tt> if <tt>*first1</tt> is
+less than <tt>*first2</tt>, and greater if <tt>*first1</tt> is greater than <tt>*first2</tt>.
+If the two first elements are equivalent then <tt>lexicographical_compare</tt>
+compares the two second elements, and so on.  As with ordinary 
+dictionary order, the first range is considered to be less than 
+the second if every element in the first range is equal to the
+corresponding element in the second but the second contains more elements.
+<P>
+The two versions of <tt>lexicographical_compare</tt> differ in how they define whether one
+element is less than another.  The first version compares
+objects using <tt>operator&lt;</tt>, and the second compares objects using
+a <A href="functors.html">function object</A> <tt>comp</tt>.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+For the first version:
+<UL>
+<LI>
+<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator1</tt>'s value type is a model of <A href="LessThanComparable.html">LessThan Comparable</A>.
+<LI>
+<tt>InputIterator2</tt>'s value type is a model of <A href="LessThanComparable.html">LessThan Comparable</A>.
+<LI>
+If <tt>v1</tt> is an object of <tt>InputIterator1</tt>'s value type and <tt>v2</tt>
+   is an object of <tt>InputIterator2</tt>'s value type, then both <tt>v1 &lt; v2</tt>
+   and <tt>v2 &lt; v1</tt> are defined.
+</UL>
+For the second version:
+<UL>
+<LI>
+<tt>InputIterator1</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>InputIterator2</tt> is a model of <A href="InputIterator.html">Input Iterator</A>.
+<LI>
+<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary Predicate</A>.
+<LI>
+<tt>InputIterator1</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
+   first argument type and second argument type.
+<LI>
+<tt>InputIterator2</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s
+   first argument type and second argument type.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first1, last1)</tt> is a valid range.
+<LI>
+<tt>[first2, last2)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear.  At most <tt>2 * min(last1 - first1, last2 - first2)</tt> comparisons.
+<h3>Example</h3>
+<pre>
+
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<tt><A href="equal.html">equal</A></tt>, <tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, 
+<tt><!--<A href="lexicographical_compare_3way.html">-->lexicographical_compare_3way<!--</A>--></tt>,
+<tt><!--<A href="search.html">-->search<!--</A>--></tt>,
+<A href="LessThanComparable.html">LessThan Comparable</A>, 
+<!--<A href="StrictWeakOrdering.html">-->Strict Weak Ordering<!--</A>-->, 
+<tt><!--<A href="sort.html">-->sort<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/pair.html b/src/tstl2cl/doc/eng/pair.html
new file mode 100644
index 0000000..847d426
--- /dev/null
+++ b/src/tstl2cl/doc/eng/pair.html
@@ -0,0 +1,346 @@
+<HTML>
+<Head>
+<Title>pair</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_pair</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: utilities</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Pair</tt> is a heterogeneous pair: it holds one object of type 
+<tt>T1</tt> and one of type <tt>T2</tt>.  A pair is much like a <A href="Container.html">Container</A>,
+in that it &quot;owns&quot; its elements.  It is not actually a model of
+<A href="Container.html">Container</A>, though, because it does not support the standard
+methods (such as <A href="Iterators.html">iterators</A>) for accessing the elements of a
+<A href="Container.html">Container</A>.
+<P>
+Functions that need to return two values often return a <tt>pair</tt>.
+<h3>Example</h3>
+<pre>
+c_pair result = c_make_pair(&a, &b);
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_utility.h">c_utility.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_pair.h">c_pair.h</A>.
+<h3>Template parameters</h3>
+<Table border>
+<TR>
+<TH>
+Parameter
+</TH>
+<TH>
+Description
+</TH>
+<TH>
+Default
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T1</tt>
+</TD>
+<TD VAlign=top>
+The type of the first element stored in the <tt>pair</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>T2</tt>
+</TD>
+<TD VAlign=top>
+The type of the second element stored in the <tt>pair</tt>
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Model of</h3>
+<A href="Assignable.html">Assignable</A>
+<h3>Type requirements</h3>
+<tt>T1</tt> and <tt>T2</tt> must both be models of <A href="Assignable.html">Assignable</A>.  Additional operations
+have additional requirements.  <tt>Pair</tt>'s default constructor may only
+be used if both <tt>T1</tt> and <tt>T2</tt> are <!--<A href="DefaultConstructible.html">-->DefaultConstructible<!--</A>-->, 
+<tt>operator==</tt> may only be used if both <tt>T1</tt> and <tt>T2</tt> are
+<A href="EqualityComparable.html">EqualityComparable</A>, and <tt>operator&lt;</tt> may only be used if both
+<tt>T1</tt> and <tt>T2</tt> are <A href="LessThanComparable.html">LessThanComparable</A>.
+<h3>Public base classes</h3>
+None.
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>first_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>second_type</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<tt>pair()</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+The default constructor.  See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pair(const first_type&amp;, const second_type&amp;)</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+The pair constructor.  See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pair(const pair&amp;)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Assignable.html">Assignable</A>
+</TD>
+<TD VAlign=top>
+The copy constructor
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+<tt>c_pair&amp; operator=(const c_pair&amp;)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="Assignable.html">Assignable</A>
+</TD>
+<TD VAlign=top>
+The assignment operator
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>first</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>second</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<tt>bool operator==(const pair&amp;, const pair&amp;)</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>bool operator&lt;(const pair&amp;, const pair&amp;)</tt>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+<pre>
+c_pair c_make_pair(value_type, value_type)
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>pair</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+These members are not defined 
+in the <A href="Assignable.html">Assignable</A> requirements,
+but are specific to <tt>pair</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>first_type</tt>
+</TD>
+<TD VAlign=top>
+The type of the pair's first component.  This is a <tt>typedef</tt> for
+   the template parameter <tt>T1</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>second_type</tt>
+</TD>
+<TD VAlign=top>
+The type of the pair's second component.  This is a <tt>typedef</tt> for
+   the template parameter <tt>T2</tt>
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<tt>pair()</tt>
+</TD>
+<TD VAlign=top>
+The default constructor.  It uses constructs objects of types
+   <tt>T1</tt> and <tt>T2</tt> using their default constructors.  This constructor
+   may only be used if both <tt>T1</tt> and <tt>T2</tt> are <A href="DefaultConstructible.html">DefaultConstructible</A>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>pair(const first_type&amp; x, const second_type&amp; y)</tt>
+</TD>
+<TD VAlign=top>
+The pair constructor.  Constructs a pair such that <tt>first</tt> is constructed
+   from <tt>x</tt> and <tt>second</tt> is constructed from <tt>y</tt>.
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+<tt>first</tt>
+</TD>
+<TD VAlign=top>
+Public member variable of type <tt>first_type</tt>: the first object stored in the <tt>pair</tt>.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>second</tt>
+</TD>
+<TD VAlign=top>
+Public member variable of type <tt>second_type</tt>: The second object stored in the <tt>pair</tt>.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class T1, class T2&gt;
+bool operator==(const pair&lt;T1,T2&gt;&amp; x, 
+                const pair&lt;T1,T2&gt;&amp; y);
+</pre>
+</TD>
+<TD VAlign=top>
+The equality operator.  The return value is <tt>true</tt> if and only 
+the first elements of <tt>x</tt> and <tt>y</tt> are equal, and the second
+elements of <tt>x</tt> and <tt>y</tt> are equal.  This operator may only
+be used if both <tt>T1</tt> and <tt>T2</tt> are <A href="EqualityComparable.html">EqualityComparable</A>.
+This is a global function, not a member function.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class T1, class T2&gt;
+bool operator&lt;(const pair&lt;T1,T2&gt;&amp; x, 
+               const pair&lt;T1,T2&gt;&amp; y);
+</pre>
+</TD>
+<TD VAlign=top>
+The comparison operator.  It uses lexicographic comparison:
+the return value is <tt>true</tt> if the
+first element of <tt>x</tt> is less than the first element of <tt>y</tt>,
+and <tt>false</tt> if the first element of <tt>y</tt> is less than the first
+element of <tt>x</tt>.  If neither of these is the case, then
+<tt>operator&lt;</tt> returns the result of comparing the second elements
+of <tt>x</tt> and <tt>y</tt>.  This operator may only
+be used if both <tt>T1</tt> and <tt>T2</tt> are <A href="LessThanComparable.html">LessThanComparable</A>.
+This is a global function, not a member function.
+</TD>
+</TR>-->
+<TR>
+<TD VAlign=top>
+<pre>
+c_pair c_make_pair(value_type, value_type)
+</pre>
+</TD>
+<TD VAlign=top>
+Equivalent to <tt>pair&lt;T1, T2&gt;(x, y)</tt>.
+This is a global function, not a member function.
+It exists only for the sake of convenience.
+</TD>
+</tr>
+</table>
+<h3>Notes</h3>
+<h3>See also</h3>
+<A href="Assignable.html">Assignable</A>, <!--<A href="DefaultConstructible.html">-->Default Constructible<!--</A>-->, <A href="LessThanComparable.html">LessThan Comparable</A>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/reverse.html b/src/tstl2cl/doc/eng/reverse.html
new file mode 100644
index 0000000..33672ff
--- /dev/null
+++ b/src/tstl2cl/doc/eng/reverse.html
@@ -0,0 +1,76 @@
+<HTML>
+<Head>
+<Title>reverse</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_reverse</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+void c_reverse(c_iterator first, c_iterator last);
+</pre>                   
+<h3>Description</h3>
+<tt>Reverse</tt> reverses a range.  That is: for every <tt>i</tt> such that
+<tt>0 &lt;= i &lt;= (last - first) / 2)</tt>, it exchanges 
+<tt>*(first + i)</tt> and <tt>*(last - (i + 1))</tt>.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+BidirectionalIterator is a model of <A href="BidirectionalIterator.html">Bidirectional Iterator</A>.
+<LI>
+BidirectionalIterator is mutable.
+</UL>
+<h3>Preconditions</h3>
+<UL>
+<LI>
+<tt>[first, last)</tt> is a valid range.
+</UL>
+<h3>Complexity</h3>
+Linear: <tt>reverse(first, last)</tt> makes <tt>(last - first) / 2</tt> calls
+to <tt><A href="swap.html">swap</A></tt>.
+<h3>Example</h3>
+<pre>
+
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+
+int main()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_reverse(first, last);	
+
+	return 0;
+}
+</pre>
+<h3>Notes</h3>
+<h3>See also</h3>
+<tt><!--<A href="reverse_copy.html">-->reverse_copy<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/search.html b/src/tstl2cl/doc/eng/search.html
new file mode 100644
index 0000000..6be6440
--- /dev/null
+++ b/src/tstl2cl/doc/eng/search.html
@@ -0,0 +1,94 @@
+<HTML>
+	<Head>
+		<meta name="vs_showGrid" content="False">
+		<Title>search</Title> 
+		<!-- Generated by htmldoc -->
+	</Head>
+	<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" ALINK="#ff0000">
+		<!--end header-->
+		<p>
+			<H3><a href="index.html">Table of Contents</a></H3>
+			<hr size="6">
+			<BR>
+			<H1>search</H1>
+			<Table CellPadding="0" CellSpacing="0" width="100%">
+				<TR>
+					<TD Align="left" VAlign="top"><b>Category</b>: algorithms</TD>
+					<TD Align="right" VAlign="top"><b>Component type</b>: function</TD>
+				</TR>
+			</Table>
+			<h3>Prototype</h3>
+			<pre>
+c_iterator c_search(c_iterator first1, c_iterator last1, c_iterator first2, c_iterator last2, BINARY_PREDICATE pf);
+</pre>
+			<h3>Description</h3>
+			<tt>Search</tt> finds a subsequence within the range <tt>[first1, last1)</tt> that 
+			is identical to <tt>[first2, last2)</tt> when compared element-by-element. It 
+			returns an iterator pointing to the beginning of that subsequence, or else <tt>last1</tt>
+			if no such subsequence exists. Using the user-supplied <A href="functors.html">function 
+				object</A> <tt>binary_pred</tt>
+		to determine whether two elements are the same.
+		<P>
+			The search algorithm returns the first iterator <tt>i</tt> in <tt>[first1, last1 - 
+				(last2 - first2))</tt> such that, for every iterator <tt>j</tt> in <tt>[first2, 
+				last2)</tt>, <tt>binary_pred(*(i + (j - first2)), *j)</tt> is <tt>true</tt>. 
+			These conditions simply mean that every element in the subrange beginning with <tt>i</tt>
+			must be the same as the corresponding element in <tt>[first2, last2)</tt>.
+			<h3>Definition</h3>
+			Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, 
+			and in the nonstandard backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+			<h3>Requirements on types</h3>
+			<UL>
+				<LI>
+					<tt>ForwardIterator1</tt> is a model of <A href="ForwardIterator.html">Forward 
+						Iterator</A>.
+				<LI>
+					<tt>ForwardIterator2</tt> is a model of <A href="ForwardIterator.html">Forward 
+						Iterator</A>.
+				<LI>
+					<tt>BinaryPredicate</tt> is a model of <A href="BinaryPredicate.html">Binary 
+						Predicate</A>.
+				<LI>
+					<tt>ForwardIterator1</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s 
+				first argument type.
+				<LI>
+					<tt>ForwardIterator2</tt>'s value type is convertible to <tt>BinaryPredicate</tt>'s 
+					second argument type.</LI>
+			</UL>
+			<h3>Preconditions</h3>
+			<UL>
+				<LI>
+					<tt>[first1, last1)</tt>
+				is a valid range.
+				<LI>
+					<tt>[first2, last2)</tt> is a valid range.</LI>
+			</UL>
+			<h3>Complexity</h3>
+			Worst case behavior is quadratic: at most <tt>(last1 - first1) * (last2 - first2)</tt>
+			comparisons. This worst case, however, is rare. Average complexity is linear.
+			<h3>Example</h3>
+			&nbsp;&nbsp;int ary[] = { 0,1,2,3,4,5,6,7,8,9 };<br>
+			&nbsp;&nbsp;int * pary[] = { &amp;ary[0], &amp;ary[1], &amp;ary[2], &amp;ary[3], &amp;ary[4], &amp;ary[5], &amp;ary[6], &amp;ary[7], &amp;ary[8], &amp;ary[9] };<br>
+			&nbsp;&nbsp;c_iterator first = c_get_array_iterator((void **)&amp;pary[0]);<br> 
+			&nbsp;&nbsp;c_iterator last = c_get_array_iterator((void **)&amp;pary[10]);<br> 
+			&nbsp;&nbsp;int * tmppary[] = { &amp;ary[3], &amp;ary[2], &amp;ary[1], &amp;ary[0], &amp;ary[4], &amp;ary[5], &amp;ary[6], &amp;ary[7], &amp;ary[8], &amp;ary[9], 0 };<br> 
+			&nbsp;&nbsp;c_iterator result;<br> 
+			&nbsp;&nbsp;result = c_search(first, last, c_get_array_iterator((void **)&amp;tmppary[0]), c_get_array_iterator((void **)&amp;tmppary[1]), is_int_equal);<br>
+			<h3>Notes</h3>
+		<P>The reason that this range is <tt>[first1, last1 - (last2 - 
+				first2))</tt>, instead of simply <tt>[first1, last1)</tt>, is that we are 
+			looking for a subsequence that is equal to the <i>complete</i> sequence <tt>[first2, 
+				last2)</tt>. An iterator <tt>i</tt> can't be the beginning of such a 
+			subsequence unless <tt>last1 - i</tt> is greater than or equal to <tt>last2 - 
+				first2</tt>. Note the implication of this: you may call <tt>search</tt> with 
+			arguments such that <tt>last1 - first1</tt> is less than <tt>last2 - first2</tt>, 
+			but such a search will always fail.
+			<h3>See also</h3>
+			<tt><A href="find.html">find</A></tt>, <tt><A href="find_if.html">find_if</A></tt>,
+			<tt><!--<A href="find_end.html">-->find_end<!--</A>--></tt>, <tt><!--<A href="search_n.html">-->search_n<!--</A>--></tt>,
+			<tt><!--<A href="mismatch.html">-->mismatch<!--</A>--></tt>, <tt><A href="equal.html">equal</A></tt>
+			<!--start footer-->
+			<HR SIZE="6"><p>
+			<H3><a href="index.html">Table of Contents</a></H3>
+		</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/select1st.html b/src/tstl2cl/doc/eng/select1st.html
new file mode 100644
index 0000000..3d78f1f
--- /dev/null
+++ b/src/tstl2cl/doc/eng/select1st.html
@@ -0,0 +1,139 @@
+<HTML>
+<Head>
+<Title>select1st</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_select1st</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: functors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Select1st</tt> is a <A href="functors.html">function object</A> that takes a single argument, 
+a <tt><A href="pair.html">pair</A></tt> <A href="#1">[1]</A>, and returns the pair's first element.
+<h3>Example</h3>
+Print all of a <tt><A href="Map.html">map</A></tt>'s keys.
+<pre>
+int main()
+{
+	<a href="pair.html">c_pair</a> pair;
+	assert(pair.first == c_select1st().O(&pair));	
+}
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_functional.h">c_functional.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_function.h">c_function.h</A>.
+This function object is an SGI extension; it is not part of the C++
+standard.
+<h3>Template parameters</h3>
+<Table border>
+<TR>
+<TH>
+Parameter
+</TH>
+<TH>
+Description
+</TH>
+<TH>
+Default
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>Pair</tt>
+</TD>
+<TD VAlign=top>
+The function object's argument type.
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Model of</h3>
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>--><!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>--><!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+<h3>Type requirements</h3>
+There exist some types <tt>U</tt> and <tt>V</tt> such that <tt>Pair</tt> provides the same
+interface as a <tt><A href="pair.html">c_pair</A></tt>. <A href="#1">[1]</A>
+<h3>Public base classes</h3>
+<tt><A href="unary_function.html">unary_function</A></tt>
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>argument_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of <tt>select1st</tt>'s argument: <tt>Pair</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>result_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of the result: <tt>Pair::first_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+value_type (*O)(c_unary_function *, value_type)
+</pre>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+Function call.  The return value is <tt>p.first</tt>.
+</TD>
+</tr>
+</table>
+<h3>New members</h3>
+All of <tt>select1st</tt>'s members are defined in the 
+<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+requirements.  <tt>Select1st</tt> does not introduce any new members.
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+<tt>Pair</tt> is not actually required to be a <tt><A href="pair.html">pair</A>&lt;U,V&gt;</tt>, but
+merely to support the same interface as <tt><A href="pair.html">pair</A></tt>.  In almost all 
+cases the template parameter will be a <tt><A href="pair.html">pair</A></tt>, but it is occasionally 
+useful for it to be something else.  One example is a <tt>struct</tt> that
+has the members <tt>first</tt>, <tt>second</tt>, and <tt>third</tt>.
+<h3>See also</h3>
+<tt><A href="identity.html">identity</A></tt>, <tt><!--<A href="select2nd.html">-->select2nd<!--</A>--></tt>, <tt><!--<A href="project1st.html">-->project1st<!--</A>--></tt>, <tt><!--<A href="project2nd.html">-->project2nd<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/swap.html b/src/tstl2cl/doc/eng/swap.html
new file mode 100644
index 0000000..a9ad34c
--- /dev/null
+++ b/src/tstl2cl/doc/eng/swap.html
@@ -0,0 +1,80 @@
+<HTML>
+<Head>
+<Title>swap</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>C_SWAP</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Category</b>: algorithms</TD>
+<TD Align=right VAlign=top><b>Component type</b>: function</TD>
+</TR>
+</Table>
+
+<h3>Prototype</h3>
+<pre>
+C_SWAP(X, Y, TMP)
+</pre>                   
+<h3>Description</h3>
+Assigns the contents of <tt>a</tt> to <tt>b</tt> and the contents of <tt>b</tt> to <tt>a</tt>.
+This is used as a primitive operation by many other algorithms.
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_algorithm.h">c_algorithm.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_algo.h">c_algo.h</A>.
+<h3>Requirements on types</h3>
+<UL>
+<LI>
+Assignable is a model of <A href="Assignable.html">Assignable</A>.
+</UL>
+<h3>Preconditions</h3>
+None.
+<h3>Complexity</h3>
+Amortized constant time. <A href="#1">[1]</A> <A href="#2">[2]</A>
+<h3>Example</h3>
+<pre>
+int x, y, tmp;
+x = 0;
+y = 2;
+C_SWAP(x, y, tmp);
+assert(y == 0);
+
+</pre>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+The time required to <tt>swap</tt> two objects of type <tt>T</tt> will
+obviously depend on the type; &quot;constant time&quot; does not mean that
+performance will be the same for an 8-bit <tt>char</tt> as for a 128-bit
+<tt>complex&lt;double&gt;</tt>.  
+<P><A name="2">[2]</A>
+This implementation of <tt>swap</tt> makes one call to a copy
+constructor and two calls to an assignment operator; roughly, then, it
+should be expected to take about the same amount of time as three
+assignments.  In many cases, however, it is possible to write a
+specialized version of <tt>swap</tt> that is far more efficient.  Consider,
+for example, swapping two <tt><A href="Vector.html">vector</A>&lt;double&gt;</tt>s each of which has <tt>N</tt>
+elements.  The unspecialized version requires <tt>3*N</tt> assignments of
+<tt>double</tt>, but a specialized version requires only nine
+pointer assignments.  <b>This is important</b> because <tt>swap</tt> is used as
+a primitive operation in many other STL algorithms, and because
+containers of containers (<tt><A href="List.html">list</A>&lt;<A href="Vector.html">vector</A>&lt;char&gt; &gt;</tt>, for example)
+are very common.  The STL includes specialized versions of <tt>swap</tt> for
+all container classes.  User-defined types should also provide
+specialized versions of <tt>swap</tt> whenever it is possible to write one
+that is more efficient than the general version.
+<h3>See also</h3>
+<tt><A href="iter_swap.html">iter_swap</A></tt>, <tt><!--<A href="swap_ranges.html">-->swap_ranges<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/doc/eng/unary_negate.html b/src/tstl2cl/doc/eng/unary_negate.html
new file mode 100644
index 0000000..4c6f4c4
--- /dev/null
+++ b/src/tstl2cl/doc/eng/unary_negate.html
@@ -0,0 +1,201 @@
+<HTML>
+<Head>
+<Title>unary_negate</Title>
+<!-- Generated by htmldoc -->
+</HEAD>
+<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
+	ALINK="#ff0000"> 
+<!--end header-->
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+<hr size="6">
+<BR Clear>
+<H1>c_unary_negate</H1>
+
+<Table CellPadding=0 CellSpacing=0 width=100%>
+<TR>
+<TD Align=left VAlign=top><b>Categories</b>: functors, adaptors</TD>
+<TD Align=right VAlign=top><b>Component type</b>: type</TD>
+</TR>
+</Table>
+
+<h3>Description</h3>
+<tt>Unary_negate</tt> is a <A href="functors.html">function object</A> adaptor: it is an
+<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>--> that represents the logical negation
+of some other <!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->.  That is: if <tt>f</tt> is an
+object of class <tt>unary_negate&lt;AdaptablePredicate&gt;</tt>, then
+there exists an object <tt>pred</tt> of class <tt>AdaptablePredicate</tt>
+such that <tt>f(x)</tt> always returns the same value as <tt>!pred(x)</tt>. <A href="#1">[1]</A>
+There is rarely any reason to construct a <tt>unary_negate</tt>
+directly; it is almost always easier to use the helper function <tt>not1</tt>.
+<h3>Example</h3>
+Finds the first element in a list that does not lie in the range
+from 1 to 10.
+<pre>
+</pre>
+<h3>Definition</h3>
+Defined in the standard header <A href="../../include/c_functional.h">c_functional.h</A>, and in the nonstandard
+backward-compatibility header <A href="../../c_function.h">c_function.h</A>.
+<h3>Template parameters</h3>
+<Table border>
+<TR>
+<TH>
+Parameter
+</TH>
+<TH>
+Description
+</TH>
+<TH>
+Default
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>AdaptablePredicate</tt>
+</TD>
+<TD VAlign=top>
+The type of the function object that this <tt>unary_negate</tt> is the logical
+   negation of.
+</TD>
+<TD VAlign=top>
+&nbsp;
+</TD>
+</tr>
+</table>
+<h3>Model of</h3>
+<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->
+<h3>Type requirements</h3>
+<tt>AdaptablePredicate</tt> must be a model of <!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->.
+<h3>Public base classes</h3>
+<tt><A href="unary_function.html">unary_function</A></tt>
+<h3>Members</h3>
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Where defined
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>argument_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+	The type of the argument: <tt><!--<A href="AdaptablePredicate.html">-->AdaptablePredicate<!--</A>-->::argument_type</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>result_type</tt>
+</TD>
+<TD VAlign=top>
+	<!--<A href="AdaptableUnaryFunction.html">-->Adaptable Unary Function<!--</A>-->
+</TD>
+<TD VAlign=top>
+The type of the result: <tt>bool</tt>
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<tt>c_bool (*O)(c_unary_predicate *, argument_type)</tt>
+</TD>
+<TD VAlign=top>
+ <A href="UnaryFunction.html">Unary Function</A>
+</TD>
+<TD VAlign=top>
+Function call operator.
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+unary_negate(const AdaptablePredicate&amp; pred)
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>unary_negate</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="AdaptablePredicate.html">AdaptablePredicate</A>&gt;
+unary_negate&lt;AdaptablePredicate&gt;
+not1(const AdaptablePredicate&amp; pred);
+</pre>
+</TD>
+<TD VAlign=top>
+<tt>unary_negate</tt>
+</TD>
+<TD VAlign=top>
+See below.
+</TD>
+</tr>-->
+</table>
+<h3>New members</h3>
+These members are not defined in the 
+<!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->
+requirements, but are specific to 
+<tt>unary_negate</tt>.
+<Table border>
+<TR>
+<TH>
+Member
+</TH>
+<TH>
+Description
+</TH>
+</TR>
+<TR>
+<TD VAlign=top>
+<pre>
+unary_negate(const AdaptablePredicate&amp; pred)
+</pre>
+</TD>
+<TD VAlign=top>
+The constructor.  Creates a <tt>unary_negate&lt;AdaptablePredicate&gt;</tt>
+whose underlying predicate is <tt>pred</tt>.  
+</TD>
+</TR>
+<!--<TR>
+<TD VAlign=top>
+<pre>
+template &lt;class <A href="AdaptablePredicate.html">AdaptablePredicate</A>&gt;
+unary_negate&lt;AdaptablePredicate&gt;
+not1(const AdaptablePredicate&amp; pred);
+</pre>
+</TD>
+<TD VAlign=top>
+If <tt>p</tt> is of type <tt>AdaptablePredicate</tt> then
+<tt>not1(p)</tt> is equivalent to <tt>unary_negate&lt;AdaptablePredicate&gt;(p)</tt>,
+but more convenient.  This is a global function, not a member
+function.
+</TD>
+</tr>-->
+</table>
+<h3>Notes</h3>
+<P><A name="1">[1]</A>
+Strictly speaking, <tt>unary_negate</tt> is redundant.  It can be
+constructed using the function object <tt><!--<A href="logical_not.html">-->logical_not<!--</A>--></tt> and the
+adaptor <tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt>.
+<h3>See also</h3>
+The <A href="functors.html">function object overview</A>, <!--<A href="AdaptablePredicate.html">-->Adaptable Predicate<!--</A>-->, <A href="Predicate.html">Predicate</A>, 
+<tt><A href="binary_negate.html">binary_negate</A></tt>, <tt><!--<A href="unary_compose.html">-->unary_compose<!--</A>--></tt>, <tt><!--<A href="binary_compose.html">-->binary_compose<!--</A>--></tt>
+
+<!--start footer--> 
+<HR SIZE="6">
+<p>
+<H3><a href="index.html">Table of Contents</a></H3>
+</BODY>
+</HTML> 
diff --git a/src/tstl2cl/include/c_algorithm.h b/src/tstl2cl/include/c_algorithm.h
new file mode 100644
index 0000000..1b822a8
--- /dev/null
+++ b/src/tstl2cl/include/c_algorithm.h
@@ -0,0 +1,58 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_ALGORITHM_H
+#define _C_ALGORITHM_H
+
+#include "../c_algo.h"
+
+#endif /* _C_ALGORITHM_H */
diff --git a/src/tstl2cl/include/c_def.h b/src/tstl2cl/include/c_def.h
new file mode 100644
index 0000000..e38666a
--- /dev/null
+++ b/src/tstl2cl/include/c_def.h
@@ -0,0 +1,70 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_DEF_H
+#define _C_DEF_H
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+
+
+typedef int c_bool;
+
+#ifndef true
+#define true (!0)
+#endif
+#ifndef false
+#define false (0)
+#endif
+
+#endif /* _C_DEF_H */
diff --git a/src/tstl2cl/include/c_functional.h b/src/tstl2cl/include/c_functional.h
new file mode 100644
index 0000000..226a9db
--- /dev/null
+++ b/src/tstl2cl/include/c_functional.h
@@ -0,0 +1,58 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_FUNCTIONAL
+#define _C_FUNCTIONAL
+
+#include "../c_function.h"
+
+#endif /* _C_FUNCTIONAL */
diff --git a/src/tstl2cl/include/c_iterator.h b/src/tstl2cl/include/c_iterator.h
new file mode 100644
index 0000000..7b263ef
--- /dev/null
+++ b/src/tstl2cl/include/c_iterator.h
@@ -0,0 +1,184 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef  _C_ITERATOR_H
+#define _C_ITERATOR_H
+
+#include "c_def.h"
+
+#define c_iterator_ft 			_c_iterator_ft
+#define c_iterator_pft 			_c_iterator_pft
+#define c_reverse_iterator_ft 		_c_reverse_iterator_ft
+#define c_reverse_iterator_pft 		_c_reverse_iterator_pft
+#define c_iterator 			_c_iterator
+#define c_reverse_iterator 		_c_reverse_iterator
+#define c_distance 			_c_distance
+#define c_distance1 			_c_distance1
+#define c_advance 			_c_advance
+
+
+#define c_get_array_iterator		_c_get_array_iterator
+#define c_get_array_reverse_iterator	_c_get_array_reverse_iterator
+
+
+#define c_iterator_ref			_c_iterator_ref
+#define c_iterator_ref_assign		_c_iterator_ref_assign
+#define c_iterator_diff			_c_iterator_diff
+#define c_iterator_at			_c_iterator_at
+#define c_iterator_positive_n		_c_iterator_positvie_n
+#define c_iterator_negative_n		_c_iterator_negative_n
+#define c_iterator_equal		_c_iterator_equal
+#define c_iterator_less			_c_iterator_less
+
+
+typedef struct c_iterator c_iterator, * c_piterator;
+typedef const c_iterator c_const_iterator;
+
+typedef struct c_reverse_iterator  c_reverse_iterator, * c_preverse_iterator;
+typedef const c_reverse_iterator c_const_reverse_iterator;
+
+typedef struct c_iterator_ft c_iterator_ft, * c_iterator_pft;
+typedef struct c_reverse_iterator_ft c_reverse_iterator_ft, * c_reverse_iterator_pft;
+
+typedef ptrdiff_t difference_type;
+typedef void ** pointer;
+typedef const void ** const_pointer;
+typedef void * value_type;
+typedef size_t size_type;
+
+struct c_iterator
+{
+	c_iterator_pft _pft;
+	void * _i;
+};
+
+struct c_reverse_iterator
+{
+	c_reverse_iterator_pft _pft;
+	void * _i;
+};
+
+struct c_iterator_ft
+{ 
+    c_iterator (* assign)(c_piterator thiz, const c_piterator val);
+    value_type (* ref)(c_piterator thiz);
+    value_type (* ref_assign)(c_piterator thiz, const value_type val);
+    c_iterator (* inc)(c_piterator thiz);
+    c_iterator (* inc_n)(c_piterator thiz, difference_type n);
+    c_iterator (* dec)(c_piterator thiz);
+    c_iterator (* dec_n)(c_piterator thiz, difference_type n);
+    difference_type (* diff)(c_piterator thiz, const c_piterator val);
+    value_type (* at)(c_piterator thiz, difference_type n);
+    c_iterator (* positive_n)(c_piterator thiz, difference_type n);
+    c_iterator (* negative_n)(c_piterator thiz, difference_type n);
+    c_bool (* equal)(c_piterator thiz, const c_piterator val);
+    c_bool (* less)(c_piterator thiz, const c_piterator val);
+};
+
+struct c_reverse_iterator_ft
+{
+    c_reverse_iterator (* assign)(c_preverse_iterator thiz, const c_preverse_iterator val);
+    value_type (* ref)(c_preverse_iterator thiz);
+    value_type (* ref_assign)(c_preverse_iterator thiz, const value_type val);
+    c_reverse_iterator (* inc)(c_preverse_iterator thiz);
+    c_reverse_iterator (* inc_n)(c_preverse_iterator thiz, difference_type n);
+    c_reverse_iterator (* dec)(c_preverse_iterator thiz);
+    c_reverse_iterator (* dec_n)(c_preverse_iterator thiz, difference_type n);
+    difference_type (* diff)(c_preverse_iterator thiz, const c_preverse_iterator val);
+    value_type (* at)(c_preverse_iterator thiz, difference_type n);
+    c_reverse_iterator (* positive_n)(c_preverse_iterator thiz, difference_type n);
+    c_reverse_iterator (* negative_n)(c_preverse_iterator thiz, difference_type n);
+    c_bool (* equal)(c_preverse_iterator thiz, const c_preverse_iterator val);
+    c_bool (* less)(c_preverse_iterator thiz, const c_preverse_iterator val);
+};
+
+#define ITER_ASSIGN(X, Y)       (X)._pft->assign(&(X), &(Y))
+#define ITER_REF(X)             (X)._pft->ref(&(X))
+#define ITER_REF_ASSIGN(X, Y)   (X)._pft->ref_assign(&(X), (Y))
+#define ITER_INC(X)             (X)._pft->inc(&(X))
+#define ITER_INC_N(X, Y)        (X)._pft->inc_n(&(X), (Y))
+#define ITER_DEC(X)             (X)._pft->dec(&(X))
+#define ITER_DEC_N(X, Y)        (X)._pft->dec_n(&(X), (Y))
+#define ITER_DIFF(X, Y)     	(X)._pft->diff(&(X), &(Y))
+#define ITER_AT(X, Y)           (X)._pft->at(&(X), (Y))
+#define ITER_POSITIVE_N(X, Y)   (X)._pft->positive_n(&(X), (Y))
+#define ITER_NEGATIVE_N(X, Y)   (X)._pft->negative_n(&(X), (Y))
+#define ITER_EQUAL(X, Y)        (X)._pft->equal(&(X), &(Y))
+#define ITER_LESS(X, Y)         (X)._pft->less(&(X), &(Y))
+
+
+#define CHECK_OUTPUT_ITERATOR(X)            ((X)._pft->ref_assign) 
+#define CHECK_INPUT_ITERATOR(X)             ((X)._pft->ref)
+#define CHECK_FORWARD_ITERATOR(X)           ((X)._pft->inc)
+#define CHECK_BIDIRECTIONAL_ITERATOR(X)     ((X)._pft->inc && (X)._pft->dec)
+#define CHECK_RANDOM_ACCESS_ITERATOR(X)     ((X)._pft->at && (X)._pft->diff)
+
+typedef int (* COMPARER)(value_type , value_type);
+
+difference_type c_distance(c_iterator first, c_iterator last);
+void c_distance1(c_iterator first, c_iterator last, difference_type * pn);
+void c_advance(c_piterator pval, difference_type n);
+
+c_iterator c_get_array_iterator(void ** ppt);
+c_reverse_iterator c_get_array_reverse_iterator(void ** ppt);
+
+value_type c_iter_ref(c_iterator x);
+value_type c_iter_ref_assign(c_iterator x, const value_type val);
+difference_type c_iter_diff(c_iterator x, c_iterator y);
+value_type c_iter_at(c_iterator x, difference_type n);
+c_iterator c_iter_positive_n(c_iterator x, difference_type n);
+c_iterator c_iter_negative_n(c_iterator x, difference_type n);
+c_bool c_iter_equal(c_iterator x, c_iterator y);
+c_bool c_iter_less(c_iterator x, c_iterator y);
+
+
+#endif /* _C_ITERATOR_H */
diff --git a/src/tstl2cl/include/c_list.h b/src/tstl2cl/include/c_list.h
new file mode 100644
index 0000000..ac46434
--- /dev/null
+++ b/src/tstl2cl/include/c_list.h
@@ -0,0 +1,133 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Lao wen bo
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Lao wen bo 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_LIST_H
+#define _C_LIST_H
+
+#include "c_def.h"
+#include "c_iterator.h"
+
+#define c_list				_c_list
+#define c_list_create			__c_list
+#define c_list_destroy			__c_tsil
+#define c_plist				_c_plist
+#define c_list_begin			_c_list_begin 
+#define c_list_end			_c_list_end
+#define c_list_rbegin			_c_list_rbegin
+#define c_list_rend			_c_list_rend
+#define c_list_size			_c_list_size
+#define c_list_empty			_c_list_empty
+#define c_list_assign			_c_list_assign
+#define c_list_front			_c_list_front
+#define c_list_back			_c_list_back
+#define c_list_push_front		_c_list_push_front		
+#define c_list_push_back		_c_list_push_back
+#define c_list_pop_front		_c_list_pop_front
+#define c_list_pop_back			_c_list_pop_back
+#define c_list_swap			_c_list_swap
+#define c_list_insert			_c_list_insert
+#define c_list_insert2			_c_list_insert2
+#define c_list_erase			_c_list_erase
+#define c_list_erase2			_c_list_erase2
+#define c_list_clear			_c_list_clear
+#define c_list_splice			_c_list_splice
+#define c_list_splice1			_c_list_splice1
+#define c_list_splice2			_c_list_splice2
+#define c_list_remove			_c_list_remove
+#define c_list_unique			_c_list_unique
+#define c_list_merge			_c_list_merge
+#define c_list_sort			_c_list_sort
+#define c_list_equal			_c_list_equal
+#define c_list_less			_c_list_less
+
+
+typedef struct c_list
+{
+    COMPARER _cmp;   
+    void * _l;
+} c_list, * c_plist;
+
+
+void __c_list(c_plist thiz, COMPARER pcmp);
+void __c_tsil(c_plist thiz);
+c_iterator c_list_begin(c_plist thiz);
+c_iterator c_list_end(c_plist thiz);
+c_reverse_iterator c_list_rbegin(c_plist thiz);
+c_reverse_iterator c_list_rend(c_plist thiz);
+size_t c_list_size(c_plist thiz);
+c_bool c_list_empty(c_plist thiz);
+c_plist c_list_assign(c_plist thiz, const c_plist L);
+value_type c_list_front(c_plist thiz);
+value_type c_list_back(c_plist thiz);
+void c_list_push_front(c_plist thiz, const value_type val);
+void c_list_push_back(c_plist thiz, const value_type val);
+void c_list_pop_front(c_plist thiz);
+void c_list_pop_back(c_plist thiz);
+void c_list_swap(c_plist thiz, c_plist L);
+c_iterator c_list_insert(c_plist thiz, c_iterator pos, const value_type val);
+void c_list_insert2(c_plist thiz, c_iterator pos, c_iterator first, c_iterator last);
+c_iterator c_list_erase(c_plist thiz, c_iterator pos);
+c_iterator c_list_erase2(c_plist thiz, c_iterator first, c_iterator last);
+void c_list_clear(c_plist thiz);
+void c_list_splice(c_plist thiz, c_iterator pos, c_plist L);
+void c_list_splice1(c_plist thiz, c_iterator pos, c_plist L, c_iterator i);
+void c_list_splice2(c_plist thiz, c_iterator pos, c_plist L, c_iterator first, c_iterator last);
+void c_list_remove(c_plist thiz, value_type val);
+void c_list_unique(c_plist thiz);
+void c_list_merge(c_plist thiz, c_plist L);
+void c_list_sort(c_plist thiz);
+c_bool c_list_equal(c_plist thiz, const c_plist L);
+c_bool c_list_less(c_plist thiz, const c_plist L);
+
+
+
+#endif /* _C_LIST_H */
diff --git a/src/tstl2cl/include/c_map.h b/src/tstl2cl/include/c_map.h
new file mode 100644
index 0000000..978a699
--- /dev/null
+++ b/src/tstl2cl/include/c_map.h
@@ -0,0 +1,122 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_MAP_H
+#define _C_MAP_H
+
+#include "../c_tree.h"
+
+#define c_map				_c_map
+#define c_pmap				_c_pmap
+#define c_map_create			__c_map
+#define c_map_destroy			__c_pam
+#define c_map_assign			_c_map_assign
+#define c_map_begin			_c_map_begin
+#define c_map_end			_c_map_end
+#define c_map_rbegin			_c_map_rbegin
+#define c_map_rend			_c_map_rend
+#define c_map_empty			_c_map_empty
+#define c_map_size			_c_map_size
+#define c_map_max_size			_c_map_max_size
+#define c_map_at			_c_map_at
+#define c_map_swap			_c_map_swap
+#define c_map_insert			_c_map_insert
+#define c_map_insert1			_c_map_insert1
+#define c_map_insert2			_c_map_insert2
+#define c_map_erase			_c_map_erase
+#define c_map_erase1			_c_map_erase1
+#define c_map_erase2			_c_map_erase2
+#define c_map_clear			_c_map_clear
+#define c_map_find			_c_map_find
+#define c_map_count			_c_map_count
+#define c_map_lower_bound		_c_map_lower_bound
+#define c_map_upper_bound		_c_map_upper_bound
+#define c_map_equal_range		_c_map_equal_range
+#define c_map_less			_c_map_less
+#define c_map_equal			_c_map_equal
+
+
+typedef struct c_map
+{
+	void * _l;
+} c_map, * c_pmap;
+
+
+void __c_map(c_pmap thiz, COMPARER keycmp);
+void __c_pam(c_pmap thiz);
+c_pmap c_map_assign(c_pmap thiz, const c_pmap M);
+c_iterator c_map_begin(c_pmap thiz);
+c_iterator c_map_end(c_pmap thiz);
+c_reverse_iterator c_map_rbegin(c_pmap thiz);
+c_reverse_iterator c_map_rend(c_pmap thiz);
+c_bool c_map_empty(c_pmap thiz);
+size_type c_map_size(c_pmap thiz);
+size_type c_map_max_size(c_pmap thiz);
+value_type c_map_at(c_pmap thiz, key_type key);
+void c_map_swap(c_pmap thiz, c_pmap M);
+c_iter_bool_pair c_map_insert(c_pmap thiz, const value_type val);
+c_iterator c_map_insert1(c_pmap thiz, c_iterator position, const value_type val);
+void c_map_insert2(c_pmap thiz, c_iterator first, c_iterator last);
+void c_map_erase(c_pmap thiz, c_iterator position);
+size_type c_map_erase1(c_pmap thiz, key_type key);
+void c_map_erase2(c_pmap thiz, c_iterator first, c_iterator last);
+void c_map_clear(c_pmap thiz);
+c_iterator c_map_find(c_pmap thiz, key_type key);
+size_type c_map_count(c_pmap thiz, key_type key);
+c_iterator c_map_lower_bound(c_pmap thiz, key_type key);
+c_iterator c_map_upper_bound(c_pmap thiz, key_type key);
+c_iter_iter_pair c_map_equal_range(c_pmap thiz, key_type key);
+c_bool c_map_less(c_pmap thiz, const c_pmap M, COMPARER paircmp);
+c_bool c_map_equal(c_pmap thiz, const c_pmap M, COMPARER paircmp);
+
+
+#endif /* _C_MAP_H */
diff --git a/src/tstl2cl/include/c_queue.h b/src/tstl2cl/include/c_queue.h
new file mode 100644
index 0000000..cdb28a3
--- /dev/null
+++ b/src/tstl2cl/include/c_queue.h
@@ -0,0 +1,95 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_QUEUE_H
+#define _C_QUEUE_H
+
+#include "c_def.h"
+#include "c_iterator.h"
+
+
+#define c_queue				_c_queue
+#define c_pqueue			_c_pqueue
+#define c_queue_create			__c_queue
+#define c_queue_destroy			__c_eueuq
+#define c_queue_assign			_c_queue_assign
+#define c_queue_empty			_c_queue_empty
+#define c_queue_size			_c_queue_size
+#define c_queue_front			_c_queue_front
+#define c_queue_back			_c_queue_back
+#define c_queue_push			_c_queue_push
+#define c_queue_pop			_c_queue_pop
+#define c_queue_equal			_c_queue_equal
+#define c_queue_less			_c_queue_less
+
+
+typedef struct c_queue
+{
+	void * _l;
+} c_queue, * c_pqueue;
+
+
+void __c_queue(c_pqueue thiz, COMPARER pcmp);
+void __c_eueuq(c_pqueue thiz);
+c_pqueue c_queue_assign(c_pqueue thiz, const c_pqueue Q);
+c_bool c_queue_empty(c_pqueue thiz);
+size_type c_queue_size(c_pqueue thiz);
+value_type c_queue_front(c_pqueue thiz);
+value_type c_queue_back(c_pqueue thiz);
+void c_queue_push(c_pqueue thiz, const value_type val);
+void c_queue_pop(c_pqueue thiz);
+c_bool c_queue_equal(c_pqueue thiz, const c_pqueue Q);
+c_bool c_queue_less(c_pqueue thiz, const c_pqueue Q);
+
+
+#endif /* _C_QUEUE_H */
+
diff --git a/src/tstl2cl/include/c_set.h b/src/tstl2cl/include/c_set.h
new file mode 100644
index 0000000..53844a3
--- /dev/null
+++ b/src/tstl2cl/include/c_set.h
@@ -0,0 +1,120 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_SET_H
+#define _C_SET_H
+
+#include "../c_tree.h"
+
+#define c_set				_c_set
+#define c_pset				_c_pset
+#define c_set_create			__c_set
+#define c_set_destroy			__c_tes
+#define c_set_assign			_c_set_assign
+#define c_set_begin			_c_set_begin
+#define c_set_end			_c_set_end
+#define c_set_rbegin			_c_set_rbegin
+#define c_set_rend			_c_set_rend
+#define c_set_empty			_c_set_empty
+#define c_set_size			_c_set_size
+#define c_set_max_size			_c_set_max_size
+#define c_set_swap			_c_set_swap
+#define c_set_insert			_c_set_insert
+#define c_set_insert1			_c_set_insert1
+#define c_set_insert2			_c_set_insert2
+#define c_set_erase			_c_set_erase
+#define c_set_erase1			_c_set_erase1
+#define c_set_erase2			_c_set_erase2
+#define c_set_clear			_c_set_clear
+#define c_set_find			_c_set_find
+#define c_set_count			_c_set_count
+#define c_set_lower_bound		_c_set_lower_bound
+#define c_set_upper_bound		_c_set_upper_bound
+#define c_set_equal_range		_c_set_equal_range
+#define c_set_less			_c_set_less
+#define c_set_equal			_c_set_equal
+
+
+typedef struct c_set
+{
+	void * _l;
+} c_set, * c_pset;
+
+
+void __c_set(c_pset thiz, COMPARER pcmp);
+void __c_tes(c_pset thiz);
+c_pset c_set_assign(c_pset thiz, const c_pset S);
+c_iterator c_set_begin(c_pset thiz);
+c_iterator c_set_end(c_pset thiz);
+c_reverse_iterator c_set_rbegin(c_pset thiz);
+c_reverse_iterator c_set_rend(c_pset thiz);
+c_bool c_set_empty(c_pset thiz);
+size_type c_set_size(c_pset thiz);
+size_type c_set_max_size(c_pset thiz);
+void c_set_swap(c_pset thiz, c_pset S);
+c_iter_bool_pair c_set_insert(c_pset thiz, const value_type val);
+c_iterator c_set_insert1(c_pset thiz, c_iterator position, const value_type val);
+void c_set_insert2(c_pset thiz, c_iterator first, c_iterator last);
+void c_set_erase(c_pset thiz, c_iterator position);
+size_type c_set_erase1(c_pset thiz, key_type key);
+void c_set_erase2(c_pset thiz, c_iterator first, c_iterator last);
+void c_set_clear(c_pset thiz);
+c_iterator c_set_find(c_pset thiz, key_type key);
+size_type c_set_count(c_pset thiz, key_type key);
+c_iterator c_set_lower_bound(c_pset thiz, key_type key);
+c_iterator c_set_upper_bound(c_pset thiz, key_type key);
+c_iter_iter_pair c_set_equal_range(c_pset thiz, key_type key);
+c_bool c_set_less(c_pset thiz, const c_pset S);
+c_bool c_set_equal(c_pset thiz, const c_pset S);
+
+
+#endif /* _C_SET_H */
diff --git a/src/tstl2cl/include/c_stack.h b/src/tstl2cl/include/c_stack.h
new file mode 100644
index 0000000..7fd0f95
--- /dev/null
+++ b/src/tstl2cl/include/c_stack.h
@@ -0,0 +1,92 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_STACK_H
+#define _C_STACK_H
+
+#include "c_def.h"
+#include "c_iterator.h"
+
+
+#define c_stack				_c_stack
+#define c_pstack			_c_pstack
+#define c_stack_create			__c_stack
+#define c_stack_destroy			__c_kcats
+#define c_stack_assign			_c_stack_assign
+#define c_stack_empty			_c_stack_empty
+#define c_stack_size			_c_stack_size
+#define c_stack_top			_c_stack_top
+#define c_stack_push			_c_stack_push
+#define c_stack_pop			_c_stack_pop
+#define c_stack_equal			_c_stack_equal
+#define c_stack_less			_c_stack_less
+
+
+typedef struct c_stack
+{
+	void * _l;
+} c_stack, * c_pstack;
+
+void __c_stack(c_pstack thiz, COMPARER pcmp);
+void __c_kcats(c_pstack thiz);
+c_pstack c_stack_assign(c_pstack thiz, const c_pstack S);
+c_bool c_stack_empty(c_pstack thiz);
+size_type c_stack_size(c_pstack thiz);
+value_type c_stack_top(c_pstack thiz);
+void c_stack_push(c_pstack thiz, const value_type val);
+void c_stack_pop(c_pstack thiz);
+c_bool c_stack_equal(c_pstack thiz, const c_pstack S);
+c_bool c_stack_less(c_pstack thiz, const c_pstack S);
+
+
+#endif /* _C_STACK_H */
+
diff --git a/src/tstl2cl/include/c_utility.h b/src/tstl2cl/include/c_utility.h
new file mode 100644
index 0000000..27e4495
--- /dev/null
+++ b/src/tstl2cl/include/c_utility.h
@@ -0,0 +1,59 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_UTILITY_H
+#define _C_UTILITY_H
+
+#include "../c_pair.h"
+
+#endif /* _C_UTILITY_H */
+
diff --git a/src/tstl2cl/include/c_vector.h b/src/tstl2cl/include/c_vector.h
new file mode 100644
index 0000000..2dabe28
--- /dev/null
+++ b/src/tstl2cl/include/c_vector.h
@@ -0,0 +1,123 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+/*
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
+ */
+
+#ifndef _C_VECTOR_H
+#define _C_VECTOR_H
+
+#include "c_def.h"
+#include "c_iterator.h"
+
+#define c_vector			_c_vector
+#define c_pvector			_c_pvector
+#define c_vector_create			__c_vector
+#define c_vector_destroy		__c_rotcev
+#define c_vector_begin			_c_vector_begin 
+#define c_vector_end			_c_vector_end
+#define c_vector_rbegin			_c_vector_rbegin
+#define c_vector_rend			_c_vector_rend
+#define c_vector_size			_c_vector_size
+#define c_vector_max_size		_c_vector_max_size
+#define c_vector_empty			_c_vector_empty
+#define c_vector_at			_c_vector_at
+#define c_vector_assign			_c_vector_assign
+#define c_vector_reserve		_c_vector_reserve
+#define c_vector_front			_c_vector_front
+#define c_vector_back			_c_vector_back
+#define c_vector_push_back		_c_vector_push_back
+#define c_vector_pop_back		_c_vector_pop_back
+#define c_vector_swap			_c_vector_swap
+#define c_vector_insert			_c_vector_insert
+#define c_vector_insert2		_c_vector_insert2
+#define c_vector_fill_insert		_c_vector_fill_insert
+#define c_vector_erase			_c_vector_erase
+#define c_vector_erase2			_c_vector_erase2
+#define c_vector_clear			_c_vector_clear
+#define c_vector_resize			_c_vector_resize
+#define c_vector_equal			_c_vector_equal
+#define c_vector_less			_c_vector_less
+
+typedef struct c_vector
+{
+    COMPARER _cmp;   
+    void * _l;
+} c_vector, * c_pvector;
+
+void __c_vector(c_pvector thiz, COMPARER pcmp);
+void __c_rotcev(c_pvector thiz);
+c_iterator c_vector_begin(c_pvector thiz);
+c_iterator c_vector_end(c_pvector thiz);
+c_reverse_iterator c_vector_rbegin(c_pvector thiz);
+c_reverse_iterator c_vector_rend(c_pvector thiz);
+size_type c_vector_size(c_pvector thiz);
+size_type c_vector_max_size(c_pvector thiz);
+size_type c_vector_capacity(c_pvector thiz);
+c_bool c_vector_empty(c_pvector thiz);
+value_type c_vector_at(c_pvector thiz, size_type n);
+c_pvector c_vector_assign(c_pvector thiz, const c_pvector V);
+void c_vector_reserve(c_pvector thiz, size_t n);
+value_type c_vector_front(c_pvector thiz);
+value_type c_vector_back(c_pvector thiz);
+void c_vector_push_back(c_pvector thiz, const value_type val);
+void c_vector_pop_back(c_pvector thiz);
+void c_vector_swap(c_pvector thiz, c_pvector V);
+c_iterator c_vector_insert(c_pvector thiz, c_iterator pos, const value_type val);
+void c_vector_insert2(c_pvector thiz, c_iterator pos, c_iterator first, c_iterator last);
+void c_vector_fill_insert(c_pvector thiz, c_iterator pos, size_type n, const value_type val);
+c_iterator c_vector_erase(c_pvector thiz, c_iterator pos);
+c_iterator c_vector_erase2(c_pvector thiz, c_iterator first, c_iterator last);
+void c_vector_clear(c_pvector thiz);
+void c_vector_resize(c_pvector thiz, size_t n);
+c_bool c_vector_equal(c_pvector thiz, const c_pvector V);
+c_bool c_vector_less(c_pvector thiz, const c_pvector V);
+
+
+#endif /* _C_VECTOR_H */
diff --git a/src/tstl2cl/license.txt b/src/tstl2cl/license.txt
new file mode 100644
index 0000000..626aac4
--- /dev/null
+++ b/src/tstl2cl/license.txt
@@ -0,0 +1,49 @@
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+Copyright (c) 2007 Wenbo Lao(Rob Lao)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+
+	Wenbo Lao(Rob Lao) 
+	viewpl(at)gmail.com
diff --git a/src/tstl2cl/msvc/tstl2cl.sln b/src/tstl2cl/msvc/tstl2cl.sln
new file mode 100644
index 0000000..daba124
--- /dev/null
+++ b/src/tstl2cl/msvc/tstl2cl.sln
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tstl2cl", "tstl2cl.vcproj", "{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}.Debug.ActiveCfg = Debug|Win32
+		{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}.Debug.Build.0 = Debug|Win32
+		{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}.Release.ActiveCfg = Release|Win32
+		{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff --git a/src/tstl2cl/msvc/tstl2cl.vcproj b/src/tstl2cl/msvc/tstl2cl.vcproj
new file mode 100644
index 0000000..6238c36
--- /dev/null
+++ b/src/tstl2cl/msvc/tstl2cl.vcproj
@@ -0,0 +1,236 @@
+<?xml version="1.0" encoding="gb2312"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="tstl2cl"
+	ProjectGUID="{252F98BA-71EB-4EA3-8BFD-2D88D3DDB535}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../include;../"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="5"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/tstl2cl.exe"
+				LinkIncremental="2"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/tstl2cl.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../include;../"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				RuntimeLibrary="4"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/tstl2cl.exe"
+				LinkIncremental="1"
+				GenerateDebugInformation="TRUE"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\c_algo.c">
+			</File>
+			<File
+				RelativePath="..\c_function.c">
+			</File>
+			<File
+				RelativePath="..\c_iterator.c">
+			</File>
+			<File
+				RelativePath="..\c_list.c">
+			</File>
+			<File
+				RelativePath="..\c_map.c">
+			</File>
+			<File
+				RelativePath="..\c_memory.c">
+			</File>
+			<File
+				RelativePath="..\c_pair.c">
+			</File>
+			<File
+				RelativePath="..\c_queue.c">
+			</File>
+			<File
+				RelativePath="..\c_set.c">
+			</File>
+			<File
+				RelativePath="..\c_stack.c">
+			</File>
+			<File
+				RelativePath="..\c_tree.c">
+			</File>
+			<File
+				RelativePath="..\c_vector.c">
+			</File>
+			<File
+				RelativePath="..\test\t_algo.c">
+			</File>
+			<File
+				RelativePath="..\test\t_list.c">
+			</File>
+			<File
+				RelativePath="..\test\t_main.c">
+			</File>
+			<File
+				RelativePath="..\test\t_map.c">
+			</File>
+			<File
+				RelativePath="..\test\t_queue.c">
+			</File>
+			<File
+				RelativePath="..\test\t_set.c">
+			</File>
+			<File
+				RelativePath="..\test\t_stack.c">
+			</File>
+			<File
+				RelativePath="..\test\t_tree.c">
+			</File>
+			<File
+				RelativePath="..\test\t_vector.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath="..\c_algo.h">
+			</File>
+			<File
+				RelativePath="..\include\c_algorithm.h">
+			</File>
+			<File
+				RelativePath="..\include\c_def.h">
+			</File>
+			<File
+				RelativePath="..\c_function.h">
+			</File>
+			<File
+				RelativePath="..\include\c_iterator.h">
+			</File>
+			<File
+				RelativePath="..\include\c_list.h">
+			</File>
+			<File
+				RelativePath="..\include\c_map.h">
+			</File>
+			<File
+				RelativePath="..\c_memory.h">
+			</File>
+			<File
+				RelativePath="..\c_pair.h">
+			</File>
+			<File
+				RelativePath="..\include\c_queue.h">
+			</File>
+			<File
+				RelativePath="..\include\c_set.h">
+			</File>
+			<File
+				RelativePath="..\include\c_stack.h">
+			</File>
+			<File
+				RelativePath="..\c_tree.h">
+			</File>
+			<File
+				RelativePath="..\include\c_vector.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/src/tstl2cl/pax_global_header b/src/tstl2cl/pax_global_header
new file mode 100644
index 0000000..93d26b5
--- /dev/null
+++ b/src/tstl2cl/pax_global_header
@@ -0,0 +1 @@
+52 comment=bb0a1194b2c8267b4f775301f6a5308feb2b6add
diff --git a/src/tstl2cl/test/t_algo.c b/src/tstl2cl/test/t_algo.c
new file mode 100644
index 0000000..91c2f04
--- /dev/null
+++ b/src/tstl2cl/test/t_algo.c
@@ -0,0 +1,867 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include "c_iterator.h"
+#include "c_algorithm.h"
+#include "c_vector.h"
+#include "c_list.h"
+#include "t_test.h"
+
+static int ary[] = { 0,1,2,3,4,5,6,7,8,9 };
+static int * pary[] = { &ary[0], &ary[1], &ary[2],
+			 &ary[3], &ary[4], &ary[5],
+			 &ary[6], &ary[7], &ary[8],
+			 &ary[9] };
+	
+static int int_comparer(value_type x, value_type y)
+{
+	return *(int *)x - *(int *)y;
+}
+
+static c_bool is_int_equal(value_type x, value_type y)
+{
+	return int_comparer(x, y) == 0;
+}
+
+static int print2(c_iterator first, c_iterator last)
+{
+	while(!ITER_EQUAL(first, last))
+	{
+		printf("%d\n", *(int *)ITER_REF(first));
+		ITER_INC(first);
+	}
+	return 0;
+}
+
+
+static int test_c_array()
+{
+	c_list list;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	__c_list(&list, int_comparer);
+	
+	c_list_insert2(&list, c_list_begin(&list), first, last);
+
+	print2(c_list_begin(&list), c_list_end(&list));
+
+	__c_tsil(&list);
+
+	return 0;
+}
+
+static int test_advance(c_iterator first, c_iterator last)
+{
+	c_iterator iter = first;
+	int i = 0;
+
+	while(1)
+	{
+		iter = first;
+		c_advance(&iter, i);
+		if(ITER_EQUAL(iter, last))
+			break;
+
+		printf("advance %d : %d\n", i, *(int *)ITER_REF(iter));
+		++ i;
+	}
+
+	return 0;
+}
+
+static int test_advance_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	printf("advance by c array:\n");
+	test_advance(first, last);
+	return 0;
+}
+
+static int test_advance_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	__c_vector(&vector, int_comparer);
+
+	c_vector_insert2(&vector, c_vector_begin(&vector), first, last);
+
+	printf("advance by vector:\n");	
+	test_advance(c_vector_begin(&vector), c_vector_end(&vector));
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_advance_by_c_list()
+{
+	c_list list;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	__c_list(&list, int_comparer);
+
+	c_list_insert2(&list, c_list_begin(&list), first, last);
+
+	printf("advance by list:\n");	
+	test_advance(c_list_begin(&list), c_list_end(&list));
+
+	__c_tsil(&list);
+	return 0;
+}
+
+
+static value_type plus_one(value_type val)
+{
+	*(int*)val += 1;
+	return val;
+}
+
+static value_type deduct_one(value_type val)
+{
+	*(int*)val -= 1;
+	return val;
+}
+
+static int test_for_each_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	printf("for each by c array:\n");
+	printf("plus one:\n");
+	c_for_each(first, last, plus_one);
+	print2(first, last);
+
+	printf("deduct one:\n");
+	c_for_each(first, last, deduct_one);
+	print2(first, last);
+
+	return 0;
+}
+
+static int test_for_each_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	__c_vector(&vector, int_comparer);
+
+	c_vector_insert2(&vector, c_vector_begin(&vector), first, last);
+
+	printf("for each by vector:\n");
+	printf("plus one:\n");
+	c_for_each(c_vector_begin(&vector), c_vector_end(&vector), plus_one);
+	print2(c_vector_begin(&vector), c_vector_end(&vector));
+
+	printf("deduct one:\n");
+	c_for_each(c_vector_begin(&vector), c_vector_end(&vector), deduct_one);
+	print2(c_vector_begin(&vector), c_vector_end(&vector));
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_for_each_by_c_list()
+{
+	c_list list;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	__c_list(&list, int_comparer);
+
+	c_list_insert2(&list, c_list_begin(&list), first, last);
+
+	printf("for each by c list:\n");
+	printf("plus one:\n");
+	c_for_each(c_list_begin(&list), c_list_end(&list), plus_one);
+	print2(c_list_begin(&list), c_list_end(&list));
+
+	printf("deduct one:\n");
+	c_for_each(c_list_begin(&list), c_list_end(&list), deduct_one);
+	print2(c_list_begin(&list), c_list_end(&list));
+
+	__c_tsil(&list);
+	return 0;
+}
+
+static int test_find_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	printf("find by c array:\n");
+	printf("to find 0:\n");
+	iter = c_find(first, last, pary[0]);
+	if(!ITER_EQUAL(iter, last))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 5:\n");
+	iter = c_find(first, last, pary[5]);
+	if(!ITER_EQUAL(iter, last))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 9:\n");
+	iter = c_find(first, last, pary[9]);
+	if(!ITER_EQUAL(iter, last))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+
+	printf("to find 10:\n");
+	iter = c_find(first, last, pary[10]);
+	if(!ITER_EQUAL(iter, last))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	return 0;
+}
+
+static int test_find_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	__c_vector(&vector, int_comparer);
+	c_vector_insert2(&vector, c_vector_end(&vector), first, last);
+
+	printf("find by vector:\n");
+	printf("to find 0:\n");
+	iter = c_find(c_vector_begin(&vector), c_vector_end(&vector), pary[0]);
+	if(!c_iter_equal(iter, c_vector_end(&vector)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 5:\n");
+	iter = c_find(c_vector_begin(&vector), c_vector_end(&vector), pary[5]);
+	if(!c_iter_equal(iter, c_vector_end(&vector)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 9:\n");
+	iter = c_find(c_vector_begin(&vector), c_vector_end(&vector), pary[9]);
+	if(!c_iter_equal(iter, c_vector_end(&vector)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+
+	printf("to find 10:\n");
+	iter = c_find(c_vector_begin(&vector), c_vector_end(&vector), pary[10]);
+	if(!c_iter_equal(iter, c_vector_end(&vector)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_find_by_c_list()
+{
+	c_list list;
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	__c_list(&list, int_comparer);
+	c_list_insert2(&list, c_list_end(&list), first, last);
+
+	printf("find by list:\n");
+	printf("to find 0:\n");
+	iter = c_find(c_list_begin(&list), c_list_end(&list), pary[0]);
+	if(!c_iter_equal(iter, c_list_end(&list)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 5:\n");
+	iter = c_find(c_list_begin(&list), c_list_end(&list), pary[5]);
+	if(!c_iter_equal(iter, c_list_end(&list)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+	
+	printf("to find 9:\n");
+	iter = c_find(c_list_begin(&list), c_list_end(&list), pary[9]);
+	if(!c_iter_equal(iter, c_list_end(&list)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+
+	printf("to find 10:\n");
+	iter = c_find(c_list_begin(&list), c_list_end(&list), pary[10]);
+	if(!c_iter_equal(iter, c_list_end(&list)))
+		printf("find it! it's %d\n", *(int*)ITER_REF(iter));
+	else
+		printf("not find!\n");
+
+	__c_tsil(&list);
+	return 0;
+}
+
+static c_bool is_even(value_type val)
+{
+	return !((*((int*)val)) % 2);
+}
+
+static int test_find_if_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	printf("find_if is_even by array:\n");
+	while(!ITER_EQUAL(first, last))
+	{
+		first = c_find_if(first, last, is_even);
+		if(ITER_EQUAL(first, last))
+			break;
+		printf("find a even : %d\n", *(int *)ITER_REF(first));
+		ITER_INC(first);
+	}
+
+	return 0;
+}
+
+static int test_find_if_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first, last;
+
+	__c_vector(&vector, int_comparer);
+
+	c_vector_insert2(&vector, c_vector_end(&vector), 
+				c_get_array_iterator((void**)&pary[0]),
+		       		c_get_array_iterator((void**)&pary[10]));
+
+	first = c_vector_begin(&vector);
+	last = c_vector_end(&vector);
+	printf("find_if is_even by vector:\n");
+	while(!ITER_EQUAL(first, last))
+	{
+		first = c_find_if(first, last, is_even);
+		if(ITER_EQUAL(first, last))
+			break;
+		printf("find a even : %d\n", *(int *)ITER_REF(first));
+		ITER_INC(first);
+	}
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_find_if_by_c_list()
+{
+	c_list list;
+	c_iterator first, last;
+
+	__c_list(&list, int_comparer);
+
+	c_list_insert2(&list, c_list_end(&list), 
+				c_get_array_iterator((void**)&pary[0]),
+		       		c_get_array_iterator((void**)&pary[10]));
+
+	first = c_list_begin(&list);
+	last = c_list_end(&list);
+
+	printf("find_if is_even by list:\n");
+	while(!ITER_EQUAL(first, last))
+	{
+		first = c_find_if(first, last, is_even);
+		if(ITER_EQUAL(first, last))
+			break;
+		printf("find a even : %d\n", *(int *)ITER_REF(first));
+		ITER_INC(first);
+	}
+
+	__c_tsil(&list);
+	return 0;
+}
+
+
+static c_bool multi_equal_30(value_type x, value_type y)
+{
+	return  *(int*)(x) * *(int*)(y) == 30;
+}
+
+static int test_adjacent_find_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	c_iterator iter;
+
+	printf("adjacent_find multi_equal_30 by array:\n");
+
+	iter = c_adjacent_find(first, last, multi_equal_30);
+	if(!ITER_EQUAL(iter, last))
+	{
+		printf("find : ");
+		first = ITER_POSITIVE_N(iter, 1);
+		printf("%d %d\n", *(int*)ITER_REF(iter), *(int*)ITER_REF(first));
+	}
+	else
+		printf("not find!\n");
+
+	return 0;	
+}
+
+static int test_adjacent_find_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first, last, iter;
+	__c_vector(&vector, int_comparer);
+	
+	c_vector_insert2(&vector, c_vector_end(&vector), 
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	first = c_vector_begin(&vector);
+	last = c_vector_end(&vector);
+
+	printf("adjacent_find multi_equal_30 by c vector:\n");
+	iter = c_adjacent_find(c_vector_begin(&vector), c_vector_end(&vector), multi_equal_30);
+	if(!ITER_EQUAL(iter, last))
+	{
+		printf("find : ");
+		first = ITER_POSITIVE_N(iter, 1);
+		printf("%d %d\n", *(int*)ITER_REF(iter), *(int*)ITER_REF(first));
+	}
+	else
+		printf("not find!\n");
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_adjacent_find_by_c_list()
+{
+	c_list list;
+	c_iterator first, last, iter;
+	__c_list(&list, int_comparer);
+	
+	c_list_insert2(&list, c_list_end(&list), 
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	first = c_list_begin(&list);
+	last = c_list_end(&list);
+
+	printf("adjacent_find multi_equal_30 by c list:\n");
+	iter = c_adjacent_find(c_list_begin(&list), c_list_end(&list), multi_equal_30);
+	if(!ITER_EQUAL(iter, last))
+	{
+		printf("find : ");
+		first = iter;
+		ITER_INC(first);
+		printf("%d %d\n", *(int*)ITER_REF(iter), *(int*)ITER_REF(first));
+	}
+	else
+		printf("not find!\n");
+
+	__c_tsil(&list);
+	return 0;
+}
+
+
+
+static int test_count_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	int i;
+
+	printf("test count by c array:\n");
+
+	for(i = 0; i < sizeof(pary) / sizeof(int *); ++ i)
+	{
+		printf("there are %d of %d in this array\n", c_count(first, last, pary[i]), *pary[i]);
+
+	}
+
+	return 0;
+}
+
+static int test_count_by_c_vector()	
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	int i;
+	c_vector vector;
+
+	__c_vector(&vector, int_comparer);
+	c_vector_insert2(&vector, c_vector_end(&vector), first, last);
+
+	printf("test count by c vector:\n");
+
+	for(i = 0; i < sizeof(pary) / sizeof(int *); ++ i)
+	{
+		printf("there are %d of %d in this vector\n", c_count(c_vector_begin(&vector), 
+									c_vector_end(&vector),
+									 pary[i]), *pary[i]);
+	}
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_count_by_c_list()
+{	
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	int i;
+	c_list list;
+
+	__c_list(&list, int_comparer);
+	c_list_insert2(&list, c_list_end(&list), first, last);
+
+	printf("test count by c array:\n");
+
+	for(i = 0; i < sizeof(pary) / sizeof(int *); ++ i)
+	{
+		printf("there are %d of %d in this list\n", c_count(c_list_begin(&list), 
+									c_list_end(&list), 
+									pary[i]), 
+									*pary[i]);
+	}
+
+	__c_tsil(&list);
+	return 0;
+}
+
+static int test_count_if_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+	
+	printf("test count by c vector\n");
+
+	printf("there are %d of even in this array\n", c_count_if(first, 
+									last,
+									is_even));
+
+	return 0;
+}
+
+static int test_count_if_by_c_vector()
+{
+	c_vector vector;
+	__c_vector(&vector, int_comparer);
+	c_vector_insert2(&vector,
+		       		c_vector_end(&vector),	
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	
+	printf("test count by c vector\n");
+
+	printf("there are %d of even in this vector\n", c_count_if(c_vector_begin(&vector), 
+									c_vector_end(&vector),
+									is_even));
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_count_if_by_c_list()
+{
+	c_list list;
+	__c_list(&list, int_comparer);
+	c_list_insert2(&list,
+		       		c_list_end(&list),	
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	
+	printf("test count by c list\n");
+
+	printf("there are %d of even in this list\n", c_count_if(c_list_begin(&list), 
+									c_list_end(&list),
+									is_even));
+
+	__c_tsil(&list);
+	return 0;
+}
+
+static int test_reverse_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void**)&pary[0]);
+	c_iterator last = c_get_array_iterator((void**)&pary[10]);
+
+	printf("test reverse by c array\n");
+
+	printf("before reverse:\n");
+	print2(first, last);
+
+	c_reverse(first, last);
+	printf("after reverse:\n");
+	print2(first, last);
+	
+	c_reverse(first, last);
+	printf("after recover:\n");
+	print2(first, last);
+	
+	return 0;
+}
+
+static int test_reverse_by_c_vector()
+{
+	c_vector vector;
+	__c_vector(&vector, int_comparer);
+	c_vector_insert2(&vector,
+		       		c_vector_end(&vector),	
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	
+	printf("test reverse by c vector\n");
+
+	printf("before reverse:\n");
+	print2(c_vector_begin(&vector), c_vector_end(&vector));
+
+	c_reverse(c_vector_begin(&vector), c_vector_end(&vector));
+	printf("after reverse:\n");
+	print2(c_vector_begin(&vector), c_vector_end(&vector));
+
+	c_reverse(c_vector_begin(&vector), c_vector_end(&vector));
+	printf("after recover:\n");
+	print2(c_vector_begin(&vector), c_vector_end(&vector));
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_reverse_by_c_list()
+{
+	c_list list;
+	__c_list(&list, int_comparer);
+	c_list_insert2(&list,
+		       		c_list_end(&list),	
+				c_get_array_iterator((void**)&pary[0]),
+				c_get_array_iterator((void**)&pary[10]));
+	
+	printf("test reverse by c list\n");
+		
+	printf("before reverse:\n");
+	print2(c_list_begin(&list), c_list_end(&list));
+
+	c_reverse(c_list_begin(&list), c_list_end(&list));
+	printf("after reverse:\n");
+	print2(c_list_begin(&list), c_list_end(&list));
+
+	c_reverse(c_list_begin(&list), c_list_end(&list));
+	printf("after recover:\n");
+	print2(c_list_begin(&list), c_list_end(&list));
+	
+	__c_tsil(&list);
+	return 0;
+}
+
+static int test_search_by_c_array()
+{
+	c_iterator first = c_get_array_iterator((void **)&pary[0]);
+	c_iterator last = c_get_array_iterator((void **)&pary[10]);
+
+	int * tmppary[] = { &ary[3], &ary[2], &ary[1], &ary[0], &ary[4], &ary[5], &ary[6], &ary[7], &ary[8], &ary[9], 0 };
+	
+	c_iterator result;
+
+	printf("\n\ntest search by c array\n");
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[1]),
+				is_int_equal);
+
+	printf("\nsearch [tmppary[0], tmppary[1])\n");
+	print2(result, last);
+
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[2]),
+				is_int_equal);
+	printf("\nsearch [tmppary[0], tmppary[2])\n");
+	print2(result, last);
+
+	
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[5]),
+				c_get_array_iterator((void **)&tmppary[7]),
+				is_int_equal);
+	printf("\nsearch [tmppary[5], tmppary[7])\n");
+	print2(result, last);
+
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[4]),
+				c_get_array_iterator((void **)&tmppary[10]),
+				is_int_equal);
+	printf("\nsearch [tmppary[4], tmppary[10])\n");
+	print2(result, last);
+
+	return 0;	
+}
+
+
+static int test_search_by_c_vector()
+{
+	c_vector vector;
+	c_iterator first, last;
+	c_iterator result;
+	int * tmppary[] = { &ary[3], &ary[2], &ary[1], &ary[0], &ary[4], &ary[5], &ary[6], &ary[7], &ary[8], &ary[9], 0 };
+	
+	__c_vector(&vector, int_comparer);
+	c_vector_insert2(&vector, c_vector_end(&vector), 
+			c_get_array_iterator((void **)&pary[0]), c_get_array_iterator((void **)&pary[10]));
+
+	first = c_vector_begin(&vector);
+	last = c_vector_end(&vector);
+
+
+	printf("\n\ntest search by c vector\n");
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[1]),
+				is_int_equal);
+
+	printf("\nsearch [tmppary[0], tmppary[1])\n");
+	print2(result, last);
+
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[2]),
+				is_int_equal);
+	printf("\nsearch [tmppary[0], tmppary[2])\n");
+	print2(result, last);
+
+	
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[5]),
+				c_get_array_iterator((void **)&tmppary[7]),
+				is_int_equal);
+	printf("\nsearch [tmppary[5], tmppary[7])\n");
+	print2(result, last);
+
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[4]),
+				c_get_array_iterator((void **)&tmppary[10]),
+				is_int_equal);
+	printf("\nsearch [tmppary[4], tmppary[10])\n");
+	print2(result, last);
+	
+
+	__c_rotcev(&vector);
+	return 0;
+}
+
+static int test_search_by_c_list()
+{
+	c_list list;
+	c_iterator first, last;
+	c_iterator result;
+	int * tmppary[] = { &ary[3], &ary[2], &ary[1], &ary[0], &ary[4], &ary[5], &ary[6], &ary[7], &ary[8], &ary[9], 0 };
+	
+	__c_list(&list, int_comparer);
+	c_list_insert2(&list, c_list_end(&list), 
+			c_get_array_iterator((void **)&pary[0]), c_get_array_iterator((void **)&pary[10]));
+
+	first = c_list_begin(&list);
+	last = c_list_end(&list);
+
+	printf("\n\ntest search by c list\n");
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[1]),
+				is_int_equal);
+
+	printf("\nsearch [tmppary[0], tmppary[1])\n");
+	print2(result, last);
+
+	result = c_search(first, last, 
+				c_get_array_iterator((void **)&tmppary[0]),
+				c_get_array_iterator((void **)&tmppary[2]),
+				is_int_equal);
+	printf("\nsearch [tmppary[0], tmppary[2])\n");
+	print2(result, last);
+
+	
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[5]),
+				c_get_array_iterator((void **)&tmppary[7]),
+				is_int_equal);
+	printf("\nsearch [tmppary[5], tmppary[7])\n");
+	print2(result, last);
+
+	result = c_search(first, last,
+				c_get_array_iterator((void **)&tmppary[4]),
+				c_get_array_iterator((void **)&tmppary[10]),
+				is_int_equal);
+	printf("\nsearch [tmppary[4], tmppary[10])\n");
+	print2(result, last);
+	
+
+	__c_tsil(&list);
+	return 0;
+}
+
+
+int t_algo()
+{
+	printf("\n\n0.test c array\n");
+	test_c_array();
+
+	printf("\n\n1.test advance\n");
+	test_advance_by_c_array();
+	test_advance_by_c_vector();
+	test_advance_by_c_list();
+
+
+	printf("\n\n2.test for_each\n");
+	test_for_each_by_c_array();
+	test_for_each_by_c_vector();
+	test_for_each_by_c_list();
+
+	printf("\n\n3.test find\n");
+	test_find_by_c_array();
+	test_find_by_c_vector();
+	test_find_by_c_list();
+
+	printf("\n\n4.test find_if\n");
+	test_find_if_by_c_array();
+	test_find_if_by_c_vector();
+	test_find_if_by_c_list();
+
+	printf("\n\n5.test adjacent_find\n");
+	test_adjacent_find_by_c_array();
+	test_adjacent_find_by_c_vector();
+	test_adjacent_find_by_c_list();
+
+	printf("\n\n6.test count\n");
+	test_count_by_c_array();
+	test_count_by_c_vector();
+	test_count_by_c_list();
+
+	printf("\n\n7.test count_if\n");
+	test_count_if_by_c_array();
+	test_count_if_by_c_vector();
+	test_count_if_by_c_list();
+	
+	printf("\n\n8.test reverse\n");	
+	test_reverse_by_c_array();
+	test_reverse_by_c_vector();
+	test_reverse_by_c_list();
+
+	printf("\n\n9.test search\n");
+	test_search_by_c_array();
+	test_search_by_c_vector();
+	test_search_by_c_list();
+
+
+
+	
+
+	printf("finish testing algorithm!\n");
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_list.c b/src/tstl2cl/test/t_list.c
new file mode 100644
index 0000000..d86eed2
--- /dev/null
+++ b/src/tstl2cl/test/t_list.c
@@ -0,0 +1,627 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../include/c_list.h"
+#include "../include/c_algorithm.h"
+#include "t_test.h"
+
+int array[6] = { 0, 1, 2, 3, 4, 5 };
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+
+static void print_list2(c_iterator first, c_iterator last)
+{
+    c_iterator iter;
+    printf("list is :\n"); 
+    for(iter = first;
+          !ITER_EQUAL(iter, last); ITER_INC(iter))
+    {
+        printf("\t%d\n", *((int *)(ITER_REF(iter))));
+    }
+} 
+
+static void print_list2_r(c_reverse_iterator first, c_reverse_iterator last)
+{
+    c_reverse_iterator iter;
+    printf("list is :\n");
+    for(iter = first; 
+            !ITER_EQUAL(iter, last); ITER_INC(iter))
+    {
+        printf("\t%d\n", *((int *)(ITER_REF(iter))));
+    }
+}
+
+static void print_list(c_list * p)
+{
+    c_iterator first, last;
+    first = c_list_begin(p);
+    last = c_list_end(p);
+    print_list2(first, last);
+}
+
+static void reverse_print_list(c_list * p)
+{
+    c_reverse_iterator first, last;
+    first = c_list_rbegin(p);
+    last = c_list_rend(p);
+    print_list2_r(first, last);
+} 
+
+static void create_with_push_back(c_list * p)
+{
+    int i = 0;
+    for (; i < 6; ++ i)
+    {
+        c_list_push_back(p, &array[i]);
+    }
+}
+
+static void create_with_push_front(c_list * p)
+{
+    int i = 0;
+    for (; i < sizeof(array) / sizeof(int); ++ i)
+    {
+        c_list_push_front(p, &array[i]); 
+    } 
+}
+
+void list_size(c_list * p)
+{
+    int i = 0;
+    for (; i < sizeof(array) / sizeof(int); ++ i)
+    {
+        printf("is empty? %s\n", (c_list_empty(p) ? "yes" : "no"));
+        printf("i = %d, size = %d\n", i, c_list_size(p));
+        c_list_push_front(p, &array[i]); 
+    } 
+}
+
+void list_assign(c_list * p)
+{
+    c_list lt;
+    __c_list(&lt, int_comparer);
+    c_list_assign(&lt, p);
+    
+    printf("list source:\n");
+    print_list(p);
+    printf("list dest:\n");
+    print_list(&lt);
+       
+    __c_tsil(&lt);
+}
+
+void list_front_back(c_list * p)
+{
+    printf("\tlist front : %d\n", (int *)c_list_front(p) ? 
+                                    *(int *)c_list_front(p) : 
+                                    0);
+    printf("\tlist back : %d\n", (int *)c_list_back(p) ?
+                                    *(int *)c_list_back(p) :
+                                    0);
+}
+
+void list_swap(c_list * p)
+{
+    c_list lt, lt1;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt1, int_comparer);
+    c_list_push_back(&lt, &array[3]);
+    c_list_push_back(&lt, &array[5]);
+    
+    printf("\tlist A : \n");
+    print_list(p);
+    printf("\tlist B : \n");
+    print_list(&lt);
+    c_list_swap(p, &lt);
+    printf("\tAfter swap\n");    
+    printf("\tlist A : \n");
+    print_list(p);
+    printf("\tlist B : \n");
+    print_list(&lt);
+    
+    printf("\t\t#########\t\t\n");
+    printf("\tlist A : \n");
+    print_list(p);
+    printf("\tlist C : \n");
+    print_list(&lt1);
+    c_list_swap(p, &lt1);
+    printf("\tAfter swap\n");
+    printf("\tlist A : \n");
+    print_list(p);
+    printf("\tlist C : \n");
+    print_list(&lt1);
+    
+    __c_tsil(&lt);
+    __c_tsil(&lt1);
+} 
+
+void list_insert(c_list * p)
+{
+    c_list lt;
+    c_iterator iter;
+    __c_list(&lt, int_comparer);
+    print_list(p);
+    c_list_insert(p, c_list_end(p), &array[3]);
+    print_list(p);
+    c_list_insert(p, c_list_begin(p), &array[5]);
+    print_list(p);
+    iter = c_list_begin(p);
+    ITER_INC(iter); //  insert between 5 and 3
+    c_list_insert(p, iter, &array[1]);
+    print_list(p);
+    
+    c_list_insert2(&lt, c_list_begin(&lt), c_list_begin(p), iter);
+    print_list(&lt);
+    c_list_clear(&lt);
+    c_list_push_back(&lt, &array[0]);
+    c_list_insert2(&lt, c_list_begin(&lt), c_list_begin(p), c_list_end(p));
+    print_list(&lt);    
+    __c_tsil(&lt);
+}
+
+void list_erase(c_list * p)
+{
+    c_iterator iter, iter2;
+    create_with_push_back(p);
+    print_list(p);
+    c_list_erase(p, c_list_begin(p));
+    print_list(p);
+    iter = c_list_end(p);
+    ITER_DEC(iter);
+    c_list_erase(p, iter);
+    print_list(p);
+    iter = c_list_begin(p);
+    iter2 = c_list_end(p);
+    ITER_INC(iter);
+    ITER_DEC(iter2);
+    c_list_erase2(p, iter, iter2);
+    print_list(p);
+    c_list_erase2(p, c_list_begin(p), c_list_end(p));
+    print_list(p);    
+}
+
+void list_splice(c_list * p)
+{
+    c_iterator iter;
+    c_list lt;
+    __c_list(&lt, int_comparer);
+    
+    create_with_push_back(p);
+    c_list_splice(&lt, c_list_begin(&lt), p);
+    print_list(&lt);
+    print_list(p);
+    
+    create_with_push_back(p);
+    c_list_splice(&lt, c_list_end(&lt), p);
+    print_list(&lt);
+    print_list(p);
+    
+    create_with_push_back(p);
+    iter = c_list_begin(&lt);
+    ITER_INC(iter);
+    c_list_splice(&lt, iter, p);
+    print_list(&lt);
+    print_list(p);
+       
+    __c_tsil(&lt);
+}
+
+void list_splice1(c_list * p)
+{
+    c_list lt;
+    c_iterator iter, iter2, iter3;
+    
+    __c_list(&lt, int_comparer);
+    create_with_push_back(p);
+    iter = c_list_begin(p);
+    iter2 = c_list_begin(p);
+    ITER_INC(iter2); ITER_INC(iter2);
+    iter3 = c_list_end(p);
+    ITER_DEC(iter3);
+    
+    
+    c_list_splice1(&lt, c_list_begin(&lt), p, iter);
+    print_list(&lt);
+    print_list(p);
+    
+    c_list_splice1(&lt, c_list_end(&lt), p, iter2);
+    print_list(&lt);
+    print_list(p);
+    
+    
+    iter = c_list_begin(&lt);
+    ITER_INC(iter);
+    c_list_splice1(&lt, iter, p, iter3);
+    print_list(&lt);
+    print_list(p);
+    
+    __c_tsil(&lt);
+}
+
+void list_splice2(c_list * p)
+{
+    c_list lt;
+    c_iterator iter, iter2, iter3;
+    
+    __c_list(&lt, int_comparer);
+    create_with_push_back(p);
+    iter = c_list_begin(p);
+    iter2 = c_list_begin(p);
+    ITER_INC(iter2);ITER_INC(iter2);ITER_INC(iter2);ITER_INC(iter2);
+    c_list_splice2(&lt, c_list_begin(&lt), p, iter, iter2);
+    print_list(&lt);
+    print_list(p);
+    
+    c_list_splice2(&lt, c_list_end(&lt), p, c_list_begin(p), c_list_end(p));
+    print_list(&lt);
+    print_list(p);
+    
+    create_with_push_back(p);
+    iter = c_list_end(p);
+    ITER_DEC(iter);ITER_DEC(iter);ITER_DEC(iter);ITER_DEC(iter);
+    c_list_splice2(&lt, c_list_begin(&lt), p, iter, c_list_end(p));
+    print_list(&lt);
+    print_list(p);
+    
+    c_list_splice2(&lt, c_list_end(&lt), p, c_list_begin(p), c_list_end(p));
+    print_list(&lt);
+    print_list(p);
+    
+    create_with_push_back(p);
+    iter = c_list_begin(p);
+    iter2 = c_list_end(p);
+    iter3 = c_list_begin(&lt);
+    ITER_INC(iter); 
+    ITER_DEC(iter2); ITER_DEC(iter2); ITER_DEC(iter2);
+    ITER_INC(iter3);
+    c_list_splice2(&lt, iter3, p, iter, iter2);
+    print_list(&lt);
+    print_list(p);
+        
+    
+    __c_tsil(&lt);
+}
+
+
+void list_remove(c_list * p)
+{
+    create_with_push_back(p);
+    print_list(p);
+    
+    c_list_remove(p, &array[0]);
+    print_list(p);
+    
+    c_list_remove(p, &array[3]);
+    print_list(p);
+    
+    c_list_remove(p, &array[5]);
+    print_list(p);
+    
+    
+    create_with_push_back(p);
+    create_with_push_back(p);
+    
+    c_list_remove(p, &array[4]);
+    print_list(p);
+    
+}
+
+void list_unique(c_list * p)
+{
+    int ary[] = { 0,0,1,1,1,3,3,3,2,2,2 };
+    c_list lt;
+    int i;
+    __c_list(&lt, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    
+    print_list(&lt);
+    c_list_unique(&lt);
+    print_list(&lt);
+    __c_tsil(&lt);
+}
+
+void list_merge()
+{
+    int ary[] = { 1,2,7,2,8,9,2,5,8,36,0,2,12,0,2 };
+    int ary2[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    c_list lt, lt2;
+    int i;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt2, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    for(i = 0; i < (sizeof(ary2) /sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt2, &ary2[i]);
+    }
+    
+    print_list(&lt);
+    print_list(&lt2);
+    printf("after merge\n");
+    c_list_merge(&lt, &lt2);
+    print_list(&lt);
+    print_list(&lt2);
+    
+    __c_tsil(&lt);
+    __c_tsil(&lt2);
+}
+
+void list_sort()
+{
+    int ary[] = { 1,2,7,2,8,9,2,5,8,36,0,2,12,0,2 };
+    int ary2[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    c_list lt, lt2;
+    int i;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt2, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    for(i = 0; i < (sizeof(ary2) /sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt2, &ary2[i]);
+    }
+    
+    print_list(&lt);
+    print_list(&lt2);
+    printf("after sort\n");
+    c_list_sort(&lt);
+    c_list_sort(&lt2);
+    print_list(&lt);
+    print_list(&lt2);
+    
+    __c_tsil(&lt);
+    __c_tsil(&lt2);    
+}
+
+void list_equal()
+{
+    int ary[] = { 1,2,7,2,8,9,2,5,8,36,0,2,12,0,2 };
+    int ary2[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    int ary3[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    c_list lt, lt2, lt3;
+    int i;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt2, int_comparer);
+    __c_list(&lt3, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    for(i = 0; i < (sizeof(ary2) /sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt2, &ary2[i]);
+    }
+    for(i = 0; i < (sizeof(ary3) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt3, &ary3[i]);
+    }
+    
+    print_list(&lt);
+    print_list(&lt2);
+    print_list(&lt3);
+    
+    if(c_list_equal(&lt, &lt2))
+        printf("lt == lt2\n");
+    else 
+        printf("lt != lt2\n");
+        
+    if(c_list_equal(&lt2, &lt3))
+        printf("lt2 == lt3\n");
+    else
+        printf("lt2 != lt3\n");
+    
+    __c_tsil(&lt);
+    __c_tsil(&lt2);    
+    __c_tsil(&lt3);
+}
+
+void list_less()
+{
+    int ary[] = { 2,89,7,2,8,9,2,5,8,36,0,2,12,0,2 };
+    int ary2[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    int ary3[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9,3 };
+    c_list lt, lt2, lt3;
+    int i;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt2, int_comparer);
+    __c_list(&lt3, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    for(i = 0; i < (sizeof(ary2) /sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt2, &ary2[i]);
+    }
+    for(i = 0; i < (sizeof(ary3) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt3, &ary3[i]);
+    }
+    
+    print_list(&lt);
+    print_list(&lt2);
+    print_list(&lt3);
+    
+    if(c_list_less(&lt, &lt2))
+        printf("lt < lt2\n");
+    else 
+        printf("lt >= lt2\n");
+        
+    if(c_list_less(&lt2, &lt3))
+        printf("lt2 < lt3\n");
+    else
+        printf("lt2 >= lt3\n");
+    
+    __c_tsil(&lt);
+    __c_tsil(&lt2);    
+    __c_tsil(&lt3);
+}
+
+void list_copy()
+{
+    int ary[] = { 0,0,0,0,0,0 };
+    int ary2[] = { 2,87,1,9,2,5,0,54,1,7,23,0,43,2,9 };
+    c_list lt, lt2;
+    int i;
+    __c_list(&lt, int_comparer);
+    __c_list(&lt2, int_comparer);
+    for(i = 0; i < (sizeof(ary) / sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt, &ary[i]);
+    }
+    for(i = 0; i < (sizeof(ary2) /sizeof(int)); ++ i)
+    {
+        c_list_push_back(&lt2, &ary2[i]);
+    }
+    
+    print_list(&lt);
+    print_list(&lt2);
+    
+    c_copy(c_list_begin(&lt), c_list_end(&lt), c_list_begin(&lt2));
+    printf("after copy \n");
+    print_list(&lt);
+    print_list(&lt2);
+    
+    c_copy_backward(c_list_begin(&lt), c_list_end(&lt), c_list_end(&lt2));
+    printf("after copy backward\n");
+    print_list(&lt);
+    print_list(&lt2);
+        
+    __c_tsil(&lt);
+    __c_tsil(&lt2);
+}
+
+int t_list()
+{
+    c_list lt;
+    
+    
+    __c_list(&lt, int_comparer);
+    
+    
+    
+    printf("\n\n##\t1.\ttest creating list with push_back\n");
+    create_with_push_back(&lt);
+    print_list(&lt);
+    reverse_print_list(&lt);
+    c_list_clear(&lt);
+    printf("after clear :\n"); 
+    print_list(&lt);
+    
+    
+    printf("\n\n##\t2.\ttest creating list with push_front\n");
+    create_with_push_front(&lt);
+    print_list(&lt);
+    reverse_print_list(&lt);
+    c_list_clear(&lt);
+
+
+    printf("\n\n##3.\ttest list size\n");
+    list_size(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n##4.\ttest list assign\n");
+    list_assign(&lt);
+    create_with_push_back(&lt);
+    list_assign(&lt);
+    c_list_clear(&lt);
+    
+
+    printf("\n\n##5.\ttest list front back\n");
+    list_front_back(&lt);
+    c_list_push_back(&lt, &array[1]);
+    list_front_back(&lt);
+    c_list_push_back(&lt, &array[3]);
+    list_front_back(&lt);
+    c_list_push_back(&lt, &array[5]);
+    list_front_back(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n##6.\ttest list pop front back\n");
+    create_with_push_back(&lt);
+    list_front_back(&lt);
+    printf("\tlist size : %d\n", c_list_size(&lt));
+    c_list_pop_front(&lt);
+    list_front_back(&lt);
+    c_list_pop_back(&lt);
+    list_front_back(&lt);
+    printf("\tlist size : %d\n", c_list_size(&lt));
+    c_list_pop_front(&lt);
+    list_front_back(&lt);
+    c_list_pop_back(&lt);
+    list_front_back(&lt);
+    printf("\tlist size : %d\n", c_list_size(&lt));
+    c_list_pop_front(&lt);
+    list_front_back(&lt);
+    c_list_pop_back(&lt);
+    list_front_back(&lt);
+    printf("\tlist size : %d\n", c_list_size(&lt));
+    c_list_pop_front(&lt);
+    list_front_back(&lt);  
+    c_list_pop_back(&lt);
+    list_front_back(&lt);
+    printf("\tlist size : %d\n", c_list_size(&lt));
+    c_list_clear(&lt);
+    
+    printf("\n\n##7.\ttest list swap\n");
+    create_with_push_back(&lt); 
+    list_swap(&lt);
+    c_list_clear(&lt); 
+    
+    printf("\n\n##8.\ttest list insert\n");
+    list_insert(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n##9.\ttest list erase\n");
+    list_erase(&lt); 
+    c_list_clear(&lt);
+    
+    printf("\n\n##10.\ttest list splice\n");
+    list_splice(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n##11.\ttest list splice1\n");
+    list_splice1(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n12.\ttest list splice2\n");
+    list_splice2(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n13.\ttest list remove\n");
+    list_remove(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n14.\ttest list unique\n");
+    list_unique(&lt);
+    c_list_clear(&lt);
+    
+    printf("\n\n15.\ttest list merge\n");
+    list_merge();
+    
+    printf("\n\n16.\ttest list sort\n");
+    list_sort();
+    
+    printf("\n\n17.\ttest list equal\n");
+    list_equal();
+    
+    printf("\n\n18.\ttest list less\n");
+    list_less();
+    
+    printf("\n\n19.\ttest list copy\n");
+    list_copy();
+    
+    __c_tsil(&lt); 
+    printf("\n\nfinish testing list!\n");
+    return 0;
+}
diff --git a/src/tstl2cl/test/t_main.c b/src/tstl2cl/test/t_main.c
new file mode 100644
index 0000000..3c74911
--- /dev/null
+++ b/src/tstl2cl/test/t_main.c
@@ -0,0 +1,30 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include "t_test.h"
+
+int t_list();
+int t_vector();
+int t_tree();
+int t_map();
+int t_set();
+int t_stack();
+int t_queue();
+int t_algo();
+
+int main()
+{
+	
+	t_list();
+	t_vector();
+	t_tree();
+	t_map();
+	t_set();
+	t_stack();
+	t_queue();
+	t_algo();
+	
+#ifdef WIN32
+	system("pause");
+#endif	
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_map.c b/src/tstl2cl/test/t_map.c
new file mode 100644
index 0000000..6e35332
--- /dev/null
+++ b/src/tstl2cl/test/t_map.c
@@ -0,0 +1,598 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../include/c_def.h"
+#include "../include/c_vector.h"
+#include "c_map.h"
+#include <assert.h>
+#include "t_test.h"
+
+c_bool __c_rb_tree_verify(c_prb_tree thiz);
+
+static int values[] = 
+{ 
+	8,	/* 0 */
+	3,	/* 1 */
+	8,	/* 2 */
+	4,	/* 3 */
+	3,	/* 4 */
+	8,	/* 5 */
+	5,	/* 6 */
+	43,	/* 7 */
+	994,	/* 8 */
+	32,	/* 9 */
+	6,	/* 10 */
+	9,	/* 11 */
+	3,	/* 12 */
+	7,	/* 13 */
+	7,	/* 14 */
+	32,	/* 15 */
+	8,	/* 16 */
+	2,	/* 17 */
+	343 	/* 18 */
+};
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+static int keys[] = 
+{ 
+	12,	/* 0 */	
+	4,	/* 1 */	
+	71,	/* 2 */
+	2,	/* 3 */
+	90,	/* 4 */
+	99,	/* 5 */
+	30,	/* 6 */
+	61,	/* 7 */
+	29,	/* 8 */
+	84,	/* 9 */
+	6,	/* 10 */
+	97,	/* 11 */
+	3,	/* 12 */
+	8,	/* 13 */
+	54,	/* 14 */
+	78,	/* 15 */
+	9,	/* 16 */
+	16,	/* 17 */
+	62,	/* 18 */
+};
+
+static c_pair pairs[] =
+{
+	{ &keys[0], &values[0] },
+	{ &keys[1], &values[1] },
+	{ &keys[2], &values[2] },
+	{ &keys[3], &values[3] },
+	{ &keys[4], &values[4] },
+	{ &keys[5], &values[5] },
+	{ &keys[6], &values[6] },
+	{ &keys[7], &values[7] },
+	{ &keys[8], &values[8] },
+	{ &keys[9], &values[9] },
+	{ &keys[10], &values[10] },
+	{ &keys[11], &values[11] },
+	{ &keys[12], &values[12] },
+	{ &keys[13], &values[13] },
+	{ &keys[14], &values[14] },
+	{ &keys[15], &values[15] },
+	{ &keys[16], &values[16] },
+	{ &keys[17], &values[17] },
+	{ &keys[18], &values[18] }
+};
+
+static inline int pair_comparer(void * x, void * y)
+{
+	value_type x_f = ((c_ppair)x)->first;
+	value_type x_s = ((c_ppair)x)->second;
+	value_type y_f = ((c_ppair)y)->first;
+	value_type y_s = ((c_ppair)y)->second;
+	int f_val = int_comparer(x_f, y_f);
+	if(!f_val)
+		return int_comparer(x_s, y_s);
+	else
+		return f_val; 
+}
+
+
+
+static int print_map(c_pmap pt)
+{
+	c_iterator iter = c_map_begin(pt);
+	c_iterator end = c_map_end(pt);
+	printf("map is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		printf("key = %d, value = %d\n",
+			*(int*)((c_ppair)ITER_REF(iter))->first,
+			*(int*)((c_ppair)ITER_REF(iter))->second);
+	}
+	return 0;
+}
+
+static int rprint_map(c_pmap pt)
+{
+	c_reverse_iterator iter = c_map_rbegin(pt);
+	c_reverse_iterator end = c_map_rend(pt);
+	printf("map is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		printf("key = %d, value = %d\n",
+			*(int*)((c_ppair)ITER_REF(iter))->first,
+			*(int*)((c_ppair)ITER_REF(iter))->second);
+	}
+	return 0;
+}
+
+
+static int create_with_insert_unique(c_pmap thiz)
+{
+	int i = 0;
+	for(; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		c_map_insert(thiz, &pairs[i]);
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+
+	return 0;
+}
+
+static int create_with_insert_equal(c_pmap thiz)
+{
+	return 0;
+}
+
+static int test_clear(c_pmap thiz)
+{
+	c_iterator begin, end;
+	c_reverse_iterator rbegin, rend;
+	c_map_clear(thiz);
+	begin = c_map_begin(thiz);
+	end = c_map_end(thiz);
+	rbegin = c_map_rbegin(thiz);
+	rend = c_map_rend(thiz);
+	
+	if(c_map_size(thiz) == 0)
+		printf("ok, size is 0\n");
+	else
+		printf("error, size is not 0\n");
+	
+	if(ITER_EQUAL(begin, end))
+		printf("ok, begin == end\n");
+	else
+		printf("error, begin != end\n");
+	
+	if(ITER_EQUAL(rbegin, rend))
+		printf("ok, rbegin == rend\n");
+	else
+		printf("error, rbegin != rend\n");
+	return 0;
+}
+
+static int test_size_empty(c_pmap thiz)
+{
+	int i = 0;
+	printf("max size is %d\n", c_map_max_size(thiz));
+	printf("size is %d\n", c_map_size(thiz));
+	printf("is empty? %s\n", c_map_empty(thiz) ? "yes" : "no");
+	
+	for(; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		printf("now insert %d\n", i + 1);
+		c_map_insert(thiz, &pairs[i]);
+		printf("size is %d\n", c_map_size(thiz));
+		printf("is empty? %s\n", c_map_empty(thiz) ? "yes" : "no");
+	}
+	printf("now clear\n");
+	c_map_clear(thiz);
+	printf("size is %d\n", c_map_size(thiz));
+	printf("is empty? %s\n", c_map_empty(thiz) ? "yes" : "no");
+
+	return 0;
+}
+
+static int test_swap(c_pmap thiz)
+{
+	c_map tr;
+	c_map_create(&tr, int_comparer);	
+	
+	c_map_swap(thiz, &tr);
+	printf("after swap\n");
+	print_map(&tr);
+	c_map_destroy(&tr);	
+	return 0;
+}
+
+static int create_with_insert_unique1(c_pmap thiz)
+{
+	c_iterator iter = c_map_begin(thiz);
+	int i = 0;
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		iter = c_map_insert1(thiz, iter, &pairs[i]);
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+	return 0;
+}
+
+static int create_with_insert_equal1(c_pmap thiz)
+{
+	return 0;
+}
+
+static int create_with_insert_unique2(c_pmap thiz)
+{
+	c_vector vt;
+	int i = 0;
+	c_vector_create(&vt, int_comparer);
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_iterator v_beg, v_end;
+		c_vector_push_back(&vt, &pairs[i]);
+
+		v_beg = c_vector_begin(&vt);
+		v_end = c_vector_end(&vt);
+		c_map_insert2(thiz, v_beg, v_end);
+
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+
+	c_vector_destroy(&vt);
+	return 0;
+}
+
+static int create_with_insert_equal2(c_pmap thiz)
+{
+	return 0;
+}
+
+static void assert_valid_iter(c_pmap thiz, c_iterator val)
+{
+	c_iterator end = c_map_end(thiz);
+	c_iterator iter = c_map_begin(thiz);
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		if(ITER_EQUAL(iter, val))
+			return;
+	}
+	assert(false);
+}
+
+static int test_erase(c_pmap thiz)
+{
+	c_iterator iter = c_map_begin(thiz);
+	c_iterator end = c_map_end(thiz);
+	assert(__c_rb_tree_verify(thiz->_l));
+	//c_map_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz->_l));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = iter;
+		assert_valid_iter(thiz, to_erase);
+		c_map_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz->_l));
+		
+		iter = c_map_begin(thiz);
+		end = c_map_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz->_l));
+	assert(c_map_empty(thiz));
+	return 0;
+}
+
+static int test_reverse_erase(c_pmap thiz)
+{
+	c_iterator iter = c_map_begin(thiz);
+	c_iterator end = c_map_end(thiz);
+	assert(__c_rb_tree_verify(thiz->_l));
+	//c_map_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz->_l));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = end;
+		ITER_DEC(to_erase);
+		assert_valid_iter(thiz, to_erase);
+		c_map_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz->_l));
+
+		iter = c_map_begin(thiz);
+		end = c_map_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz->_l));
+	assert(c_map_empty(thiz));
+	return 0;
+}
+
+static int test_find_erase(c_pmap thiz)
+{
+	int j = 0;
+	for(j = 0; j < sizeof(keys) / sizeof(int); ++ j)
+	{
+		c_iterator target, map_end;	
+		printf("j = %d, key = %d\n", j, keys[j]);
+
+		target = c_map_find(thiz, &keys[j]); // set same as map 
+			
+		map_end = c_map_end(thiz);
+		if(!ITER_EQUAL(map_end, target))
+		{
+			printf("to erase : %d\n", *(int*)(((c_ppair)ITER_REF(target))->first));
+
+			assert_valid_iter(thiz, target);
+			c_map_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz->_l));
+		}			
+	}
+	return 0;
+}
+
+static int test_reverse_find_erase(c_pmap thiz)
+{
+	int j = 0;
+	for(j = sizeof(keys) / sizeof(int) - 1; j >= 0; -- j)
+	{
+		c_iterator target, map_end;	
+		printf("j = %d\n", j);
+
+		target = c_map_find(thiz, &keys[j]); // set same as map
+		
+		map_end = c_map_end(thiz);
+		if(!ITER_EQUAL(map_end, target))
+		{			
+			printf("to erase : %d\n", *(int*)(((c_ppair)ITER_REF(target))->first));
+			assert_valid_iter(thiz, target);
+			c_map_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz->_l));
+		}			
+	}
+	return 0;	
+}
+
+static int test_count(c_pmap thiz)
+{
+	int i = 0;
+	create_with_insert_equal2(thiz);
+		
+	for(i = 0; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		size_t count = c_map_count(thiz, &keys[i]);
+		printf("i : %d; key : %d; count : %d\n", i, keys[i], count);
+	}
+	return 0;
+}
+
+static int test_less()
+{
+	c_bool rt;
+	c_map ta, tb;
+
+	c_map_create(&ta, int_comparer);
+	c_map_create(&tb, int_comparer);
+
+	
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+	printf("*ta is :\n");
+	print_map(&ta);
+	printf("*tb is :\n");
+	print_map(&tb);
+	rt = c_map_less(&ta, &tb, pair_comparer);
+	if(rt)
+		printf("is less\n");
+	else
+		printf("is not less\n");
+
+	c_map_clear(&ta);
+	c_map_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+	printf("*ta is :\n");
+	print_map(&ta);
+	printf("*tb is :\n");
+	print_map(&tb);
+	rt = c_map_less(&ta, &tb, pair_comparer);
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	c_map_clear(&ta);
+	c_map_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+	printf("*ta is :\n");
+	print_map(&ta);
+	printf("*tb is :\n");
+	print_map(&tb);
+	rt = c_map_less(&ta, &tb, pair_comparer);
+
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	return 0;
+}
+
+
+static int test_equal()
+{
+	c_bool rt;
+	c_map ta, tb;
+
+	c_map_create(&ta, int_comparer);
+	c_map_create(&tb, int_comparer);
+
+	
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_map_equal(&ta, &tb, pair_comparer);
+	if(rt)
+		printf("is equal\n");
+	else
+		printf("is not equal\n");
+
+	c_map_clear(&ta);
+	c_map_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_map_equal(&ta, &tb, pair_comparer);
+
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	c_map_clear(&ta);
+	c_map_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+	rt = c_map_equal(&ta, &tb, pair_comparer);
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	return 0;
+}
+
+static int test_at()
+{
+	c_map m;
+	value_type val = NULL;
+	int key = 84;
+	int nonkeys[] = { 5, -1, -28, -998, -62356, 95238 };
+	int i = 0;
+	c_map_create(&m, int_comparer);
+	create_with_insert_unique(&m);
+
+	val = c_map_at(&m, &key);
+
+	if(val != NULL)
+	{
+		printf("map at %i, value is %i\n", key, *(int*)val);
+	}
+
+	for(i = 0; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		val = c_map_at(&m, &keys[i]);
+		if(val != NULL)
+		{
+			printf("map at %i, value is %i\n", keys[i], *(int*)val);
+		}
+	}
+
+	for(i = 0; i < sizeof(nonkeys) /sizeof(int); ++ i)
+	{
+		val = c_map_at(&m, &nonkeys[i]);
+		if(val != NULL)
+			assert(false);
+		else
+			printf("ok! pass!\n");
+	}
+	
+	c_map_destroy(&m);
+}
+
+int t_map()
+{
+	c_map map;
+
+	c_map_create(&map, int_comparer);
+
+	
+	assert(__c_rb_tree_verify(map._l));
+	printf("0. test create with insert unique\n");
+	create_with_insert_unique(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n1. test clear\n");
+	test_clear(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n2. test size and empty\n");
+	test_size_empty(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n3. test create with insert equal\n");
+	c_map_clear(&map);
+	create_with_insert_equal(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n4. test swap\n");
+	create_with_insert_unique(&map);
+	test_swap(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n5. test create with insert unique1\n");
+	create_with_insert_unique1(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n6. test create with insert equal1\n");
+	c_map_clear(&map);
+	create_with_insert_equal1(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n7. test create with insert unique2\n");
+	c_map_clear(&map);
+	create_with_insert_unique2(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n8. test create with insert equal2\n");
+	c_map_clear(&map);
+	create_with_insert_equal2(&map);
+	print_map(&map);
+	rprint_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+	
+	printf("\n\n9. test erase\n");
+	c_map_clear(&map);
+	create_with_insert_unique(&map);
+	test_erase(&map);
+	create_with_insert_unique(&map);	
+	test_reverse_erase(&map);	
+	print_map(&map);
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n10. test find and erase\n");
+	c_map_clear(&map);
+	printf("* test_find_erase:\n");
+	create_with_insert_unique(&map);
+	print_map(&map);	
+	test_find_erase(&map);
+	print_map(&map);	
+	printf("* test_reverse_find_erase:\n");
+	create_with_insert_unique(&map);
+	print_map(&map);	
+	test_reverse_find_erase(&map);
+	print_map(&map);	
+	assert(__c_rb_tree_verify(map._l));
+
+	printf("\n\n11. test count:\n"); // 'lower_bound' 'upper_bound' 'equal_range' used	
+	create_with_insert_unique(&map);
+	test_count(&map);
+
+	printf("\n\n12. test less:\n");
+	test_less();
+
+	printf("\n\n13. test equal:\n");
+	test_equal();
+
+	printf("\n\n14. test at:\n");
+	test_at();
+	
+	c_map_destroy(&map);
+	printf("\n\nfinish testing map!\n");
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_queue.c b/src/tstl2cl/test/t_queue.c
new file mode 100644
index 0000000..6f28062
--- /dev/null
+++ b/src/tstl2cl/test/t_queue.c
@@ -0,0 +1,147 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "c_queue.h"
+#include "c_vector.h"
+#include "t_test.h"
+
+static int ary[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
+#define SIZE 10
+
+
+static int int_comparer(value_type x, value_type y)
+{
+	return *(int *)x - *(int *)y;
+}
+
+static int create_with_push(c_pqueue ps, int ary[])
+{
+	int i = 0;
+	for(i = 0; i < SIZE; ++ i)
+	{
+		c_queue_push(ps, &ary[i]);
+	}
+	return 0;
+}	
+
+static int print_queue(c_pqueue ps)
+{
+	c_vector tmpvt;
+	__c_vector(&tmpvt, int_comparer);
+
+	printf("queue is : \n");
+	while(!c_queue_empty(ps))
+	{
+		int * tmp = c_queue_front(ps);
+		printf("front is : %d, size is : %d, back is : %d\n", 
+				*tmp, 
+				c_queue_size(ps),
+				*(int *)c_queue_back(ps));
+		c_queue_pop(ps);
+		c_vector_push_back(&tmpvt, tmp);
+	}
+
+	// recover queue
+	do
+	{
+		c_iterator iter = c_vector_begin(&tmpvt);
+		c_iterator end = c_vector_end(&tmpvt);
+		for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+		{
+			c_queue_push(ps, ITER_REF(iter));
+		}
+	} while(0);	
+
+	__c_rotcev(&tmpvt);
+	return 0;
+}
+
+static int clear_queue(c_pqueue ps)
+{
+	while(!c_queue_empty(ps))
+	{
+		c_queue_pop(ps);
+	}
+
+	return 0;
+}	
+
+
+int t_queue()
+{
+	c_queue queue, queue1;
+	int ary1[] = { 2, 3, 4, 5, 6, 7, 8, 9, 0, 1 }; 
+	__c_queue(&queue, int_comparer);
+	__c_queue(&queue1, int_comparer);
+
+	create_with_push(&queue, ary);
+	printf("queue: \n");
+	print_queue(&queue);
+
+	create_with_push(&queue1, ary1);
+	printf("queue1: \n");
+	print_queue(&queue1);
+	
+	if(c_queue_equal(&queue, &queue1))
+		printf("queue == queue1\n");
+	else
+		printf("queue != queue1\n");
+
+	clear_queue(&queue);
+	clear_queue(&queue1);
+
+	create_with_push(&queue, ary1);
+	printf("queue: \n");
+	print_queue(&queue);
+
+	create_with_push(&queue1, ary1);
+	printf("queue1: \n");
+	print_queue(&queue1);
+
+	if(c_queue_equal(&queue, &queue1))
+		printf("queue == queue1\n");
+	else
+		printf("queue != queue1\n");
+
+
+	clear_queue(&queue);
+	clear_queue(&queue1);
+
+	create_with_push(&queue, ary);
+	printf("queue: \n");
+	print_queue(&queue);
+
+	create_with_push(&queue1, ary1);
+	printf("queue1: \n");
+	print_queue(&queue1);
+	
+	if(c_queue_less(&queue, &queue1))
+		printf("queue < queue1\n");
+	else
+		printf("queue >= queue1\n");
+
+	clear_queue(&queue);
+	clear_queue(&queue1);
+
+	create_with_push(&queue, ary1);
+	printf("queue: \n");
+	print_queue(&queue);
+
+	create_with_push(&queue1, ary1);
+	printf("queue1: \n");
+	print_queue(&queue1);
+
+	if(c_queue_less(&queue, &queue1))
+		printf("queue < queue1\n");
+	else
+		printf("queue >= queue1\n");
+
+
+
+	__c_eueuq(&queue);
+	__c_eueuq(&queue1);
+
+	printf("\nfinish testing queue!\n\n");
+	
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_set.c b/src/tstl2cl/test/t_set.c
new file mode 100644
index 0000000..117e827
--- /dev/null
+++ b/src/tstl2cl/test/t_set.c
@@ -0,0 +1,567 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../include/c_def.h"
+#include "../include/c_vector.h"
+#include "../include/c_set.h"
+#include <assert.h>
+#include "t_test.h"
+
+static int values[] = 
+{ 
+	8,	/* 0 */
+	3,	/* 1 */
+	8,	/* 2 */
+	4,	/* 3 */
+	3,	/* 4 */
+	8,	/* 5 */
+	5,	/* 6 */
+	43,	/* 7 */
+	994,	/* 8 */
+	32,	/* 9 */
+	6,	/* 10 */
+	9,	/* 11 */
+	3,	/* 12 */
+	7,	/* 13 */
+	7,	/* 14 */
+	32,	/* 15 */
+	8,	/* 16 */
+	2,	/* 17 */
+	343 	/* 18 */
+};
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+static int keys[] = 
+{ 
+	12,	/* 0 */	
+	4,	/* 1 */	
+	71,	/* 2 */
+	2,	/* 3 */
+	90,	/* 4 */
+	99,	/* 5 */
+	30,	/* 6 */
+	61,	/* 7 */
+	29,	/* 8 */
+	84,	/* 9 */
+	6,	/* 10 */
+	97,	/* 11 */
+	3,	/* 12 */
+	8,	/* 13 */
+	54,	/* 14 */
+	78,	/* 15 */
+	9,	/* 16 */
+	16,	/* 17 */
+	62,	/* 18 */
+};
+
+/*
+static c_pair pairs[] =
+{
+	{ &keys[0], &values[0] },
+	{ &keys[1], &values[1] },
+	{ &keys[2], &values[2] },
+	{ &keys[3], &values[3] },
+	{ &keys[4], &values[4] },
+	{ &keys[5], &values[5] },
+	{ &keys[6], &values[6] },
+	{ &keys[7], &values[7] },
+	{ &keys[8], &values[8] },
+	{ &keys[9], &values[9] },
+	{ &keys[10], &values[10] },
+	{ &keys[11], &values[11] },
+	{ &keys[12], &values[12] },
+	{ &keys[13], &values[13] },
+	{ &keys[14], &values[14] },
+	{ &keys[15], &values[15] },
+	{ &keys[16], &values[16] },
+	{ &keys[17], &values[17] },
+	{ &keys[18], &values[18] }
+};
+*/
+
+static inline int pair_comparer(void * x, void * y)
+{
+	value_type x_f = ((c_ppair)x)->first;
+	value_type x_s = ((c_ppair)x)->second;
+	value_type y_f = ((c_ppair)y)->first;
+	value_type y_s = ((c_ppair)y)->second;
+	int f_val = int_comparer(x_f, y_f);
+	if(!f_val)
+		return int_comparer(x_s, y_s);
+	else
+		return f_val; 
+}
+
+
+static int print_set(c_pset pt)
+{
+	c_iterator iter = c_set_begin(pt);
+	c_iterator end = c_set_end(pt);
+	printf("set is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		printf("value = %d\n",
+			*(int*)(ITER_REF(iter)));
+	}
+	return 0;
+}
+
+static int rprint_set(c_pset pt)
+{
+	c_reverse_iterator iter = c_set_rbegin(pt);
+	c_reverse_iterator end = c_set_rend(pt);
+	printf("set is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		printf("value = %d\n",
+			*(int*)(ITER_REF(iter)));
+	}
+	return 0;
+}
+
+
+static int create_with_insert_unique(c_pset thiz)
+{
+	int i = 0;
+	for(; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		c_set_insert(thiz, &keys[i]);
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+	return 0;
+}
+
+static int create_with_insert_equal(c_pset thiz)
+{
+	int i = 0;
+	for(; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_set_insert(thiz, &values[i]);
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+	return 0;
+}
+
+static int test_clear(c_pset thiz)
+{
+	c_iterator begin, end;
+	c_reverse_iterator rbegin, rend;
+	c_set_clear(thiz);
+	begin = c_set_begin(thiz);
+	end = c_set_end(thiz);
+	rbegin = c_set_rbegin(thiz);
+	rend = c_set_rend(thiz);
+	
+	if(c_set_size(thiz) == 0)
+		printf("ok, size is 0\n");
+	else
+		printf("error, size is not 0\n");
+	
+	if(ITER_EQUAL(begin, end))
+		printf("ok, begin == end\n");
+	else
+		printf("error, begin != end\n");
+	
+	if(ITER_EQUAL(rbegin, rend))
+		printf("ok, rbegin == rend\n");
+	else
+		printf("error, rbegin != rend\n");
+	return 0;
+}
+
+static int test_size_empty(c_pset thiz)
+{
+	int i = 0;
+	printf("max size is %d\n", c_set_max_size(thiz));
+	printf("size is %d\n", c_set_size(thiz));
+	printf("is empty? %s\n", c_set_empty(thiz) ? "yes" : "no");
+	
+	for(; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		printf("now insert %d\n", i + 1);
+		c_set_insert(thiz, &values[i]);
+
+		printf("size is %d\n", c_set_size(thiz));
+		printf("is empty? %s\n", c_set_empty(thiz) ? "yes" : "no");
+	}
+	printf("now clear\n");
+	c_set_clear(thiz);
+	printf("size is %d\n", c_set_size(thiz));
+	printf("is empty? %s\n", c_set_empty(thiz) ? "yes" : "no");
+
+	return 0;
+}
+
+static int test_swap(c_pset thiz)
+{
+	c_set tr;
+	c_set_create(&tr, int_comparer);	
+
+	c_set_swap(thiz, &tr);
+	printf("after swap\n");
+	print_set(&tr);
+	c_set_destroy(&tr);	
+	return 0;
+}
+
+static int create_with_insert_unique1(c_pset thiz)
+{
+	c_iterator iter = c_set_begin(thiz);
+	int i = 0;
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		iter = c_set_insert1(thiz, iter, &keys[i]);
+
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+	return 0;
+}
+
+static int create_with_insert_equal1(c_pset thiz)
+{
+	c_iterator iter = c_set_begin(thiz);
+	int i = 0;
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		iter = c_set_insert1(thiz, iter, &values[i]);
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+	return 0;
+}
+
+static int create_with_insert_unique2(c_pset thiz)
+{
+	c_vector vt;
+	int i = 0;
+	c_vector_create(&vt, int_comparer);
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_iterator v_beg, v_end;
+		c_vector_push_back(&vt, &keys[i]);
+
+		v_beg = c_vector_begin(&vt);
+		v_end = c_vector_end(&vt);
+		c_set_insert2(thiz, v_beg, v_end);
+
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+
+	c_vector_destroy(&vt);
+	return 0;
+}
+
+static int create_with_insert_equal2(c_pset thiz)
+{
+	c_vector vt;
+	int i = 0;
+	c_vector_create(&vt, int_comparer);
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_iterator v_beg, v_end;
+		c_vector_push_back(&vt, &values[i]);
+
+		v_beg = c_vector_begin(&vt);
+		v_end = c_vector_end(&vt);
+		c_set_insert2(thiz, v_beg, v_end);
+		
+		assert(__c_rb_tree_verify(thiz->_l));
+	}
+
+	c_vector_destroy(&vt);
+	return 0;
+}
+
+static void assert_valid_iter(c_pset thiz, c_iterator val)
+{
+	c_iterator end = c_set_end(thiz);
+	c_iterator iter = c_set_begin(thiz);
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		if(ITER_EQUAL(iter, val))
+			return;
+	}
+	assert(false);
+}
+
+static int test_erase(c_pset thiz)
+{
+	c_iterator iter = c_set_begin(thiz);
+	c_iterator end = c_set_end(thiz);
+	assert(__c_rb_tree_verify(thiz->_l));
+	//c_set_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz->_l));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = iter;
+		assert_valid_iter(thiz, to_erase);
+		c_set_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz->_l));
+		
+		iter = c_set_begin(thiz);
+		end = c_set_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz->_l));
+	assert(c_set_empty(thiz));
+	return 0;
+}
+
+static int test_reverse_erase(c_pset thiz)
+{
+	c_iterator iter = c_set_begin(thiz);
+	c_iterator end = c_set_end(thiz);
+	assert(__c_rb_tree_verify(thiz->_l));
+	//c_set_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz->_l));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = end;
+		ITER_DEC(to_erase);
+		assert_valid_iter(thiz, to_erase);
+		c_set_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz->_l));
+
+		iter = c_set_begin(thiz);
+		end = c_set_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz->_l));
+	assert(c_set_empty(thiz));
+	return 0;
+}
+
+static int test_find_erase(c_pset thiz)
+{
+	int j = 0;
+	for(j = 0; j < sizeof(keys) / sizeof(int); ++ j)
+	{
+		c_iterator target, set_end;	
+		printf("j = %d, key = %d\n", j, keys[j]);
+
+		target = c_set_find(thiz, &keys[j]); // set same as map 
+			
+		set_end = c_set_end(thiz);
+		if(!ITER_EQUAL(set_end, target))
+		{
+			printf("to erase : %d\n", *(int*)ITER_REF(target));
+
+			assert_valid_iter(thiz, target);
+			c_set_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz->_l));
+		}			
+	}
+	return 0;
+}
+
+static int test_reverse_find_erase(c_pset thiz)
+{
+	int j = 0;
+	for(j = sizeof(keys) / sizeof(int) - 1; j >= 0; -- j)
+	{
+		c_iterator target, set_end;	
+		printf("j = %d\n", j);
+
+		target = c_set_find(thiz, &keys[j]); // set same as map
+		
+		set_end = c_set_end(thiz);
+		if(!ITER_EQUAL(set_end, target))
+		{			
+			printf("to erase : %d\n", *(int*)ITER_REF(target));
+
+			assert_valid_iter(thiz, target);
+			c_set_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz->_l));
+		}			
+	}
+	return 0;	
+}
+
+static int test_count(c_pset thiz)
+{
+	int i = 0;
+	create_with_insert_equal2(thiz);
+		
+	for(i = 0; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		size_t count = c_set_count(thiz, &keys[i]);
+		printf("i : %d; key : %d; count : %d\n", i, keys[i], count);
+	}
+	return 0;
+}
+
+static int test_less()
+{
+	c_bool rt;
+	c_set ta, tb;
+
+	c_set_create(&ta, int_comparer);
+	c_set_create(&tb, int_comparer);
+
+
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_set_less(&ta, &tb);
+	if(rt)
+		printf("is less\n");
+	else
+		printf("is not less\n");
+
+	c_set_clear(&ta);
+	c_set_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_set_less(&ta, &tb);
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	c_set_clear(&ta);
+	c_set_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+	rt = c_set_less(&ta, &tb);
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	return 0;
+}
+
+static int test_equal()
+{
+	c_bool rt;
+	c_set ta, tb;
+
+	c_set_create(&ta, int_comparer);
+	c_set_create(&tb, int_comparer);
+
+
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_set_equal(&ta, &tb);
+	if(rt)
+		printf("is equal\n");
+	else
+		printf("is not equal\n");
+
+	c_set_clear(&ta);
+	c_set_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+	rt = c_set_equal(&ta, &tb);
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	c_set_clear(&ta);
+	c_set_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+	rt = c_set_equal(&ta, &tb);
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	return 0;
+}
+
+int t_set()
+{
+	c_set set;
+
+	c_set_create(&set, int_comparer);
+
+	assert(__c_rb_tree_verify(set._l));
+	printf("0. test create with insert unique\n");
+	create_with_insert_unique(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n1. test clear\n");
+	test_clear(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n2. test size and empty\n");
+	test_size_empty(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n3. test create with insert equal\n");
+	c_set_clear(&set);
+	create_with_insert_equal(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n4. test swap\n");
+	test_swap(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n5. test create with insert unique1\n");
+	create_with_insert_unique1(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n6. test create with insert equal1\n");
+	c_set_clear(&set);
+	create_with_insert_equal1(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n7. test create with insert unique2\n");
+	c_set_clear(&set);
+	create_with_insert_unique2(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n8. test create with insert equal2\n");
+	c_set_clear(&set);
+	create_with_insert_equal2(&set);
+	print_set(&set);
+	rprint_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+	
+	printf("\n\n9. test erase\n");
+	c_set_clear(&set);
+	create_with_insert_unique(&set);
+	test_erase(&set);
+	create_with_insert_unique(&set);	
+	test_reverse_erase(&set);	
+	print_set(&set);
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n10. test find and erase\n");
+	c_set_clear(&set);
+	printf("* test_find_erase:\n");
+	create_with_insert_unique(&set);
+	print_set(&set);	
+	test_find_erase(&set);
+	print_set(&set);	
+	printf("* test_reverse_find_erase:\n");
+	create_with_insert_unique(&set);
+	print_set(&set);	
+	test_reverse_find_erase(&set);
+	print_set(&set);	
+	assert(__c_rb_tree_verify(set._l));
+
+	printf("\n\n11. test count:\n"); // 'lower_bound' 'upper_bound' 'equal_range' used	
+	test_count(&set);
+
+	printf("\n\n12. test less:\n");
+	test_less();
+
+	printf("\n\n13. test equal:\n");
+	test_equal();
+	
+	c_set_destroy(&set);
+	printf("\n\nfinish testing set!\n");
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_stack.c b/src/tstl2cl/test/t_stack.c
new file mode 100644
index 0000000..d123855
--- /dev/null
+++ b/src/tstl2cl/test/t_stack.c
@@ -0,0 +1,143 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "c_stack.h"
+#include "c_vector.h"
+#include "t_test.h"
+
+static int ary[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
+#define SIZE 10
+
+
+static int int_comparer(value_type x, value_type y)
+{
+	return *(int *)x - *(int *)y;
+}
+
+static int create_with_push(c_pstack ps, int ary[])
+{
+	int i = 0;
+	for(i = 0; i < SIZE; ++ i)
+	{
+		c_stack_push(ps, &ary[i]);
+	}
+	return 0;
+}	
+
+static int print_stack(c_pstack ps)
+{
+	c_vector tmpvt;
+	__c_vector(&tmpvt, int_comparer);
+
+	printf("stack is : \n");
+	while(!c_stack_empty(ps))
+	{
+		int * tmp = c_stack_top(ps);
+		printf("elem is : %d, size is : %d\n", *tmp, c_stack_size(ps));
+		c_stack_pop(ps);
+		c_vector_push_back(&tmpvt, tmp);
+	}
+
+	// recover stack
+	do
+	{
+		c_reverse_iterator riter = c_vector_rbegin(&tmpvt);
+		c_reverse_iterator rend = c_vector_rend(&tmpvt);
+		for(; !ITER_EQUAL(riter, rend); ITER_INC(riter))
+		{
+			c_stack_push(ps, ITER_REF(riter));
+		}
+	} while(0);	
+
+	__c_rotcev(&tmpvt);
+	return 0;
+}
+
+static int clear_stack(c_pstack ps)
+{
+	while(!c_stack_empty(ps))
+	{
+		c_stack_pop(ps);
+	}
+
+	return 0;
+}	
+
+
+int t_stack()
+{
+	c_stack stack, stack1;
+	int ary1[] = { 2, 3, 4, 5, 6, 7, 8, 9, 0, 1 }; 
+	__c_stack(&stack, int_comparer);
+	__c_stack(&stack1, int_comparer);
+
+	create_with_push(&stack, ary);
+	printf("stack: \n");
+	print_stack(&stack);
+
+	create_with_push(&stack1, ary1);
+	printf("stack1: \n");
+	print_stack(&stack1);
+	
+	if(c_stack_equal(&stack, &stack1))
+		printf("stack == stack1\n");
+	else
+		printf("stack != stack1\n");
+
+	clear_stack(&stack);
+	clear_stack(&stack1);
+
+	create_with_push(&stack, ary1);
+	printf("stack: \n");
+	print_stack(&stack);
+
+	create_with_push(&stack1, ary1);
+	printf("stack1: \n");
+	print_stack(&stack1);
+
+	if(c_stack_equal(&stack, &stack1))
+		printf("stack == stack1\n");
+	else
+		printf("stack != stack1\n");
+
+
+	clear_stack(&stack);
+	clear_stack(&stack1);
+
+	create_with_push(&stack, ary);
+	printf("stack: \n");
+	print_stack(&stack);
+
+	create_with_push(&stack1, ary1);
+	printf("stack1: \n");
+	print_stack(&stack1);
+	
+	if(c_stack_less(&stack, &stack1))
+		printf("stack < stack1\n");
+	else
+		printf("stack >= stack1\n");
+
+	clear_stack(&stack);
+	clear_stack(&stack1);
+
+	create_with_push(&stack, ary1);
+	printf("stack: \n");
+	print_stack(&stack);
+
+	create_with_push(&stack1, ary1);
+	printf("stack1: \n");
+	print_stack(&stack1);
+
+	if(c_stack_less(&stack, &stack1))
+		printf("stack < stack1\n");
+	else
+		printf("stack >= stack1\n");
+
+
+
+	__c_kcats(&stack);
+	__c_kcats(&stack1);
+
+	printf("\nfinish testing stack!\n\n");
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_test.h b/src/tstl2cl/test/t_test.h
new file mode 100644
index 0000000..dca16ff
--- /dev/null
+++ b/src/tstl2cl/test/t_test.h
@@ -0,0 +1,8 @@
+#ifndef __T_TEST_H
+#define __T_TEST_H
+
+#ifdef _MSC_VER
+#define inline __inline
+#endif
+
+#endif
diff --git a/src/tstl2cl/test/t_tree.c b/src/tstl2cl/test/t_tree.c
new file mode 100644
index 0000000..0de6979
--- /dev/null
+++ b/src/tstl2cl/test/t_tree.c
@@ -0,0 +1,672 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "../include/c_def.h"
+#include "../include/c_vector.h"
+#include "../c_tree.h"
+#include <assert.h>
+#include "t_test.h"
+
+
+#define MAP	0
+#define SET	1
+
+#define IMPL	MAP
+//#define IMPL 	SET
+
+
+static int values[] = 
+{ 
+	8,	/* 0 */
+	3,	/* 1 */
+	8,	/* 2 */
+	4,	/* 3 */
+	3,	/* 4 */
+	8,	/* 5 */
+	5,	/* 6 */
+	43,	/* 7 */
+	994,	/* 8 */
+	32,	/* 9 */
+	6,	/* 10 */
+	9,	/* 11 */
+	3,	/* 12 */
+	7,	/* 13 */
+	7,	/* 14 */
+	32,	/* 15 */
+	8,	/* 16 */
+	2,	/* 17 */
+	343 	/* 18 */
+};
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+static int keys[] = 
+{ 
+	12,	/* 0 */	
+	4,	/* 1 */	
+	71,	/* 2 */
+	2,	/* 3 */
+	90,	/* 4 */
+	99,	/* 5 */
+	30,	/* 6 */
+	61,	/* 7 */
+	29,	/* 8 */
+	84,	/* 9 */
+	6,	/* 10 */
+	97,	/* 11 */
+	3,	/* 12 */
+	8,	/* 13 */
+	54,	/* 14 */
+	78,	/* 15 */
+	9,	/* 16 */
+	16,	/* 17 */
+	62,	/* 18 */
+};
+
+static c_pair pairs[] =
+{
+	{ &keys[0], &values[0] },
+	{ &keys[1], &values[1] },
+	{ &keys[2], &values[2] },
+	{ &keys[3], &values[3] },
+	{ &keys[4], &values[4] },
+	{ &keys[5], &values[5] },
+	{ &keys[6], &values[6] },
+	{ &keys[7], &values[7] },
+	{ &keys[8], &values[8] },
+	{ &keys[9], &values[9] },
+	{ &keys[10], &values[10] },
+	{ &keys[11], &values[11] },
+	{ &keys[12], &values[12] },
+	{ &keys[13], &values[13] },
+	{ &keys[14], &values[14] },
+	{ &keys[15], &values[15] },
+	{ &keys[16], &values[16] },
+	{ &keys[17], &values[17] },
+	{ &keys[18], &values[18] }
+};
+
+static inline int pair_comparer(void * x, void * y)
+{
+	value_type x_f = ((c_ppair)x)->first;
+	value_type x_s = ((c_ppair)x)->second;
+	value_type y_f = ((c_ppair)y)->first;
+	value_type y_s = ((c_ppair)y)->second;
+	int f_val = int_comparer(x_f, y_f);
+	if(!f_val)
+		return int_comparer(x_s, y_s);
+	else
+		return f_val; 
+}
+
+
+
+int print_tree(c_prb_tree pt)
+{
+	c_iterator iter = c_rb_tree_begin(pt);
+	c_iterator end = c_rb_tree_end(pt);
+	printf("tree is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+#if IMPL == MAP
+		printf("key = %d, value = %d\n",
+			*(int*)((c_ppair)ITER_REF(iter))->first,
+			*(int*)((c_ppair)ITER_REF(iter))->second);
+#endif
+
+#if IMPL == SET
+		printf("value = %d\n",
+			*(int*)(ITER_REF(iter)));
+#endif
+	}
+	return 0;
+}
+
+int rprint_tree(c_prb_tree pt)
+{
+	c_reverse_iterator iter = c_rb_tree_rbegin(pt);
+	c_reverse_iterator end = c_rb_tree_rend(pt);
+	printf("tree is:\n");
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+#if IMPL == MAP
+		printf("key = %d, value = %d\n",
+			*(int*)((c_ppair)ITER_REF(iter))->first,
+			*(int*)((c_ppair)ITER_REF(iter))->second);
+#endif
+
+#if IMPL == SET
+		printf("value = %d\n",
+			*(int*)(ITER_REF(iter)));
+#endif
+	}
+	return 0;
+}
+
+
+int create_with_insert_unique(c_prb_tree thiz)
+{
+	int i = 0;
+	for(; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+#if IMPL == MAP
+		c_rb_tree_insert_unique(thiz, &pairs[i]);
+#endif
+#if IMPL == SET
+		c_rb_tree_insert_unique(thiz, &keys[i]);
+#endif
+		assert(__c_rb_tree_verify(thiz));
+	}
+	return 0;
+}
+
+int create_with_insert_equal(c_prb_tree thiz)
+{
+	int i = 0;
+	for(; i < sizeof(values) / sizeof(int); ++ i)
+	{
+#if IMPL == MAP
+		c_rb_tree_insert_equal(thiz, &pairs[i]);
+#endif
+#if IMPL == SET
+		c_rb_tree_insert_equal(thiz, &values[i]);
+#endif
+		assert(__c_rb_tree_verify(thiz));
+	}
+	return 0;
+}
+
+int test_clear(c_prb_tree thiz)
+{
+	c_iterator begin, end;
+	c_reverse_iterator rbegin, rend;
+	c_rb_tree_clear(thiz);
+	begin = c_rb_tree_begin(thiz);
+	end = c_rb_tree_end(thiz);
+	rbegin = c_rb_tree_rbegin(thiz);
+	rend = c_rb_tree_rend(thiz);
+	
+	if(c_rb_tree_size(thiz) == 0)
+		printf("ok, size is 0\n");
+	else
+		printf("error, size is not 0\n");
+	
+	if(ITER_EQUAL(begin, end))
+		printf("ok, begin == end\n");
+	else
+		printf("error, begin != end\n");
+	
+	if(ITER_EQUAL(rbegin, rend))
+		printf("ok, rbegin == rend\n");
+	else
+		printf("error, rbegin != rend\n");
+	return 0;
+}
+
+int test_size_empty(c_prb_tree thiz)
+{
+	int i = 0;
+	printf("max size is %d\n", c_rb_tree_max_size(thiz));
+	printf("size is %d\n", c_rb_tree_size(thiz));
+	printf("is empty? %s\n", c_rb_tree_empty(thiz) ? "yes" : "no");
+	
+	for(; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		printf("now insert %d\n", i + 1);
+#if IMPL == MAP
+		c_rb_tree_insert_unique(thiz, &pairs[i]);
+#endif
+#if IMPL == SET
+		c_rb_tree_insert_unique(thiz, &values[i]);
+#endif
+		printf("size is %d\n", c_rb_tree_size(thiz));
+		printf("is empty? %s\n", c_rb_tree_empty(thiz) ? "yes" : "no");
+	}
+	printf("now clear\n");
+	c_rb_tree_clear(thiz);
+	printf("size is %d\n", c_rb_tree_size(thiz));
+	printf("is empty? %s\n", c_rb_tree_empty(thiz) ? "yes" : "no");
+
+	return 0;
+}
+
+int test_swap(c_prb_tree thiz)
+{
+	c_rb_tree tr;
+	c_rb_tree_create(&tr, int_comparer);	
+#if IMPL == MAP
+	tr._A_keyofvalue = c_select1st();	
+#endif
+
+#if IMPL == SET
+	tr._A_keyofvalue = c_identity();
+#endif
+	c_rb_tree_swap(thiz, &tr);
+	printf("after swap\n");
+	print_tree(&tr);
+	c_rb_tree_destroy(&tr);	
+	return 0;
+}
+
+int create_with_insert_unique1(c_prb_tree thiz)
+{
+	c_iterator iter = c_rb_tree_begin(thiz);
+	int i = 0;
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+#if IMPL == MAP
+		iter = c_rb_tree_insert_unique1(thiz, iter, &pairs[i]);
+#else
+		iter = c_rb_tree_insert_unique1(thiz, iter, &keys[i]);
+#endif
+		assert(__c_rb_tree_verify(thiz));
+	}
+	return 0;
+}
+
+int create_with_insert_equal1(c_prb_tree thiz)
+{
+	c_iterator iter = c_rb_tree_begin(thiz);
+	int i = 0;
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+#if IMPL == MAP
+		iter = c_rb_tree_insert_equal1(thiz, iter, &pairs[i]);
+#else
+		iter = c_rb_tree_insert_equal1(thiz, iter, &values[i]);
+#endif	
+		assert(__c_rb_tree_verify(thiz));
+	}
+	return 0;
+}
+
+int create_with_insert_unique2(c_prb_tree thiz)
+{
+	c_vector vt;
+	int i = 0;
+	c_vector_create(&vt, int_comparer);
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_iterator v_beg, v_end;
+#if IMPL == MAP
+		c_vector_push_back(&vt, &pairs[i]);
+#else
+		c_vector_push_back(&vt, &keys[i]);
+#endif
+		v_beg = c_vector_begin(&vt);
+		v_end = c_vector_end(&vt);
+		c_rb_tree_insert_unique2(thiz, v_beg, v_end);
+
+		assert(__c_rb_tree_verify(thiz));
+	}
+
+	c_vector_destroy(&vt);
+	return 0;
+}
+
+int create_with_insert_equal2(c_prb_tree thiz)
+{
+	c_vector vt;
+	int i = 0;
+	c_vector_create(&vt, int_comparer);
+	for(i = 0; i < sizeof(values) / sizeof(int); ++ i)
+	{
+		c_iterator v_beg, v_end;
+#if IMPL == MAP
+		c_vector_push_back(&vt, &pairs[i]);
+#else
+		c_vector_push_back(&vt, &values[i]);
+#endif
+		v_beg = c_vector_begin(&vt);
+		v_end = c_vector_end(&vt);
+		c_rb_tree_insert_equal2(thiz, v_beg, v_end);
+		
+		assert(__c_rb_tree_verify(thiz));
+	}
+
+	c_vector_destroy(&vt);
+	return 0;
+}
+
+void assert_valid_iter(c_prb_tree thiz, c_iterator val)
+{
+	c_iterator end = c_rb_tree_end(thiz);
+	c_iterator iter = c_rb_tree_begin(thiz);
+	for(; !ITER_EQUAL(iter, end); ITER_INC(iter))
+	{
+		if(ITER_EQUAL(iter, val))
+			return;
+	}
+	assert(false);
+}
+
+int test_erase(c_prb_tree thiz)
+{
+	c_iterator iter = c_rb_tree_begin(thiz);
+	c_iterator end = c_rb_tree_end(thiz);
+	assert(__c_rb_tree_verify(thiz));
+	//c_rb_tree_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = iter;
+		assert_valid_iter(thiz, to_erase);
+		c_rb_tree_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz));
+		
+		iter = c_rb_tree_begin(thiz);
+		end = c_rb_tree_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz));
+	assert(c_rb_tree_empty(thiz));
+	return 0;
+}
+
+int test_reverse_erase(c_prb_tree thiz)
+{
+	c_iterator iter = c_rb_tree_begin(thiz);
+	c_iterator end = c_rb_tree_end(thiz);
+	assert(__c_rb_tree_verify(thiz));
+	//c_rb_tree_erase(thiz, end);  // erasing end results in error
+	assert(__c_rb_tree_verify(thiz));
+	while(!ITER_EQUAL(iter, end))
+	{
+		c_iterator to_erase = end;
+		ITER_DEC(to_erase);
+		assert_valid_iter(thiz, to_erase);
+		c_rb_tree_erase(thiz, to_erase);
+		assert(__c_rb_tree_verify(thiz));
+
+		iter = c_rb_tree_begin(thiz);
+		end = c_rb_tree_end(thiz);
+	}
+	assert(__c_rb_tree_verify(thiz));
+	assert(c_rb_tree_empty(thiz));
+	return 0;
+}
+
+int test_find_erase(c_prb_tree thiz)
+{
+	int j = 0;
+	for(j = 0; j < sizeof(keys) / sizeof(int); ++ j)
+	{
+		c_iterator target, tree_end;	
+		printf("j = %d, key = %d\n", j, keys[j]);
+
+		target = c_rb_tree_find(thiz, &keys[j]); // set same as map 
+			
+		tree_end = c_rb_tree_end(thiz);
+		if(!ITER_EQUAL(tree_end, target))
+		{
+#if IMPL == MAP
+			printf("to erase : %d\n", *(int*)(((c_ppair)ITER_REF(target))->first));
+#else
+			printf("to erase : %d\n", *(int*)ITER_REF(target));
+#endif
+
+			assert_valid_iter(thiz, target);
+			c_rb_tree_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz));
+		}			
+	}
+	return 0;
+}
+
+int test_reverse_find_erase(c_prb_tree thiz)
+{
+	int j = 0;
+	for(j = sizeof(keys) / sizeof(int) - 1; j >= 0; -- j)
+	{
+		c_iterator target, tree_end;	
+		printf("j = %d\n", j);
+
+		target = c_rb_tree_find(thiz, &keys[j]); // set same as map
+		
+		tree_end = c_rb_tree_end(thiz);
+		if(!ITER_EQUAL(tree_end, target))
+		{			
+#if IMPL == MAP
+			printf("to erase : %d\n", *(int*)(((c_ppair)ITER_REF(target))->first));
+#else
+			printf("to erase : %d\n", *(int*)ITER_REF(target));
+#endif
+			assert_valid_iter(thiz, target);
+			c_rb_tree_erase(thiz, target);
+			assert(__c_rb_tree_verify(thiz));
+		}			
+	}
+	return 0;	
+}
+
+int test_count(c_prb_tree thiz)
+{
+	int i = 0;
+	create_with_insert_equal2(thiz);
+		
+	for(i = 0; i < sizeof(keys) / sizeof(int); ++ i)
+	{
+		size_t count = c_rb_tree_count(thiz, &keys[i]);
+		printf("i : %d; key : %d; count : %d\n", i, keys[i], count);
+	}
+	return 0;
+}
+
+int test_less()
+{
+	c_bool rt;
+	c_rb_tree ta, tb;
+
+	c_rb_tree_create(&ta, int_comparer);
+	c_rb_tree_create(&tb, int_comparer);
+
+#if IMPL == MAP
+	ta._A_keyofvalue = tb._A_keyofvalue = c_select1st();
+#else
+	ta._A_keyofvalue = tb._A_keyofvalue = c_identity();
+#endif
+
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_less(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_less(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is less\n");
+	else
+		printf("is not less\n");
+
+	c_rb_tree_clear(&ta);
+	c_rb_tree_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_less(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_less(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	c_rb_tree_clear(&ta);
+	c_rb_tree_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_less(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_less(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is less\n");
+	else 
+		printf("is not less\n");
+
+	return 0;
+}
+
+
+int test_equal()
+{
+	c_bool rt;
+	c_rb_tree ta, tb;
+
+	c_rb_tree_create(&ta, int_comparer);
+	c_rb_tree_create(&tb, int_comparer);
+
+#if IMPL == MAP
+	ta._A_keyofvalue = tb._A_keyofvalue = c_select1st();
+#else
+	ta._A_keyofvalue = tb._A_keyofvalue = c_identity();
+#endif
+
+	create_with_insert_equal(&ta);
+	create_with_insert_equal(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_equal(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_equal(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is equal\n");
+	else
+		printf("is not equal\n");
+
+	c_rb_tree_clear(&ta);
+	c_rb_tree_clear(&tb);
+	create_with_insert_unique(&ta);
+	create_with_insert_equal(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_equal(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_equal(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	c_rb_tree_clear(&ta);
+	c_rb_tree_clear(&tb);
+	create_with_insert_equal(&ta);
+	create_with_insert_unique(&tb);
+#if IMPL == MAP
+	rt = c_rb_tree_equal(&ta, &tb, pair_comparer);
+#else
+	rt = c_rb_tree_equal(&ta, &tb, int_comparer);
+#endif
+	if(rt)
+		printf("is equal\n");
+	else 
+		printf("is not equal\n");
+
+	return 0;
+}
+
+int t_tree()
+{
+	c_rb_tree tree;
+
+	__c_rb_tree(&tree, int_comparer);
+
+#if IMPL == MAP
+	tree._A_keyofvalue = c_select1st();	
+#endif
+#if IMPL == SET
+	tree._A_keyofvalue = c_identity();
+#endif
+
+	assert(__c_rb_tree_verify(&tree));
+	printf("0. test create with insert unique\n");
+	create_with_insert_unique(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n1. test clear\n");
+	test_clear(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n2. test size and empty\n");
+	test_size_empty(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n3. test create with insert equal\n");
+	c_rb_tree_clear(&tree);
+	create_with_insert_equal(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n4. test swap\n");
+	test_swap(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n5. test create with insert unique1\n");
+	create_with_insert_unique1(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n6. test create with insert equal1\n");
+	c_rb_tree_clear(&tree);
+	create_with_insert_equal1(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n7. test create with insert unique2\n");
+	c_rb_tree_clear(&tree);
+	create_with_insert_unique2(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n8. test create with insert equal2\n");
+	c_rb_tree_clear(&tree);
+	create_with_insert_equal2(&tree);
+	print_tree(&tree);
+	rprint_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+	
+	printf("\n\n9. test erase\n");
+	c_rb_tree_clear(&tree);
+	create_with_insert_unique(&tree);
+	test_erase(&tree);
+	create_with_insert_unique(&tree);	
+	test_reverse_erase(&tree);	
+	print_tree(&tree);
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n10. test find and erase\n");
+	c_rb_tree_clear(&tree);
+	printf("* test_find_erase:\n");
+	create_with_insert_unique(&tree);
+	print_tree(&tree);	
+	test_find_erase(&tree);
+	print_tree(&tree);	
+	printf("* test_reverse_find_erase:\n");
+	create_with_insert_unique(&tree);
+	print_tree(&tree);	
+	test_reverse_find_erase(&tree);
+	print_tree(&tree);	
+	assert(__c_rb_tree_verify(&tree));
+
+	printf("\n\n11. test count:\n"); // 'lower_bound' 'upper_bound' 'equal_range' used	
+	test_count(&tree);
+
+	printf("\n\n12. test less:\n");
+	test_less();
+
+	printf("\n\n13. test equal:\n");
+	test_equal();
+	
+	__c_eert_br(&tree);
+	printf("\n\nfinish testing tree!\n");
+	return 0;
+}
diff --git a/src/tstl2cl/test/t_vector.c b/src/tstl2cl/test/t_vector.c
new file mode 100644
index 0000000..46abdd0
--- /dev/null
+++ b/src/tstl2cl/test/t_vector.c
@@ -0,0 +1,365 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "../include/c_vector.h"
+#include "../include/c_algorithm.h"
+#include "t_test.h"
+
+
+static int array[] = { 0,1,2,3,4,5,6,7,8,9,10 };
+
+
+
+static inline int int_comparer(void * x, void * y)
+{
+    return *(int *)(x) - *(int *)(y);
+}
+
+static void print_vector2(c_iterator first, c_iterator last)
+{
+    c_iterator iter;
+    printf("vector is :\n"); 
+    for(iter = first;
+          !ITER_EQUAL(iter, last); ITER_INC(iter))
+    {
+        if(ITER_REF(iter))
+            printf("\t%d\n", *((int *)(ITER_REF(iter))));
+    }
+} 
+
+static void print_vector2_r(c_reverse_iterator first, c_reverse_iterator last)
+{
+    c_reverse_iterator iter;
+    printf("vector is :\n");
+    for(iter = first; 
+            !ITER_EQUAL(iter, last); ITER_INC(iter))
+    {
+        printf("\t%d\n", *((int *)(ITER_REF(iter))));
+    }
+}
+
+static void print_vector(c_vector * p)
+{
+    c_iterator first, last;
+    first = c_vector_begin(p);
+    last = c_vector_end(p);
+    print_vector2(first, last);
+}
+
+static void reverse_print_vector(c_vector * p)
+{
+    c_reverse_iterator first, last;
+    first = c_vector_rbegin(p);
+    last = c_vector_rend(p);
+    print_vector2_r(first, last);
+} 
+
+static void create_with_push_back(c_vector * p)
+{
+    int i = 0;
+    for (; i < sizeof(array) / sizeof(int); ++ i)
+    {
+        c_vector_push_back(p, &array[i]);
+    }
+}
+
+static void clear_vector(c_vector * p)
+{
+    c_vector_clear(p);
+}
+
+static void erase_vector()
+{
+    c_vector vt;
+    c_vector * p = &vt;
+    c_iterator i1, i3, i4, i6, i10;
+    
+    __c_vector(&vt, int_comparer);
+    
+    create_with_push_back(&vt);
+    i1 = c_vector_begin(p);
+    print_vector(p);
+    
+    printf("erase last :\n");
+    i10 = ITER_POSITIVE_N(i1, 10);
+    c_vector_erase(p, i10);
+    print_vector(p);
+    
+    printf("erase middle 1 : \n");
+    i4 = ITER_POSITIVE_N(i1, 4);
+    c_vector_erase(p, i4);
+    print_vector(p);
+    
+    printf("erase middle n : \n");
+    i3 = ITER_POSITIVE_N(i1, 3);
+    i6 = ITER_POSITIVE_N(i1, 6);
+    c_vector_erase2(p, i3, i6);
+    print_vector(p);
+    
+    printf("erase first :\n");
+    c_vector_erase(p, i1);
+    print_vector(p);   
+    
+    printf("erase all :\n");
+    c_vector_erase2(p, c_vector_begin(p), c_vector_end(p));
+    print_vector(p); 
+    
+    __c_rotcev(&vt);
+}
+
+
+static void vector_assign(c_vector * p)
+{
+    c_vector new_vt;
+    __c_vector(&new_vt, int_comparer);
+    
+    c_vector_assign(&new_vt, p);
+    
+    printf("new vector :\n");
+    print_vector(&new_vt);
+    __c_rotcev(&new_vt);    
+}
+
+static void vector_reserve(c_vector * p)
+{
+    c_vector newvt;
+    __c_vector(&newvt, int_comparer);
+
+    printf("capacity original : %d\n", c_vector_capacity(p));
+    c_vector_reserve(p, c_vector_capacity(p) + 5);
+    printf("new capacity : %d\n", c_vector_capacity(p));
+    
+    printf("\nempty capacity : %d\n", c_vector_capacity(&newvt));
+    c_vector_reserve(&newvt, c_vector_capacity(&newvt) + 5);
+    printf("new capacity : %d\n", c_vector_capacity(&newvt));
+       
+    __c_rotcev(&newvt);
+}
+
+static void vector_front_back(c_vector * p)
+{
+    printf("front of vector : %d\n", *(int*)c_vector_front(p)); 
+    printf("back of vector : %d\n", *(int*)c_vector_back(p));  
+}
+
+static void vector_swap(c_vector * p)
+{
+    c_vector lvt;
+    __c_vector(&lvt, int_comparer);
+    c_vector_push_back(&lvt, &array[3]);
+    
+    c_vector_swap(p, &lvt);
+    printf("local vector is : \n");
+    print_vector(&lvt);
+    printf("outside vector is : \n");
+    print_vector(p);
+    __c_rotcev(&lvt);    
+}
+
+static void vector_insert(c_vector * p)
+{
+    c_iterator iter;
+    c_vector_insert(p, c_vector_end(p), &array[0]);
+    c_vector_insert(p, c_vector_begin(p), &array[2]);
+    c_vector_insert(p, c_vector_end(p), &array[4]);
+    c_vector_insert(p, c_vector_end(p), &array[6]);
+    c_vector_insert(p, c_vector_begin(p), &array[8]);
+    
+    iter = c_vector_begin(p);
+    iter = ITER_POSITIVE_N(iter, 3);
+    c_vector_insert(p, iter, &array[5]);   
+    
+    printf("vector after insertion\n");
+    print_vector(p);
+}
+
+static void vector_insert2(c_vector * p)
+{
+    c_vector vt;
+    __c_vector(&vt, int_comparer);
+    
+    c_vector_insert2(&vt, 
+                    c_vector_begin(&vt), 
+                    c_vector_begin(p),
+                    c_vector_end(p));
+    printf("after insert2\n");
+    print_vector(&vt);
+    __c_rotcev(&vt);    
+}
+
+static void vector_fill_insert(c_vector * p)
+{
+    c_iterator iter = c_vector_begin(p);
+    
+    c_vector_fill_insert(p, ITER_INC(iter), 10, &array[8]);
+    printf("after fill insert middle\n");
+    print_vector(p);    
+    
+    c_vector_fill_insert(p, c_vector_begin(p), 10, &array[6]);
+    printf("after fill insert begin\n");
+    print_vector(p);    
+    
+    c_vector_fill_insert(p, c_vector_end(p), 10, &array[4]);
+    printf("after fill insert end\n");
+    print_vector(p);
+    
+}
+
+static void vector_resize(c_vector * p)
+{
+    print_vector(p);
+    printf("vector size : %d\n", c_vector_size(p));
+    c_vector_resize(p, 100);
+    print_vector(p);
+    printf("vector size : %d\n", c_vector_size(p));
+    c_vector_resize(p, 0);
+    print_vector(p);
+    printf("vector size : %d\n", c_vector_size(p));
+    create_with_push_back(p);
+    c_vector_resize(p, 3);
+    print_vector(p);
+    printf("vector size : %d\n", c_vector_size(p));    
+}
+
+static void vector_equal(c_vector * p)
+{
+    c_iterator iter;
+    int * old;
+    c_vector vt;
+    __c_vector(&vt, int_comparer);
+    
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_equal(&vt, p) ? "IS equal\n" : "NOT equal\n");
+    
+    create_with_push_back(&vt);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_equal(&vt, p) ? "IS equal\n" : "NOT equal\n");
+    
+    iter = c_vector_begin(&vt);
+    old = (int*)ITER_REF(iter); 
+    ITER_REF_ASSIGN(iter, &array[5]);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_equal(&vt, p) ? "IS equal\n" : "NOT equal\n");       
+    ITER_REF_ASSIGN(iter, old);
+    
+    c_vector_clear(&vt);
+    c_vector_clear(p);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_equal(&vt, p) ? "IS equal\n" : "NOT equal\n");
+    __c_rotcev(&vt);
+}
+
+static void vector_less(c_vector * p)
+{
+    c_iterator iter;
+    int * old;
+    c_vector vt;
+    __c_vector(&vt, int_comparer);
+    
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_less(&vt, p) ? "IS less\n" : "NOT less\n");
+    
+    create_with_push_back(&vt);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_less(&vt, p) ? "IS less\n" : "NOT less\n");
+    
+    iter = c_vector_begin(&vt);
+    old = (int*)ITER_REF(iter);
+    ITER_REF_ASSIGN(iter, &array[5]);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_less(&vt, p) ? "IS less\n" : "NOT less\n");
+    ITER_REF_ASSIGN(iter, old);
+    
+    ITER_INC_N(iter, 3);
+    old = (int*)ITER_REF(iter);
+    ITER_REF_ASSIGN(iter, &array[0]);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_less(&vt, p) ? "IS less\n" : "NOT less\n");
+        
+    c_vector_clear(&vt);
+    c_vector_clear(p);
+    print_vector(&vt);
+    print_vector(p);
+    printf(c_vector_less(&vt, p) ? "IS less\n" : "NOT less\n");
+    __c_rotcev(&vt);
+}
+
+
+int t_vector()
+{
+    c_vector vt;
+    __c_vector(&vt, int_comparer);
+    
+
+    printf("1.test create vector\n");
+    create_with_push_back(&vt);
+    print_vector(&vt);
+    reverse_print_vector(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n2.test vector assign\n");
+    create_with_push_back(&vt);    
+    vector_assign(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n3.test erase vector\n");
+    erase_vector();
+    
+    printf("\n\n4.test reserve vector\n");
+    create_with_push_back(&vt);
+    vector_reserve(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n5.test front back\n");
+    create_with_push_back(&vt);
+    vector_front_back(&vt);
+    clear_vector(&vt);
+
+    printf("\n\n6.test swap\n");
+    create_with_push_back(&vt);
+    vector_swap(&vt);
+    clear_vector(&vt);
+
+    printf("\n\n7.test insert\n");
+    vector_insert(&vt);
+    clear_vector(&vt);    
+    
+    printf("\n\n8.test insert2\n");
+    create_with_push_back(&vt);
+    vector_insert2(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n9.test fill insert\n");
+    create_with_push_back(&vt);
+    vector_fill_insert(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n10.test resize\n");
+    create_with_push_back(&vt);
+    vector_resize(&vt);
+    clear_vector(&vt);
+        
+    printf("\n\n11.test equal\n");
+    create_with_push_back(&vt);
+    vector_equal(&vt);
+    clear_vector(&vt);
+    
+    printf("\n\n12.test less\n");
+    create_with_push_back(&vt);
+    vector_less(&vt);
+    clear_vector(&vt);        
+    
+    __c_rotcev(&vt);
+    printf("\n\nfinish testing vector!\n");
+    return 0;
+}
+
diff --git a/src/tstl2cl/tstl2cl.dev b/src/tstl2cl/tstl2cl.dev
new file mode 100644
index 0000000..5d2ff3b
--- /dev/null
+++ b/src/tstl2cl/tstl2cl.dev
@@ -0,0 +1,409 @@
+[Project]
+FileName=tstl2cl.dev
+Name=tstl2cl
+UnitCount=36
+Type=1
+Ver=1
+ObjFiles=
+Includes=./include;.\include;./;.\;.
+Libs=
+PrivateResource=
+ResourceIncludes=
+MakeIncludes=
+Compiler=
+CppCompiler=
+Linker=
+IsCpp=0
+Icon=
+ExeOutput=
+ObjectOutput=
+OverrideOutput=0
+OverrideOutputName=tstl2cl.exe
+HostApplication=
+Folders=include,test
+CommandLine=
+UseCustomMakefile=0
+CustomMakefile=
+IncludeVersionInfo=0
+SupportXPThemes=0
+CompilerSet=0
+CompilerSettings=0000000000000001000000
+
+[Unit3]
+FileName=test\t_list.c
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+CompileCpp=0
+
+[Unit4]
+FileName=include\c_def.h
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+CompileCpp=0
+
+[Unit5]
+FileName=include\c_iterator.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit6]
+FileName=include\c_list.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit8]
+FileName=c_algo.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit9]
+FileName=c_function.h
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit10]
+FileName=c_memory.h
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[VersionInfo]
+Major=0
+Minor=1
+Release=1
+Build=1
+LanguageID=1033
+CharsetID=1252
+CompanyName=
+FileVersion=
+FileDescription=Developed using the Dev-C++ IDE
+InternalName=
+LegalCopyright=
+LegalTrademarks=
+OriginalFilename=
+ProductName=
+ProductVersion=
+AutoIncBuildNr=0
+
+[Unit1]
+FileName=c_list.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit2]
+FileName=c_memory.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit11]
+FileName=c_function.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit7]
+FileName=c_algo.h
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit12]
+FileName=include\c_algorithm.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit13]
+FileName=include\c_vector.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit14]
+FileName=c_vector.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit15]
+FileName=test\t_vector.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit17]
+FileName=c_pair.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit18]
+FileName=test\t_main.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit16]
+FileName=c_pair.h
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit19]
+FileName=c_tree.c
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit20]
+FileName=c_tree.h
+CompileCpp=0
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit21]
+FileName=test\t_tree.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit22]
+FileName=include\c_map.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit23]
+FileName=c_map.c
+CompileCpp=0
+Folder=tstl2cl
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit24]
+FileName=test\t_map.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit25]
+FileName=test\t_queue.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit26]
+FileName=test\t_set.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit27]
+FileName=test\t_stack.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit28]
+FileName=include\c_queue.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit29]
+FileName=include\c_set.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit30]
+FileName=include\c_stack.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit31]
+FileName=c_queue.c
+CompileCpp=0
+Folder=tstl2cl
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit32]
+FileName=c_set.c
+CompileCpp=0
+Folder=tstl2cl
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit33]
+FileName=c_stack.c
+CompileCpp=0
+Folder=tstl2cl
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit34]
+FileName=c_iterator.c
+CompileCpp=0
+Folder=tstl2cl
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit35]
+FileName=include\c_functional.h
+CompileCpp=0
+Folder=include
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit36]
+FileName=test\t_algo.c
+CompileCpp=0
+Folder=test
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
-- 
1.9.4.msysgit.2

